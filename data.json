[
  {
    "filename": "/mnt/f/Node/cmmv-admin/vite.config.ts",
    "type": "Constant",
    "value": "env",
    "snippet": "const env = loadEnv(mode, process.cwd(), 'VITE')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/main.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = createApp(App)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.interface.ts",
    "type": "Interface",
    "value": "DatasetEntry",
    "snippet": "interface DatasetEntry {\n  filename: string;\n  type:\n    | 'Function'\n    | 'Class'\n    | 'Interface'\n    | 'Enum'\n    | 'Variable'\n    | 'Symbol'\n    | 'Decorator'\n    | 'AbstractClass'\n    | 'Constant';\n  value: string;\n  snippet: string;\n  vector: Float32Array;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Class",
    "value": "Dataset",
    "snippet": "@Service('ai-dataset')\nexport class Dataset {\n  private logger = new Logger('Dataset');\n  private data: DatasetEntry[] = [];\n  private indexSize = 384;\n\n  addEntry(entry: DatasetEntry) {\n    if (!(entry.vector instanceof Float32Array))\n      throw new Error('Invalid vector format, expected Float32Array.');\n\n    if (entry.vector.length !== this.indexSize)\n      throw new Error(\n        `Vector length mismatch: Expected ${this.indexSize}, got ${entry.vector.length}`,\n      );\n\n    this.logger.verbose(\n      `Index ${entry.type}:${entry.value} (${entry.filename})`,\n    );\n    this.data.push(entry);\n  }\n\n  save() {\n    const filePath = Config.get('ai.tokenizer.output', './data.bin');\n    const buffer = Buffer.alloc(this.data.length * (this.indexSize * 4));\n    fs.writeFileSync(\n      filePath.replace('.bin', '.json'),\n      JSON.stringify(\n        this.data.map(({ vector, ...rest }) => rest),\n        null,\n        2,\n      ),\n    );\n\n    this.logger.verbose(`Save index: ${filePath.replace('.bin', '.json')}`);\n\n    this.data.forEach((entry, i) => {\n      Buffer.from(entry.vector.buffer).copy(buffer, i * (this.indexSize * 4));\n    });\n\n    this.logger.verbose(`Save dataset: ${filePath}`);\n\n    fs.writeFileSync(filePath, buffer);\n  }\n\n  load() {\n    const filePath = Config.get('ai.tokenizer.output', './data.bin');\n\n    if (fs.existsSync(filePath)) {\n      const jsonData = JSON.parse(\n        fs.readFileSync(filePath.replace('.bin', '.json'), 'utf-8'),\n      );\n      const buffer = fs.readFileSync(filePath);\n\n      this.data = jsonData.map((entry: any, i: number) => ({\n        ...entry,\n        vector: new Float32Array(\n          buffer.buffer,\n          i * (this.indexSize * 4),\n          this.indexSize,\n        ),\n      }));\n\n      console.log(\n        `ðŸ“¥ Dataset carregado (${this.data.length} entradas) do binÃ¡rio.`,\n      );\n    }\n  }\n\n  /*search(queryVector: Float32Array, topK = 5): DatasetEntry[] {\n        const D = new Float32Array(topK);\n        const I = new Int32Array(topK);\n        this.index.search(queryVector, topK, D, I);\n\n        return I.map((idx) => (idx >= 0 ? this.data[idx] : null)).filter((item) => item !== null) as DatasetEntry[];\n    }*/\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Constant",
    "value": "filePath",
    "snippet": "const filePath = Config.get('ai.tokenizer.output', './data.bin');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Constant",
    "value": "buffer",
    "snippet": "const buffer = Buffer.alloc(this.data.length * (this.indexSize * 4));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Constant",
    "value": "filePath",
    "snippet": "const filePath = Config.get('ai.tokenizer.output', './data.bin');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Constant",
    "value": "jsonData",
    "snippet": "const jsonData = JSON.parse(\n        fs.readFileSync(filePath.replace('.bin', '.json'), 'utf-8'),\n      );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/dataset.provider.ts",
    "type": "Constant",
    "value": "buffer",
    "snippet": "const buffer = fs.readFileSync(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/index.ts",
    "type": "Constant",
    "value": "AIModule",
    "snippet": "const AIModule = new Module('ai', {\n  configs: [],\n  providers: [Tokenizer, Dataset],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.interface.ts",
    "type": "Interface",
    "value": "TokenizerOptions",
    "snippet": "interface TokenizerOptions {\n  patterns: fg.Pattern | fg.Pattern[];\n  embeddingModel?: 'all-MiniLM-L6-v2' | 'codellama';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.interface.ts",
    "type": "Interface",
    "value": "TokenizedSnippet",
    "snippet": "interface TokenizedSnippet {\n  filename: string;\n  type: string;\n  value: string;\n  snippet: string;\n  vector: any;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Class",
    "value": "Tokenizer",
    "snippet": "@Service('ai-tokenizer')\nexport class Tokenizer extends EventEmitter {\n  private logger = new Logger('Tokenizer');\n  private options: TokenizerOptions;\n  private embedder: any;\n  private dataset: Dataset = new Dataset();\n\n  async initialize() {\n    const TransformersApi = Function('return import(\"@xenova/transformers\")')();\n    const { pipeline } = await TransformersApi;\n    const embeddingModel = Config.get(\n      'ai.tokenizer.embeddingModel',\n      'codellama',\n    );\n    const token = Config.get('ai.huggingface.token');\n    this.embedder = await pipeline('feature-extraction', embeddingModel, {\n      token,\n    });\n    this.logger.verbose(`Start embedder: ${embeddingModel}`);\n  }\n\n  async start() {\n    const patterns = Config.get('ai.tokenizer.patterns', ['**/*.ts']);\n    const ignore = Config.get('ai.tokenizer.ignore', ['**/*.ts']);\n    const exclude = Config.get('ai.tokenizer.exclude', []);\n    const TraverseApi = Function('return import(\"@babel/traverse\")')();\n    const traverse = (await TraverseApi).default;\n\n    if (!this.embedder) await this.initialize();\n    this.logger.verbose(`Mapping files: ${patterns.join(',')}`);\n\n    const files = await fg(patterns, {\n      onlyFiles: true,\n      absolute: true,\n      ignore: ['node_modules', ...ignore],\n    });\n\n    this.logger.verbose(`Total files: ${files.length}`);\n\n    const promises: Promise<void>[] = [];\n    const ignoreDefault = [\n      'node_modules',\n      '.d.ts',\n      '.cjs',\n      '.spec.ts',\n      '.test.ts',\n      '.mjs',\n    ];\n\n    for (const filename of files) {\n      if (\n        ignore.some((ext) => filename.includes(ext)) ||\n        ignoreDefault.some((ext) => filename.includes(ext)) ||\n        exclude.some((ext) => filename.includes(ext))\n      )\n        continue;\n\n      this.logger.verbose(`Parsing: ${filename}`);\n      const content = fs.readFileSync(filename, 'utf-8');\n\n      const ast = parse(content, {\n        sourceType: 'module',\n        strictMode: false,\n        plugins: [\n          'typescript',\n          'jsx',\n          'decorators-legacy',//@ts-ignore\n          ['@babel/plugin-proposal-decorators', { legacy: true }],//@ts-ignore\n          'babel-plugin-parameter-decorator',\n        ],\n      });\n\n      traverse.default(ast, {\n        FunctionDeclaration: (path) => {\n          if (path.node.id) {\n            promises.push(\n              this.processEntity(\n                'Function',\n                filename,\n                path.node.id.name,\n                content,\n                path,\n              ),\n            );\n          }\n        },\n        ClassDeclaration: (path) => {\n            if (path.node.id && path.node.abstract) {\n              promises.push(\n                this.processEntity(\n                  'AbstractClass',\n                  filename,\n                  path.node.id.name,\n                  content,\n                  path,\n                ),\n              );\n            } else if (path.node.id) {\n              promises.push(\n                this.processEntity(\n                  'Class',\n                  filename,\n                  path.node.id.name,\n                  content,\n                  path,\n                ),\n              );\n            }\n        },\n        TSInterfaceDeclaration: (path) => {\n          if (path.node.id) {\n            promises.push(\n              this.processEntity(\n                'Interface',\n                filename,\n                path.node.id.name,\n                content,\n                path,\n              ),\n            );\n          }\n        },\n        TSEnumDeclaration: (path) => {\n          if (path.node.id) {\n            promises.push(\n              this.processEntity(\n                'Enum',\n                filename,\n                path.node.id.name,\n                content,\n                path,\n              ),\n            );\n          }\n        },\n        VariableDeclaration: (path) => {\n          if (path.node.kind === 'const') {\n            path.node.declarations.forEach((declaration) => {\n              if (declaration.id.type === 'Identifier') {\n                promises.push(\n                  this.processEntity(\n                    'Constant',\n                    filename,\n                    declaration.id.name,\n                    content,\n                    path,\n                  ),\n                );\n              }\n            });\n          }\n        },\n        Decorator: (path) => {\n          if (path.node.expression.type === 'Identifier') {\n            promises.push(\n              this.processEntity(\n                'Decorator',\n                filename,\n                path.node.expression.name,\n                content,\n                path,\n              ),\n            );\n          }\n        },\n        CallExpression: (path) => {\n          if (\n            path.node.callee.type === 'Identifier' &&\n            path.node.callee.name === 'Symbol'\n          ) {\n            if (path.node.arguments.length > 0) {\n              const symbolName = path.node.arguments[0].value;\n              if (typeof symbolName === 'string') {\n                promises.push(\n                  this.processEntity(\n                    'Symbol',\n                    filename,\n                    symbolName,\n                    content,\n                    path,\n                  ),\n                );\n              }\n            }\n          }\n        },\n      });\n    }\n\n    await Promise.all(promises);\n    this.dataset.save();\n  }\n\n  private async processEntity(\n    type: DatasetEntry['type'],\n    filename: string,\n    name: string,\n    content: string,\n    path: any,\n  ) {\n    try {\n      const snippet = content.slice(path.node.start!, path.node.end!);\n      const vector = await this.generateEmbedding(snippet);\n      this.dataset.addEntry({ filename, type, value: name, snippet, vector });\n    } catch (e) {\n      this.logger.error(e.message, filename);\n    }\n  }\n\n  private async generateEmbedding(text: string): Promise<Float32Array> {\n    const output = await this.embedder(text, {\n      pooling: 'mean',\n      normalize: true,\n    });\n\n    if (output.data.length !== 384)\n      throw new Error(\n        `Embedding size mismatch: Expected 384, got ${output.data.length}`,\n      );\n\n    return new Float32Array(output.data);\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "TransformersApi",
    "snippet": "const TransformersApi = Function('return import(\"@xenova/transformers\")')();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "embeddingModel",
    "snippet": "const embeddingModel = Config.get(\n      'ai.tokenizer.embeddingModel',\n      'codellama',\n    );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "token",
    "snippet": "const token = Config.get('ai.huggingface.token');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "patterns",
    "snippet": "const patterns = Config.get('ai.tokenizer.patterns', ['**/*.ts']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "ignore",
    "snippet": "const ignore = Config.get('ai.tokenizer.ignore', ['**/*.ts']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "exclude",
    "snippet": "const exclude = Config.get('ai.tokenizer.exclude', []);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "TraverseApi",
    "snippet": "const TraverseApi = Function('return import(\"@babel/traverse\")')();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "traverse",
    "snippet": "const traverse = (await TraverseApi).default;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "files",
    "snippet": "const files = await fg(patterns, {\n      onlyFiles: true,\n      absolute: true,\n      ignore: ['node_modules', ...ignore],\n    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "promises",
    "snippet": "const promises: Promise<void>[] = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "ignoreDefault",
    "snippet": "const ignoreDefault = [\n      'node_modules',\n      '.d.ts',\n      '.cjs',\n      '.spec.ts',\n      '.test.ts',\n      '.mjs',\n    ];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "filename",
    "snippet": "const filename"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = fs.readFileSync(filename, 'utf-8');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "ast",
    "snippet": "const ast = parse(content, {\n        sourceType: 'module',\n        strictMode: false,\n        plugins: [\n          'typescript',\n          'jsx',\n          'decorators-legacy',//@ts-ignore\n          ['@babel/plugin-proposal-decorators', { legacy: true }],//@ts-ignore\n          'babel-plugin-parameter-decorator',\n        ],\n      });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "symbolName",
    "snippet": "const symbolName = path.node.arguments[0].value;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "snippet",
    "snippet": "const snippet = content.slice(path.node.start!, path.node.end!);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "vector",
    "snippet": "const vector = await this.generateEmbedding(snippet);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.provider.ts",
    "type": "Constant",
    "value": "output",
    "snippet": "const output = await this.embedder(text, {\n      pooling: 'mean',\n      normalize: true,\n    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.sample.ts",
    "type": "Class",
    "value": "TokenizerSample",
    "snippet": "class TokenizerSample {\n  @Hook(HooksType.onInitialize)\n  async start() {\n    const { Tokenizer } = await import('./tokenizer.provider');\n    const tokenizer = new Tokenizer();\n    tokenizer.start();\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-ai/src/tokenizer.sample.ts",
    "type": "Constant",
    "value": "tokenizer",
    "snippet": "const tokenizer = new Tokenizer();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-cookie-session/src/sample.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = cmmv();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/copy-misc.ts",
    "type": "Constant",
    "value": "files",
    "snippet": "const files = await fg([\r\n        './src/nodes/**/*.node.json', \r\n        './src/nodes/*.node.json',\r\n        './packages/nodes/*.node.json',\r\n        './packages/nodes/**/*.node.json'\r\n    ], {\r\n        ignore: ['node_modules/**'],\r\n        cwd: process.cwd()\r\n    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/docs.controller.ts",
    "type": "Constant",
    "value": "index",
    "snippet": "const index = require('../docs/index.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/docs.controller.ts",
    "type": "Constant",
    "value": "indexLinks",
    "snippet": "const indexLinks = require('../docs/indexLinks.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/docs.controller.ts",
    "type": "Class",
    "value": "DocsController",
    "snippet": "@Controller('docs')\nexport class DocsController {\n    @Get()\n    async indexHandler(@Response() res) {\n        return res.render('views/docs/index', {\n            docs: indexLinks['index'].data,\n            services: ServiceRegistry.getServicesArr(),\n        });\n    }\n\n    @Get(':item')\n    async getDocHandler(@Param('item') item: string, @Response() res) {\n        if (index[item]) this.getDoc(index[item], res, item);\n        else res.code(404).end();\n    }\n\n    @Get(':dir/:item')\n    async getDocSubdirHandler(\n        @Param('dir') dir: string,\n        @Param('item') item: string,\n        @Response() res,\n    ) {\n        const fullPath = `${dir}/${item}`;\n        if (index[fullPath]) this.getDoc(index[fullPath], res, fullPath);\n        else res.code(404).end();\n    }\n\n    getDoc(docFilename, res, fullPath) {\n        let indexData = { ...indexLinks[fullPath] };\n        const data = indexData.data;\n        delete indexData.data;\n        data.links = indexData;\n\n        return res.render('views/docs/index', {\n            docs: data,\n            services: ServiceRegistry.getServicesArr(),\n        });\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/docs.controller.ts",
    "type": "Constant",
    "value": "fullPath",
    "snippet": "const fullPath = `${dir}/${item}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/docs.controller.ts",
    "type": "Constant",
    "value": "data",
    "snippet": "const data = indexData.data;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Class",
    "value": "GenerateDocs",
    "snippet": "class GenerateDocs {\n    public languages: Array<string> = ['en', 'ptbr'];\n    public defaultLanguage: string = 'en';\n\n    async convertMarkdownToHTML() {\n        const lang = Config.get<string>('docs.lang', 'en');\n\n        hljs.registerLanguage(\n            'ts',\n            require('highlight.js/lib/languages/typescript'),\n        );\n\n        const markdown = MarkdownIt({\n            html: true,\n            linkify: true,\n            breaks: true,\n            typographer: true,\n            highlight: (str, lang) => {\n                if (lang && hljs.getLanguage(lang)) {\n                    return (\n                        //'<div class=\"code-block-container\">' +\n                        '<pre><code class=\"hljs language-' +\n                        lang +\n                        '\" lang=\"' +\n                        lang +\n                        '\">' +\n                        hljs.highlight(str, { language: lang }).value +\n                        '</code></pre>'\n                        //'<button class=\"copy-code-btn\" onclick=\"copyToClipboard(this)\">Copy</button>' +\n                        //'</div>'\n                    );\n                }\n\n                return `<pre><code class=\"hljs\">${markdown.utils.escapeHtml(str)}</code></pre>`;\n            },\n        });\n\n        const docsFiles = await glob([\n            `./docs/${lang}/**/*.md`,\n            `./docs/${lang}/*.md`,\n        ]);\n\n        for (let file of docsFiles) {\n            if (!file.includes('README') && !file.includes('node_modules')) {\n                const content = await fs.readFileSync(\n                    path.resolve(file),\n                    'utf8',\n                );\n                let rendered = await markdown.render(content);\n                rendered = this.injectCopyButton(rendered);\n                rendered = this.fixLinks(rendered);\n                rendered = this.addAnchorLinks(rendered);\n                await fs.writeFileSync(\n                    file.replace('.md', '.html'),\n                    rendered,\n                    'utf8',\n                );\n            }\n        }\n    }\n\n    injectCopyButton(renderedHtml) {\n        return renderedHtml.replace(\n            /<pre><code class=\"hljs(.*?)>([\\s\\S]*?)<\\/code><\\/pre>/g,\n            `<div class=\"code-block-container\">\n                <button class=\"copy-code-btn\" onclick=\"copyToClipboard(this)\" title=\"Copy\">\n                    <i class=\"fa-regular fa-clone\"></i>\n                </button>\n                <pre><code class=\"hljs$1\">$2</code></pre>\n             </div>`,\n        );\n    }\n\n    async generateIndex() {\n        const lang = Config.get<string>('docs.lang', 'en');\n\n        const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);\n\n        let index = {};\n        let indexLink = {};\n\n        docsFiles.sort((a, b) => {\n            const regex = /(\\d+)|([^\\d]+)/g;\n            const partsA = a.match(regex).map(part => Number(part));\n            const partsB = b.match(regex).map(part => Number(part));\n\n            for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n                if (partsA[i] !== partsB[i]) {\n                    return partsA[i] > partsB[i] ? 1 : -1;\n                }\n            }\n\n            return 0;\n        });\n\n        let pointer = 0;\n\n        for (let file of docsFiles) {\n            if (!file.includes('README') && !file.includes('node_modules')) {\n                const pathFile = encodeURIComponent(\n                    file\n                        .replace(process.cwd(), '')\n                        .replace(lang + '/', '')\n                        .replace('docs/', '')\n                        .replace(/\\\\/g, '/'),\n                );\n\n                const urlFixed = this.convertLinkToCleanURL(pathFile);\n                index[urlFixed] = './' + file.replace(process.cwd() + '/', '');\n\n                const title = this.getTitle(\n                    './' + file.replace(process.cwd() + '/', ''),\n                );\n\n                try {\n                    indexLink[urlFixed] = {\n                        prev: {\n                            link: docsFiles[pointer - 1]\n                                ? this.convertLinkToCleanURL(\n                                      docsFiles[pointer - 1],\n                                  )\n                                : '',\n                            title: docsFiles[pointer - 1]\n                                ? this.getTitle(\n                                      './' +\n                                          docsFiles[pointer - 1].replace(\n                                              process.cwd() + '/',\n                                              '',\n                                          ),\n                                  )\n                                : '',\n                            desc: docsFiles[pointer - 1]\n                                ? this.getDesc(\n                                      './' +\n                                          docsFiles[pointer - 1].replace(\n                                              process.cwd() + '/',\n                                              '',\n                                          ),\n                                  )\n                                : '',\n                        },\n                        next: {\n                            link: docsFiles[pointer + 1]\n                                ? this.convertLinkToCleanURL(\n                                      docsFiles[pointer + 1],\n                                  )\n                                : '',\n                            title: docsFiles[pointer + 1]\n                                ? this.getTitle(\n                                      './' +\n                                          docsFiles[pointer + 1].replace(\n                                              process.cwd() + '/',\n                                              '',\n                                          ),\n                                  )\n                                : '',\n                            desc: docsFiles[pointer + 1]\n                                ? this.getDesc(\n                                      './' +\n                                          docsFiles[pointer + 1].replace(\n                                              process.cwd() + '/',\n                                              '',\n                                          ),\n                                  )\n                                : '',\n                        },\n                        meta: `\n                        <link rel=\"prev\" href=\"/${docsFiles[pointer - 1] ? this.convertLinkToCleanURL(docsFiles[pointer - 1]) : ''}\" />\n                        <link rel=\"next\" href=\"/${docsFiles[pointer + 1] ? this.convertLinkToCleanURL(docsFiles[pointer + 1]) : ''}\" />\n                        `,\n                        ldjson: JSON.stringify(\n                            {\n                                '@context': 'https://schema.org',\n                                '@type': 'WebPage',\n                                name: title,\n                                breadcrumb: {\n                                    '@type': 'BreadcrumbList',\n                                    itemListElement: [\n                                        {\n                                            '@type': 'ListItem',\n                                            position: 1,\n                                            name: 'Previous Page',\n                                            item:\n                                                '/' +\n                                                (docsFiles[pointer - 1]\n                                                    ? this.convertLinkToCleanURL(\n                                                          docsFiles[\n                                                              pointer - 1\n                                                          ],\n                                                      )\n                                                    : ''),\n                                        },\n                                        {\n                                            '@type': 'ListItem',\n                                            position: 2,\n                                            name: 'Current Page',\n                                            item:\n                                                '/docs/' +\n                                                this.convertLinkToCleanURL(\n                                                    pathFile,\n                                                ),\n                                        },\n                                        {\n                                            '@type': 'ListItem',\n                                            position: 3,\n                                            name: 'Next Page',\n                                            item:\n                                                '/' +\n                                                (docsFiles[pointer + 1]\n                                                    ? this.convertLinkToCleanURL(\n                                                          docsFiles[\n                                                              pointer + 1\n                                                          ],\n                                                      )\n                                                    : ''),\n                                        },\n                                    ],\n                                },\n                            },\n                            null,\n                            4,\n                        ),\n                        data: await this.getDocsStrutucture(file),\n                    };\n                } catch (e) {\n                    console.error(e);\n                }\n\n                pointer++;\n            }\n        }\n\n        await fs.writeFileSync(\n            'docs/index.json',\n            JSON.stringify(index, null, 4),\n        );\n\n        await fs.writeFileSync(\n            'docs/indexLinks.json',\n            JSON.stringify(indexLink, null, 4),\n        );\n    }\n\n    getTitle(file) {\n        const content = fs.readFileSync(path.resolve(file), 'utf-8');\n\n        const regex = /<h1[^>]*>(.*?)<\\/h1>/i;\n        const match = content.match(regex);\n\n        if (match && match[1]) return match[1];\n\n        return null;\n    }\n\n    getDesc(file) {\n        const content = fs\n            .readFileSync(path.resolve(file), 'utf-8')\n            .replace(/<h1>.*?<\\/a>\\n<p>/, '');\n        const textOnly = content.replace(/<[^>]*>/g, '');\n        const dec = textOnly.substring(0, 80).trim() + '...';\n        return dec;\n    }\n\n    convertLinkToCleanURL(link: string): string {\n        const lang = Config.get<string>('docs.lang', 'en');\n\n        const decodedLink = decodeURIComponent(\n            link\n                .replace(process.cwd(), '')\n                .replace('.html', '')\n                .replace(/\\./g, '')\n                .replace(lang + '/', '')\n                .replace('/docs/', '')\n                .replace(/\\\\/g, '/'),\n        );\n\n        const pathParts = decodedLink.split('/');\n\n        const cleanPathParts = pathParts.map(part => {\n            const cleanPart = part\n                .replace(lang + '/', '')\n                .replace(/\\d+\\s*-\\s*/g, '')\n                .replace(/\\s+/g, '-')\n                .replace(/[^\\w-]+/g, '')\n                .toLowerCase();\n\n            return cleanPart;\n        });\n\n        const cleanURL = cleanPathParts.filter(Boolean).join('/');\n\n        return cleanURL;\n    }\n\n    convertToGitLink(link: string): string {\n        const lang = Config.get<string>('docs.lang', 'en');\n        return link\n            .replace('.html', '.md')\n            ?.replace('docs/', '')\n            .replace(lang + '/', lang + '/tree/main/');\n    }\n\n    fixLinks(html: string): string {\n        const regex = /<a([^>]*)>/gi;\n        const replacement = '<a$1 target=\"_blank\" rel=\"nofollow\">';\n        const modifiedHtml = html.replace(regex, replacement);\n        return modifiedHtml;\n    }\n\n    addAnchorLinks(html: string): string {\n        const headerTags = ['h1', 'h2'];\n        const modifiedHtml = headerTags.reduce((html, tag) => {\n            const regex = new RegExp(`(<${tag}[^>]*>)(.*?)(</${tag}>)`, 'gi');\n            const matches = html.match(regex);\n\n            if (matches) {\n                matches.forEach(match => {\n                    const text = match.replace(/<\\/?[^>]+(>|$)/g, '');\n                    const id = text\n                        .toLowerCase()\n                        .replace(/\\s/g, '-')\n                        .replace(/\\s+/g, '-')\n                        .replace(/[^\\w-]+/g, '');\n                    const anchorLink = `<a id=\"${id}\" title=\"${text}\"></a>`;\n                    html = html.replace(match, `${match}${anchorLink}`);\n                });\n            }\n\n            return html;\n        }, html);\n\n        return modifiedHtml;\n    }\n\n    async generateAlgoliaJSON() {\n        const lang = Config.get<string>('docs.lang', 'en');\n        const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);\n        let algoliaData = [];\n\n        for (let file of docsFiles) {\n            if (!file.includes('README') && !file.includes('node_modules')) {\n                const content = await fs.readFileSync(file, 'utf8');\n                const pathFile = encodeURIComponent(\n                    file\n                        .replace(process.cwd(), '')\n                        .replace('docs/', '')\n                        .replace(/\\\\/g, '/'),\n                );\n                const url = this.convertLinkToCleanURL(pathFile);\n                const hierarchy = this.extractHierarchy(content);\n                const cleanedContent = this.cleanContentForAlgolia(content);\n\n                algoliaData.push({\n                    objectID: url,\n                    url: `/${url}.html`,\n                    content: cleanedContent,\n                    hierarchy: hierarchy,\n                    anchor: '',\n                    type: 'content',\n                });\n            }\n        }\n\n        await fs.writeFileSync(\n            'docs/algolia.json',\n            JSON.stringify(algoliaData, null, 4),\n        );\n    }\n\n    extractHierarchy(htmlContent: string): any {\n        const hierarchy = {\n            lvl0: '',\n            lvl1: '',\n            lvl2: '',\n            lvl3: '',\n            lvl4: '',\n            lvl5: '',\n            lvl6: '',\n        };\n\n        const lvl0Match = htmlContent.match(/<h1>(.*?)<\\/h1>/);\n        const lvl1Match = htmlContent.match(/<h2>(.*?)<\\/h2>/);\n        const lvl2Match = htmlContent.match(/<h3>(.*?)<\\/h3>/);\n\n        if (lvl0Match) hierarchy.lvl0 = lvl0Match[1];\n        if (lvl1Match) hierarchy.lvl1 = lvl1Match[1];\n        if (lvl2Match) hierarchy.lvl2 = lvl2Match[1];\n\n        return hierarchy;\n    }\n\n    cleanContentForAlgolia(htmlContent: string): string {\n        return htmlContent\n            .replace(/<\\/?[^>]+(>|$)/g, '')\n            .replace(/\\s+/g, ' ')\n            .trim();\n    }\n\n    async generateSitemap() {\n        const lang = Config.get<string>('docs.lang', 'en');\n        const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);\n\n        const baseUrl = 'https://cmmv.io';\n        let sitemap = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n`;\n        sitemap += `<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n`;\n\n        sitemap += `  <url>\\n`;\n        sitemap += `    <loc>${baseUrl}</loc>\\n`;\n        sitemap += `    <changefreq>weekly</changefreq>\\n`;\n        sitemap += `  </url>\\n`;\n\n        for (let file of docsFiles) {\n            if (!file.includes('README') && !file.includes('node_modules')) {\n                const pathFile = encodeURIComponent(\n                    file.replace(process.cwd(), '').replace(/\\\\/g, '/'),\n                ).replace('.html', '');\n                const url = this.convertLinkToCleanURL(pathFile);\n\n                sitemap += `  <url>\\n`;\n                sitemap += `    <loc>${baseUrl}/${url}</loc>\\n`;\n                sitemap += `    <changefreq>weekly</changefreq>\\n`;\n                sitemap += `  </url>\\n`;\n            }\n        }\n\n        sitemap += `</urlset>`;\n        await fs.writeFileSync('public/sitemap.xml', sitemap, 'utf8');\n    }\n\n    async getDocsStrutucture(file = null) {\n        const lang = Config.get<string>('docs.lang', 'en');\n\n        let strutucture = {\n            index: '',\n            navbar: [],\n            breadcrumb: [],\n            anchors: [],\n            link: file?.replace(cwd(), ''),\n            git: this.convertToGitLink(file?.replace(cwd(), '')),\n            links: {},\n        };\n\n        const filesAndDirsIndex = await fg(\n            path.resolve(process.cwd(), `./docs/${lang}/*`),\n            {\n                dot: false,\n                onlyFiles: false,\n                ignore: ['./docs/index.html'],\n            },\n        );\n\n        if (file) {\n            const pathDivider = process.platform === 'win32' ? '\\\\' : '/';\n            const [root, content] = file\n                .replace(\n                    path.join(process.cwd(), '/docs/').replace(lang + '/', ''),\n                    '',\n                )\n                .split(pathDivider);\n            strutucture.breadcrumb[0] = root.split('-')[1]?.trim();\n\n            if (strutucture.breadcrumb[1]) {\n                if (typeof content == 'string')\n                    strutucture.breadcrumb[1] = content.split('-')[1]?.trim();\n\n                if (\n                    strutucture.breadcrumb[0] &&\n                    strutucture.breadcrumb[0].includes('.')\n                )\n                    strutucture.breadcrumb[0] =\n                        strutucture.breadcrumb[0].split('.')[0];\n\n                if (\n                    strutucture.breadcrumb[1] &&\n                    strutucture.breadcrumb[1].includes('.')\n                )\n                    strutucture.breadcrumb[1] =\n                        strutucture.breadcrumb[1].split('.')[0];\n            } else {\n                if (\n                    strutucture.breadcrumb[0] &&\n                    strutucture.breadcrumb[0].includes('.')\n                )\n                    strutucture.breadcrumb[0] =\n                        strutucture.breadcrumb[0].split('.')[0];\n            }\n        }\n\n        strutucture.index = file\n            ? fs.readFileSync(path.resolve(file), 'utf8')\n            : fs.readFileSync(path.resolve('./docs/index.html'), 'utf8');\n\n        for (let fileOrDir of filesAndDirsIndex) {\n            try {\n                let basename = path.basename(fileOrDir);\n                let [indexRaw, nameRaw] = basename.split('-');\n                let index = parseInt(indexRaw.trim());\n                let name = nameRaw\n                    ? nameRaw?.includes('.')\n                        ? nameRaw.split('.')[0]?.trim()\n                        : nameRaw?.trim()\n                    : indexRaw.split('.')[0]?.trim();\n                const isDir = fs.lstatSync(fileOrDir).isDirectory();\n\n                if (index < 0) index = 0;\n\n                if (name && !strutucture.navbar[index]) {\n                    strutucture.navbar[index] = {\n                        filename: fileOrDir,\n                        uri: '/docs/' + this.convertLinkToCleanURL(fileOrDir),\n                        isDir,\n                        index: index,\n                        name: name,\n                        children: [],\n                    };\n\n                    if (isDir) {\n                        const filesChildren = await fg(`${fileOrDir}/*.html`, {\n                            dot: false,\n                            onlyFiles: true,\n                        });\n\n                        for (let children of filesChildren) {\n                            let basenameChildren = path.basename(children);\n                            let [indexRawChildren, nameRawChildren] =\n                                basenameChildren.split('-');\n                            /*let indexChildren = parseInt(\n                                indexRawChildren.trim(),\n                            );*/\n                            let nameChildren = nameRawChildren\n                                ? nameRawChildren.includes('.')\n                                    ? nameRawChildren.split('.')[0]?.trim()\n                                    : nameRawChildren?.trim()\n                                : indexRawChildren.split('.')[0]?.trim();\n\n                            strutucture.navbar[index].children.push({\n                                filename: children,\n                                uri:\n                                    '/docs/' +\n                                    this.convertLinkToCleanURL(children),\n                                name: nameChildren,\n                            });\n                        }\n                    }\n                }\n            } catch (e) {\n                console.log(e);\n            }\n        }\n\n        if (strutucture.index) {\n            const regex = /<h[1-4]>(.*?)<\\/.*?<a id=\"(.*?)\".*?>/g;\n            let match;\n\n            while ((match = regex.exec(strutucture.index)) !== null) {\n                strutucture.anchors.push({\n                    id: match[2],\n                    label: match[1],\n                });\n            }\n        }\n\n        return strutucture;\n    }\n\n    uppercaseFirstLetter(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n\n    fixedLabel(value) {\n        return value\n            ? this.uppercaseFirstLetter(\n                  value === null || value === void 0\n                      ? void 0\n                      : value.replace(/([A-Z])/g, ' $1'),\n              )\n            : '';\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "markdown",
    "snippet": "const markdown = MarkdownIt({\n            html: true,\n            linkify: true,\n            breaks: true,\n            typographer: true,\n            highlight: (str, lang) => {\n                if (lang && hljs.getLanguage(lang)) {\n                    return (\n                        //'<div class=\"code-block-container\">' +\n                        '<pre><code class=\"hljs language-' +\n                        lang +\n                        '\" lang=\"' +\n                        lang +\n                        '\">' +\n                        hljs.highlight(str, { language: lang }).value +\n                        '</code></pre>'\n                        //'<button class=\"copy-code-btn\" onclick=\"copyToClipboard(this)\">Copy</button>' +\n                        //'</div>'\n                    );\n                }\n\n                return `<pre><code class=\"hljs\">${markdown.utils.escapeHtml(str)}</code></pre>`;\n            },\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "docsFiles",
    "snippet": "const docsFiles = await glob([\n            `./docs/${lang}/**/*.md`,\n            `./docs/${lang}/*.md`,\n        ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = await fs.readFileSync(\n                    path.resolve(file),\n                    'utf8',\n                );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "docsFiles",
    "snippet": "const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "regex",
    "snippet": "const regex = /(\\d+)|([^\\d]+)/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "partsA",
    "snippet": "const partsA = a.match(regex).map(part => Number(part));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "partsB",
    "snippet": "const partsB = b.match(regex).map(part => Number(part));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "pathFile",
    "snippet": "const pathFile = encodeURIComponent(\n                    file\n                        .replace(process.cwd(), '')\n                        .replace(lang + '/', '')\n                        .replace('docs/', '')\n                        .replace(/\\\\/g, '/'),\n                );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "urlFixed",
    "snippet": "const urlFixed = this.convertLinkToCleanURL(pathFile);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "title",
    "snippet": "const title = this.getTitle(\n                    './' + file.replace(process.cwd() + '/', ''),\n                );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = fs.readFileSync(path.resolve(file), 'utf-8');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "regex",
    "snippet": "const regex = /<h1[^>]*>(.*?)<\\/h1>/i;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "match",
    "snippet": "const match = content.match(regex);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = fs\n            .readFileSync(path.resolve(file), 'utf-8')\n            .replace(/<h1>.*?<\\/a>\\n<p>/, '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "textOnly",
    "snippet": "const textOnly = content.replace(/<[^>]*>/g, '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "dec",
    "snippet": "const dec = textOnly.substring(0, 80).trim() + '...';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "decodedLink",
    "snippet": "const decodedLink = decodeURIComponent(\n            link\n                .replace(process.cwd(), '')\n                .replace('.html', '')\n                .replace(/\\./g, '')\n                .replace(lang + '/', '')\n                .replace('/docs/', '')\n                .replace(/\\\\/g, '/'),\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "pathParts",
    "snippet": "const pathParts = decodedLink.split('/');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "cleanPathParts",
    "snippet": "const cleanPathParts = pathParts.map(part => {\n            const cleanPart = part\n                .replace(lang + '/', '')\n                .replace(/\\d+\\s*-\\s*/g, '')\n                .replace(/\\s+/g, '-')\n                .replace(/[^\\w-]+/g, '')\n                .toLowerCase();\n\n            return cleanPart;\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "cleanPart",
    "snippet": "const cleanPart = part\n                .replace(lang + '/', '')\n                .replace(/\\d+\\s*-\\s*/g, '')\n                .replace(/\\s+/g, '-')\n                .replace(/[^\\w-]+/g, '')\n                .toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "cleanURL",
    "snippet": "const cleanURL = cleanPathParts.filter(Boolean).join('/');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "regex",
    "snippet": "const regex = /<a([^>]*)>/gi;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "replacement",
    "snippet": "const replacement = '<a$1 target=\"_blank\" rel=\"nofollow\">';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "modifiedHtml",
    "snippet": "const modifiedHtml = html.replace(regex, replacement);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "headerTags",
    "snippet": "const headerTags = ['h1', 'h2'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "modifiedHtml",
    "snippet": "const modifiedHtml = headerTags.reduce((html, tag) => {\n            const regex = new RegExp(`(<${tag}[^>]*>)(.*?)(</${tag}>)`, 'gi');\n            const matches = html.match(regex);\n\n            if (matches) {\n                matches.forEach(match => {\n                    const text = match.replace(/<\\/?[^>]+(>|$)/g, '');\n                    const id = text\n                        .toLowerCase()\n                        .replace(/\\s/g, '-')\n                        .replace(/\\s+/g, '-')\n                        .replace(/[^\\w-]+/g, '');\n                    const anchorLink = `<a id=\"${id}\" title=\"${text}\"></a>`;\n                    html = html.replace(match, `${match}${anchorLink}`);\n                });\n            }\n\n            return html;\n        }, html);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "regex",
    "snippet": "const regex = new RegExp(`(<${tag}[^>]*>)(.*?)(</${tag}>)`, 'gi');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "matches",
    "snippet": "const matches = html.match(regex);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "text",
    "snippet": "const text = match.replace(/<\\/?[^>]+(>|$)/g, '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "id",
    "snippet": "const id = text\n                        .toLowerCase()\n                        .replace(/\\s/g, '-')\n                        .replace(/\\s+/g, '-')\n                        .replace(/[^\\w-]+/g, '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "anchorLink",
    "snippet": "const anchorLink = `<a id=\"${id}\" title=\"${text}\"></a>`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "docsFiles",
    "snippet": "const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = await fs.readFileSync(file, 'utf8');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "pathFile",
    "snippet": "const pathFile = encodeURIComponent(\n                    file\n                        .replace(process.cwd(), '')\n                        .replace('docs/', '')\n                        .replace(/\\\\/g, '/'),\n                );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "url",
    "snippet": "const url = this.convertLinkToCleanURL(pathFile);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "hierarchy",
    "snippet": "const hierarchy = this.extractHierarchy(content);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "cleanedContent",
    "snippet": "const cleanedContent = this.cleanContentForAlgolia(content);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "hierarchy",
    "snippet": "const hierarchy = {\n            lvl0: '',\n            lvl1: '',\n            lvl2: '',\n            lvl3: '',\n            lvl4: '',\n            lvl5: '',\n            lvl6: '',\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lvl0Match",
    "snippet": "const lvl0Match = htmlContent.match(/<h1>(.*?)<\\/h1>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lvl1Match",
    "snippet": "const lvl1Match = htmlContent.match(/<h2>(.*?)<\\/h2>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lvl2Match",
    "snippet": "const lvl2Match = htmlContent.match(/<h3>(.*?)<\\/h3>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "docsFiles",
    "snippet": "const docsFiles = await glob([\n            `./docs/${lang}/**/*.html`,\n            `./docs/${lang}/*.html`,\n        ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "baseUrl",
    "snippet": "const baseUrl = 'https://cmmv.io';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "pathFile",
    "snippet": "const pathFile = encodeURIComponent(\n                    file.replace(process.cwd(), '').replace(/\\\\/g, '/'),\n                ).replace('.html', '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "url",
    "snippet": "const url = this.convertLinkToCleanURL(pathFile);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "lang",
    "snippet": "const lang = Config.get<string>('docs.lang', 'en');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "filesAndDirsIndex",
    "snippet": "const filesAndDirsIndex = await fg(\n            path.resolve(process.cwd(), `./docs/${lang}/*`),\n            {\n                dot: false,\n                onlyFiles: false,\n                ignore: ['./docs/index.html'],\n            },\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "pathDivider",
    "snippet": "const pathDivider = process.platform === 'win32' ? '\\\\' : '/';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "isDir",
    "snippet": "const isDir = fs.lstatSync(fileOrDir).isDirectory();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "filesChildren",
    "snippet": "const filesChildren = await fg(`${fileOrDir}/*.html`, {\n                            dot: false,\n                            onlyFiles: true,\n                        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/generate.ts",
    "type": "Constant",
    "value": "regex",
    "snippet": "const regex = /<h[1-4]>(.*?)<\\/.*?<a id=\"(.*?)\".*?>/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-docs/src/index.controller.ts",
    "type": "Class",
    "value": "IndexController",
    "snippet": "@Controller()\nexport class IndexController {\n    @Get()\n    async indexHandler(@Response() res) {\n        return res.render('views/index');\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.module.ts",
    "type": "Constant",
    "value": "ElasticModule",
    "snippet": "const ElasticModule = new Module('elastic', {\r\n    providers: [ElasticService]\r\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Class",
    "value": "ElasticService",
    "snippet": "@Service()\r\nexport class ElasticService extends Singleton {\r\n    public logger: Logger = new Logger('ElasticService');\r\n    public elasticClient: Client;\r\n\r\n    public static async loadConfig(application: Application): Promise<void> {\r\n        const instance = ElasticService.getInstance();\r\n        const config = Config.get<string>('elastic', { node: 'http://localhost:9200' });\r\n\r\n        try {\r\n            instance.elasticClient = new Client(config);\r\n            const isConnected = await instance.verifyConnection();\r\n\r\n            if (isConnected) {\r\n                instance.logger.log(\"Elastic connected and verified!\");\r\n            } else {\r\n                throw new Error(\"ElasticSearch server is not responding.\");\r\n            }\r\n        }\r\n        catch(err){\r\n            instance.logger.error(err.message);\r\n            console.error(err);\r\n        }\r\n    }\r\n\r\n    public static async createIndex(indexName: string, settings?: any, mappings?: any): Promise<any> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {            \r\n            const exists = await ElasticService.checkIndexExists(indexName);\r\n\r\n            if (exists) {\r\n                instance.logger.log(`Index \"${indexName}\" already exists.`);\r\n                return false;\r\n            }\r\n\r\n            let body: any = {};\r\n\r\n            if (settings != null) {\r\n                body.settings = {\r\n                    ...settings,\r\n                    number_of_shards: settings?.number_of_shards || 1,\r\n                    number_of_replicas: settings?.number_of_replicas || 0,\r\n                };\r\n            }\r\n\r\n            if (mappings != null) \r\n                body.mappings = mappings;\r\n            \r\n            const result = await instance.elasticClient.indices.create({\r\n                index: indexName,\r\n                wait_for_active_shards: settings?.number_of_shards || 1,\r\n                timeout: \"5s\",\r\n                master_timeout: \"5s\",\r\n                body\r\n            });           \r\n\r\n            const existsAlias = await ElasticService.checkAliasExists(indexName);\r\n\r\n            if (existsAlias == false)\r\n                await ElasticService.createAlias(indexName);\r\n\r\n            return result;\r\n        } catch (err) {\r\n            instance.logger.error(`Error creating index \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async checkIndexExists(indexName: string): Promise<boolean> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            const result = await instance.elasticClient.indices.exists({ index: indexName });\r\n            return result;\r\n        } catch (err) {\r\n            instance.logger.error(`Error checking index \"${indexName}\": ${err.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static async insertDocument(indexName: string, document: any) {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            return await instance.elasticClient.index({\r\n                index: indexName,\r\n                refresh: 'wait_for',\r\n                body: document\r\n            });\r\n        } catch (err) {\r\n            instance.logger.error(`Error inserting document into index \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async updateDocument(indexName: string, documentId: string, updateBody: any) {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            return await instance.elasticClient.update({\r\n                index: indexName,\r\n                id: documentId,\r\n                doc: updateBody \r\n            });\r\n        } catch (err) {\r\n            instance.logger.error(`Error updating document \"${documentId}\" in index \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async deleteDocument(indexName: string, documentId: string) {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            return await instance.elasticClient.delete({\r\n                index: indexName,\r\n                id: documentId\r\n            });\r\n        } catch (err) {\r\n            instance.logger.error(`Error deleting document \"${documentId}\" in index \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async searchDocuments(indexName: string, query: any): Promise<any[]> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            const result = await instance.elasticClient.search({\r\n                index: indexName,\r\n                body: query\r\n            });\r\n\r\n            return result.hits.hits;\r\n        } catch (err) {\r\n            instance.logger.error(`Error searching documents in index \"${indexName}\": ${err.message}`);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    public static async createAlias(indexName: string): Promise<void> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            const aliasExists = await ElasticService.checkAliasExists(indexName);\r\n\r\n            if (aliasExists) {\r\n                instance.logger.log(`Alias \"${indexName}\" already exists.`);\r\n                return;\r\n            }\r\n\r\n            await instance.elasticClient.indices.updateAliases({\r\n                body: {\r\n                    actions: [\r\n                        { add: { \r\n                            index: indexName, \r\n                            alias: indexName, \r\n                            is_write_index: true \r\n                        } }\r\n                    ]\r\n                }\r\n            });\r\n        } \r\n        catch (err) {\r\n            instance.logger.error(`Error creating alias \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async checkAliasExists(aliasName: string): Promise<boolean> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            return await instance.elasticClient.indices.existsAlias({ name: aliasName });\r\n        } catch (err) {\r\n            instance.logger.error(`Error checking alias \"${aliasName}\": ${err.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static async performRollover(aliasName: string, conditions: any): Promise<void> {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            const response = await instance.elasticClient.indices.rollover({\r\n                alias: aliasName,\r\n                body: { conditions }\r\n            });\r\n        } catch (err) {\r\n            instance.logger.error(`Error performing rollover for alias \"${aliasName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    public static async deleteIndex(indexName: string) {\r\n        const instance = ElasticService.getInstance();\r\n\r\n        try {\r\n            return await instance.elasticClient.indices.delete({ index: indexName });\r\n        } catch (err) {\r\n            instance.logger.error(`Error deleting index \"${indexName}\": ${err.message}`);\r\n        }\r\n    }\r\n\r\n    //Utils\r\n    private async verifyConnection(): Promise<boolean> {\r\n        try {\r\n            await this.elasticClient.ping();\r\n            return true;\r\n        } catch (err) {\r\n            this.logger.error(\"ElasticSearch ping failed. Server might be down.\");\r\n            return false;\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "config",
    "snippet": "const config = Config.get<string>('elastic', { node: 'http://localhost:9200' });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "isConnected",
    "snippet": "const isConnected = await instance.verifyConnection();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "exists",
    "snippet": "const exists = await ElasticService.checkIndexExists(indexName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance.elasticClient.indices.create({\r\n                index: indexName,\r\n                wait_for_active_shards: settings?.number_of_shards || 1,\r\n                timeout: \"5s\",\r\n                master_timeout: \"5s\",\r\n                body\r\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "existsAlias",
    "snippet": "const existsAlias = await ElasticService.checkAliasExists(indexName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance.elasticClient.indices.exists({ index: indexName });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance.elasticClient.search({\r\n                index: indexName,\r\n                body: query\r\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "aliasExists",
    "snippet": "const aliasExists = await ElasticService.checkAliasExists(indexName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = await instance.elasticClient.indices.rollover({\r\n                alias: aliasName,\r\n                body: { conditions }\r\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-elastic/src/elastic.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = ElasticService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.config.ts",
    "type": "Constant",
    "value": "EmailConfig",
    "snippet": "const EmailConfig: ConfigSchema = {\n  email: {\n    name: {\n      type: 'string',\n      required: false,\n    },\n    host: {\n      type: 'string',\n      required: false,\n    },\n    port: {\n      type: 'number',\n      required: false,\n    },\n    secure: {\n      type: 'boolean',\n      required: false,\n      default: false,\n    },\n    ignoreTLS: {\n      type: 'boolean',\n      required: false,\n      default: false,\n    },\n    requireTLS: {\n      type: 'boolean',\n      required: false,\n    },\n    localAddress: {\n      type: 'string',\n      required: false,\n    },\n    connectionTimeout: {\n      type: 'number',\n      required: false,\n    },\n    greetingTimeout: {\n      type: 'number',\n      required: false,\n    },\n    socketTimeout: {\n      type: 'number',\n      required: false,\n    },\n    dnsTimeout: {\n      type: 'number',\n      required: false,\n    },\n    logger: {\n      type: 'boolean',\n      required: false,\n      default: false,\n    },\n    debug: {\n      type: 'boolean',\n      required: false,\n      default: false,\n    },\n    disableFileAccess: {\n      type: 'boolean',\n      required: false,\n    },\n    disableUrlAccess: {\n      type: 'boolean',\n      required: false,\n    },\n    proxy: {\n      type: 'string',\n      required: false,\n    },\n    auth: {\n      type: 'object',\n      required: false,\n      properties: {\n        type: {\n          type: 'string',\n          required: false,\n          default: 'oauth2',\n        },\n        user: {\n          type: 'string',\n          required: false,\n        },\n        pass: {\n          type: 'string',\n          required: false,\n        },\n        options: {\n          type: 'object',\n          required: false,\n        },\n        clientId: {\n          type: 'string',\n          required: false,\n        },\n        clientSecret: {\n          type: 'string',\n          required: false,\n        },\n        refreshToken: {\n          type: 'string',\n          required: false,\n        },\n        accessToken: {\n          type: 'string',\n          required: false,\n        },\n        expires: {\n          type: 'number',\n          required: false,\n        },\n        accessUrl: {\n          type: 'string',\n          required: false,\n        },\n        serviceClient: {\n          type: 'string',\n          required: false,\n        },\n        privateKey: {\n          type: 'string',\n          required: false,\n        },\n      },\n    },\n    tls: {\n      type: 'object',\n      required: false,\n      properties: {\n        servername: {\n          type: 'string',\n          required: false,\n        },\n        enableTrace: {\n          type: 'boolean',\n          required: false,\n        },\n        rejectUnauthorized: {\n          type: 'boolean',\n          required: false,\n        },\n        isServer: {\n          type: 'boolean',\n          required: false,\n        },\n        ALPNProtocols: {\n          type: 'boolean',\n          required: false,\n        },\n        SNICallback: {\n          type: 'boolean',\n          required: false,\n        },\n        session: {\n          type: 'any',\n          required: false,\n        },\n        requestOCSP: {\n          type: 'boolean',\n          required: false,\n        },\n      },\n    },\n    SES: {\n      type: 'object',\n      required: false,\n      properties: {\n        region: {\n          type: 'string',\n          required: false,\n        },\n        accessKeyId: {\n          type: 'string',\n          required: false,\n        },\n        secretAccessKey: {\n          type: 'string',\n          required: false,\n        },\n      },\n    },\n    pool: {\n      type: 'boolean',\n      required: false,\n    },\n    maxConnections: {\n      type: 'number',\n      required: false,\n      default: 5,\n    },\n    maxMessages: {\n      type: 'number',\n      required: false,\n      default: 100,\n    },\n  },\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.module.ts",
    "type": "Constant",
    "value": "EmailModule",
    "snippet": "const EmailModule = new Module('email', {\n  configs: [EmailConfig],\n  providers: [EmailService],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Class",
    "value": "EmailService",
    "snippet": "@Service('email')\nexport class EmailService extends Singleton {\n  public logger: Logger = new Logger('EmailService');\n  public transporter: nodemailer.Transporter;\n\n  public static async loadConfig(application: Application): Promise<void> {\n    const instance = EmailService.getInstance();\n    const options = Config.get<any>('email');\n\n    if (options.SES) options.SES = new AWS.SES(options.SES);\n\n    instance.transporter = nodemailer.createTransport(options);\n  }\n\n  public async send(\n    from: string,\n    to: string,\n    subject: string,\n    html: string,\n    options?: Mail.Options,\n  ): Promise<boolean> {\n    const instance = EmailService.getInstance();\n\n    try {\n      const optionsLogger = Config.get<boolean>('email.logger', false);\n      let message: Mail.Options = { from, to, subject, html };\n\n      if (options) message = { ...message, ...options };\n\n      const info = await instance.transporter.sendMail(message);\n\n      if (optionsLogger)\n        instance.logger.log(`Message sent to ${to}: ${info.messageId}`);\n\n      return true;\n    } catch (err) {\n      instance.logger.error(`Error sending email to ${to}: ${err.message}`);\n      return false;\n    }\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = EmailService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options = Config.get<any>('email');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = EmailService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Constant",
    "value": "optionsLogger",
    "snippet": "const optionsLogger = Config.get<boolean>('email.logger', false);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-email/src/email.service.ts",
    "type": "Constant",
    "value": "info",
    "snippet": "const info = await instance.transporter.sendMail(message);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "ec",
    "snippet": "const ec = new EC('secp256k1');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Class",
    "value": "Encryptor",
    "snippet": "class Encryptor {\r\n    /**\r\n     * Encrypts a payload using the recipient's public key.\r\n     *\r\n     * This method generates an ephemeral key pair to derive a shared secret\r\n     * using Elliptic Curve Diffie-Hellman (ECDH). The payload is then encrypted \r\n     * using AES-256-GCM with the derived shared key, providing confidentiality and\r\n     * authenticity of the message.\r\n     *\r\n     * @param recipientPublicKeyHex - The recipient's public key in hexadecimal format.\r\n     * @param payload - The string payload to be encrypted.\r\n     * @returns An object containing the encrypted payload, IV, authentication tag, and ephemeral public key.\r\n     */\r\n    public static encryptPayload(\r\n        recipientPublicKeyHex: string,\r\n        payload: string\r\n    ){  \r\n        const recipientPublicKey = ec.keyFromPublic(recipientPublicKeyHex, 'hex').getPublic();\r\n        const ephemeralKeyPair = ec.genKeyPair();\r\n        const ephemeralPublicKey = ephemeralKeyPair.getPublic('hex'); \r\n\r\n        const sharedSecret = ephemeralKeyPair.derive(recipientPublicKey);\r\n        const sharedKey = crypto.createHash('sha256').update(sharedSecret.toString(16)).digest();\r\n        const iv = crypto.randomBytes(12);\r\n        const cipher = crypto.createCipheriv('aes-256-gcm', sharedKey, iv);\r\n\r\n        const encrypted = Buffer.concat([cipher.update(payload, 'utf8'), cipher.final()]);\r\n        const authTag = cipher.getAuthTag(); \r\n\r\n        return {\r\n            payload: '0x' + encrypted.toString('hex'),\r\n            iv: '0x' + iv.toString('hex'),\r\n            authTag: '0x' + authTag.toString('hex'),\r\n            ephemeralPublicKey: '0x' + ephemeralPublicKey\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decrypts an encrypted payload using the recipient's private key.\r\n     *\r\n     * This method derives the shared secret using the recipient's private key and\r\n     * the sender's ephemeral public key. The derived shared key is then used to\r\n     * decrypt the payload using AES-256-GCM, ensuring confidentiality and integrity.\r\n     *\r\n     * @param recipientPrivateKeyHex - The recipient's private key in hexadecimal format.\r\n     * @param encryptedData - An object containing the encrypted payload, IV, and authentication tag.\r\n     * @param ephemeralPublicKeyHex - The ephemeral public key sent by the sender in hexadecimal format.\r\n     * @returns The decrypted payload as a string.\r\n     */\r\n    public static decryptPayload(\r\n        recipientPrivateKeyHex: string,\r\n        encryptedData: { encrypted: string, iv: string, authTag: string },\r\n        ephemeralPublicKeyHex: string\r\n    ): string {\r\n        const recipientPrivateKey = ec.keyFromPrivate(recipientPrivateKeyHex.replace(\"0x\", \"\"), 'hex');\r\n        const ephemeralPublicKey = ec.keyFromPublic(ephemeralPublicKeyHex.replace(\"0x\", \"\"), 'hex').getPublic();\r\n        const sharedSecret = recipientPrivateKey.derive(ephemeralPublicKey);\r\n        const sharedKey = crypto.createHash('sha256').update(sharedSecret.toString(16)).digest();\r\n        const decipher = crypto.createDecipheriv('aes-256-gcm', sharedKey, Buffer.from(encryptedData.iv.replace(\"0x\", \"\"), 'hex'));\r\n        decipher.setAuthTag(Buffer.from(encryptedData.authTag.replace(\"0x\", \"\"), 'hex'));\r\n\r\n        const decrypted = Buffer.concat([\r\n            decipher.update(Buffer.from(encryptedData.encrypted.replace(\"0x\", \"\"), 'hex')),\r\n            decipher.final()\r\n        ]);\r\n\r\n        return decrypted.toString('utf8');\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "recipientPublicKey",
    "snippet": "const recipientPublicKey = ec.keyFromPublic(recipientPublicKeyHex, 'hex').getPublic();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "ephemeralKeyPair",
    "snippet": "const ephemeralKeyPair = ec.genKeyPair();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "ephemeralPublicKey",
    "snippet": "const ephemeralPublicKey = ephemeralKeyPair.getPublic('hex');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "sharedSecret",
    "snippet": "const sharedSecret = ephemeralKeyPair.derive(recipientPublicKey);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "sharedKey",
    "snippet": "const sharedKey = crypto.createHash('sha256').update(sharedSecret.toString(16)).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "iv",
    "snippet": "const iv = crypto.randomBytes(12);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "cipher",
    "snippet": "const cipher = crypto.createCipheriv('aes-256-gcm', sharedKey, iv);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "encrypted",
    "snippet": "const encrypted = Buffer.concat([cipher.update(payload, 'utf8'), cipher.final()]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "authTag",
    "snippet": "const authTag = cipher.getAuthTag();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "recipientPrivateKey",
    "snippet": "const recipientPrivateKey = ec.keyFromPrivate(recipientPrivateKeyHex.replace(\"0x\", \"\"), 'hex');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "ephemeralPublicKey",
    "snippet": "const ephemeralPublicKey = ec.keyFromPublic(ephemeralPublicKeyHex.replace(\"0x\", \"\"), 'hex').getPublic();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "sharedSecret",
    "snippet": "const sharedSecret = recipientPrivateKey.derive(ephemeralPublicKey);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "sharedKey",
    "snippet": "const sharedKey = crypto.createHash('sha256').update(sharedSecret.toString(16)).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "decipher",
    "snippet": "const decipher = crypto.createDecipheriv('aes-256-gcm', sharedKey, Buffer.from(encryptedData.iv.replace(\"0x\", \"\"), 'hex'));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/encryptor.ts",
    "type": "Constant",
    "value": "decrypted",
    "snippet": "const decrypted = Buffer.concat([\r\n            decipher.update(Buffer.from(encryptedData.encrypted.replace(\"0x\", \"\"), 'hex')),\r\n            decipher.final()\r\n        ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/keys.ts",
    "type": "Class",
    "value": "ECKeys",
    "snippet": "class ECKeys {\n    /**\n     * Generates a new elliptic curve key pair.\n     *\n     * @returns {EC.KeyPair} - A key pair object containing both private and public keys.\n     */\n    public static generateKeys(): EC.KeyPair {\n        const ec = new EC('secp256k1');\n        const recipientKeyPair = ec.genKeyPair();\n        return recipientKeyPair;\n    }\n\n    /**\n     * Extracts the private key from a given elliptic curve key pair.\n     *\n     * @param {EC.KeyPair} keyPair - The key pair object from which to extract the private key.\n     * @returns {string} - The private key in hexadecimal format.\n     */\n    public static getPrivateKey(keyPair: EC.KeyPair): string {\n        return keyPair.getPrivate('hex');\n    }\n\n    /**\n     * Extracts the public key from a given elliptic curve key pair.\n     *\n     * @param {EC.KeyPair} keyPair - The key pair object from which to extract the public key.\n     * @returns {string} - The public key in hexadecimal format.\n     */\n    public static getPublicKey(keyPair: EC.KeyPair): string {\n        return keyPair.getPublic('hex');\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/keys.ts",
    "type": "Constant",
    "value": "ec",
    "snippet": "const ec = new EC('secp256k1');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/keys.ts",
    "type": "Constant",
    "value": "recipientKeyPair",
    "snippet": "const recipientKeyPair = ec.genKeyPair();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "bip32",
    "snippet": "const bip32 = BIP32Factory(ecc);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Class",
    "value": "Signer",
    "snippet": "class Signer {\r\n    /**\r\n     * Signs a given object using a private key and returns the signature.\r\n     * The object is first serialized using a schema, then hashed using the specified algorithm.\r\n     * \r\n     * @param privateKeyHex - The private key used for signing, in hex string format.\r\n     * @param object - The object to be signed.\r\n     * @param schema - The JSON schema to serialize the object.\r\n     * @param algorithm - The hashing algorithm to use (default is \"sha3-256\").\r\n     * @returns An object containing the object hash and the signature in hex string format.\r\n     * @throws Error if the signing process fails.\r\n     */\r\n    public static signObject(\r\n        privateKeyHex: string, \r\n        object: any,\r\n        algorithm: string = \"sha3-256\"\r\n    ){\r\n        const objectString = (typeof object === \"object\") ? JSON.stringify(object) : \"{}\";\r\n        const hash = createHash(algorithm).update(objectString).digest('hex');\r\n        const signature = ecc.sign(Buffer.from(hash, 'hex'), Buffer.from(privateKeyHex, 'hex'));\r\n\r\n        const isValid = ecc.verify(\r\n            Buffer.from(hash, 'hex'), \r\n            Buffer.from(Wallet.privateToPublic(privateKeyHex), \"hex\"), \r\n            signature\r\n        );\r\n\r\n        if (signature && isValid) {\r\n            return {\r\n                objectHash: hash,\r\n                signature: Buffer.from(signature).toString('hex')\r\n            };\r\n        }\r\n                    \r\n        throw new Error('Error sign object.');\r\n    }\r\n\r\n    /**\r\n     * Verifies a signature against the hash of an object and a given public key.\r\n     * \r\n     * @param objectHash - The hash of the object being verified, in hex string format.\r\n     * @param signatureHex - The signature to verify, in hex string format.\r\n     * @param publicKeyHex - The public key used for verification, in hex string format.\r\n     * @returns True if the signature is valid, false otherwise.\r\n     */\r\n    public static verifySignature(\r\n        objectHash: any, \r\n        signatureHex: string,\r\n        publicKeyHex: string | Uint8Array | undefined\r\n    ){\r\n        try {\r\n            if (typeof publicKeyHex !== \"string\")\r\n                publicKeyHex = Buffer.from(publicKeyHex).toString(\"hex\");\r\n\r\n            const isValid = ecc.verify(\r\n                Buffer.from(objectHash.replace(\"0x\", \"\"), 'hex'), \r\n                Buffer.from(publicKeyHex.replace(\"0x\", \"\"), 'hex'),\r\n                Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex')  \r\n            );\r\n\r\n            return isValid;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recovers the public key from a given signature and message hash.\r\n     * The recovered public key is returned in compressed format (starting with 02 or 03).\r\n     * \r\n     * @param objectHash - The hash of the object (message).\r\n     * @param signatureHex - The signature in hex string format.\r\n     * @param recoveryId - The recovery ID (typically 0 or 1).\r\n     * @returns The recovered public key as a hex string in compressed format.\r\n     * @throws Error if the public key cannot be recovered.\r\n     */\r\n    public static recoverPublicKey(\r\n        objectHash: string, \r\n        signatureHex: string,\r\n        recoveryId: 0 | 1 = 1 // Default is 1 for recovery ID\r\n    ): string {\r\n        const publicKey = ecc.recover(\r\n            Buffer.from(objectHash.replace(\"0x\", \"\"), 'hex'), \r\n            Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex'), \r\n            recoveryId\r\n        );\r\n\r\n        if (publicKey) {\r\n            const compressedPublicKey = ecc.pointCompress(publicKey, true);\r\n            return Buffer.from(compressedPublicKey).toString('hex');\r\n        }\r\n\r\n        throw new Error('Error recovering public key.');\r\n    }\r\n\r\n    /**\r\n     * Signs a given string by hashing it and returns the signature along with the hash.\r\n     * The string is hashed using the specified algorithm and then signed.\r\n     * \r\n     * @param privateKeyHex - The private key used for signing, in hex string format.\r\n     * @param message - The string message to be signed.\r\n     * @param algorithm - The hashing algorithm to use (default is \"sha256\").\r\n     * @returns An object containing the message hash and the signature in hex string format.\r\n     * @throws Error if the signing process fails.\r\n     */\r\n    public static signString(\r\n        privateKeyHex: string, \r\n        message: string, \r\n        algorithm: string = \"sha256\"\r\n    ): string {\r\n        let hash = createHash(algorithm).update(message).digest();\r\n    \r\n        if (hash.length > 32) \r\n            hash = hash.subarray(0, 32);\r\n        \r\n        const key = bip32.fromPrivateKey(Buffer.from(privateKeyHex, 'hex'), Buffer.alloc(32));\r\n        const signature = ecc.sign(hash, key.privateKey!);\r\n\r\n        if (signature) \r\n            return `${hash.toString('hex')}:${Buffer.from(signature).toString('hex')}`;\r\n\r\n        throw new Error('Error signing string.');\r\n    }\r\n\r\n    /**\r\n     * Verifies a signature against a given message hash and public key.\r\n     * \r\n     * @param messageHash - The hash of the message that was signed, in hex string format.\r\n     * @param signatureHex - The signature to verify, in hex string format.\r\n     * @param publicKeyHex - The public key used for verification, in hex string format.\r\n     * @returns True if the signature is valid, false otherwise.\r\n     */\r\n    public static verifyHashSignature(\r\n        signature: string, \r\n        publicKeyHex: string\r\n    ): boolean {\r\n        try {\r\n            const [messageHash, signatureHex] = signature.split(\":\");\r\n\r\n            const isValid = ecc.verify(\r\n                Buffer.from(messageHash, 'hex'), \r\n                Buffer.from(publicKeyHex, 'hex'), \r\n                Buffer.from(signatureHex, 'hex')\r\n            );\r\n\r\n            return isValid;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recovers the public key from a given signature and message hash.\r\n     * \r\n     * @param messageHash - The hash of the message that was signed, in hex string format.\r\n     * @param signatureHex - The signature in hex string format.\r\n     * @param recoveryId - The recovery ID (typically 0 or 1).\r\n     * @returns The recovered public key as a hex string in compressed format.\r\n     * @throws Error if the public key cannot be recovered.\r\n     */\r\n    public static recoverPublicKeyFromHash(\r\n        signature: string,\r\n        recoveryId: 0 | 1 = 1 // Default is 1 for recovery ID\r\n    ): string {\r\n        const [messageHash, signatureHex] = signature.split(\":\");\r\n\r\n        const publicKey = ecc.recover(\r\n            Buffer.from(messageHash.replace(\"0x\", \"\"), 'hex'), \r\n            Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex'), \r\n            recoveryId\r\n        );\r\n\r\n        if (publicKey) {\r\n            const compressedPublicKey = ecc.pointCompress(publicKey, true);\r\n            return Buffer.from(compressedPublicKey).toString('hex');\r\n        }\r\n\r\n        throw new Error('Error recovering public key.');\r\n    }\r\n\r\n    /**\r\n     * Verifies a signature by trying both recovery IDs (0 and 1) and returns whether the message was signed by the public key.\r\n     * \r\n     * @param signature - The signature in \"hash:signature\" format.\r\n     * @param publicKeyHex - The public key used for verification, in hex string format.\r\n     * @returns True if the message was signed by the public key, false otherwise.\r\n     */\r\n    public static signedBy(\r\n        signature: string,\r\n        publicKeyHex: string\r\n    ): boolean {\r\n        try{\r\n            if(publicKeyHex.startsWith(\"0x\"))\r\n                publicKeyHex = publicKeyHex.replace(\"0x\", \"\");\r\n    \r\n            const key0 = Signer.recoverPublicKeyFromHash(signature, 0);\r\n            const key1 = Signer.recoverPublicKeyFromHash(signature);\r\n            return (publicKeyHex === key0 || publicKeyHex === key1);\r\n        }\r\n        catch{\r\n            return false;\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "objectString",
    "snippet": "const objectString = (typeof object === \"object\") ? JSON.stringify(object) : \"{}\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "hash",
    "snippet": "const hash = createHash(algorithm).update(objectString).digest('hex');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "signature",
    "snippet": "const signature = ecc.sign(Buffer.from(hash, 'hex'), Buffer.from(privateKeyHex, 'hex'));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "isValid",
    "snippet": "const isValid = ecc.verify(\r\n            Buffer.from(hash, 'hex'), \r\n            Buffer.from(Wallet.privateToPublic(privateKeyHex), \"hex\"), \r\n            signature\r\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "isValid",
    "snippet": "const isValid = ecc.verify(\r\n                Buffer.from(objectHash.replace(\"0x\", \"\"), 'hex'), \r\n                Buffer.from(publicKeyHex.replace(\"0x\", \"\"), 'hex'),\r\n                Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex')  \r\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "publicKey",
    "snippet": "const publicKey = ecc.recover(\r\n            Buffer.from(objectHash.replace(\"0x\", \"\"), 'hex'), \r\n            Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex'), \r\n            recoveryId\r\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "compressedPublicKey",
    "snippet": "const compressedPublicKey = ecc.pointCompress(publicKey, true);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key = bip32.fromPrivateKey(Buffer.from(privateKeyHex, 'hex'), Buffer.alloc(32));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "signature",
    "snippet": "const signature = ecc.sign(hash, key.privateKey!);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "isValid",
    "snippet": "const isValid = ecc.verify(\r\n                Buffer.from(messageHash, 'hex'), \r\n                Buffer.from(publicKeyHex, 'hex'), \r\n                Buffer.from(signatureHex, 'hex')\r\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "publicKey",
    "snippet": "const publicKey = ecc.recover(\r\n            Buffer.from(messageHash.replace(\"0x\", \"\"), 'hex'), \r\n            Buffer.from(signatureHex.replace(\"0x\", \"\"), 'hex'), \r\n            recoveryId\r\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "compressedPublicKey",
    "snippet": "const compressedPublicKey = ecc.pointCompress(publicKey, true);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "key0",
    "snippet": "const key0 = Signer.recoverPublicKeyFromHash(signature, 0);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/signer.ts",
    "type": "Constant",
    "value": "key1",
    "snippet": "const key1 = Signer.recoverPublicKeyFromHash(signature);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "ec",
    "snippet": "const ec = new EC('secp256k1');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "bip32",
    "snippet": "const bip32 = BIP32Factory(ecc);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Interface",
    "value": "Network",
    "snippet": "interface Network {\r\n    wif: number;\r\n    bip32: {\r\n        public: number;\r\n        private: number;\r\n    };\r\n    messagePrefix?: string;\r\n    bech32?: string;\r\n    pubKeyHash?: number;\r\n    scriptHash?: number;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Class",
    "value": "Wallet",
    "snippet": "class Wallet {\r\n    /**\r\n     * Returns the entropy size in bits for the given word count of a mnemonic phrase.\r\n     * \r\n     * @param size - The number of words (must be 12, 15, 18, 21, or 24).\r\n     * @returns The entropy size in bits.\r\n     * @throws Error if the word count is invalid.\r\n     */\r\n    public static getEntropyForWordCount(size: number): number {\r\n        const wordToEntropyMap: { [key: number]: number } = {\r\n            3: 32, 6: 64, 9: 96, 12: 128, 15: 160, \r\n            18: 192, 21: 224, 24: 256\r\n        }\r\n\r\n        if (!wordToEntropyMap[size]) \r\n            throw new Error(`Invalid length. Use 12, 15, 18, 21 or 24 words.`);\r\n        \r\n        return wordToEntropyMap[size];\r\n    }\r\n\r\n    /**\r\n     * Generates a mnemonic phrase using the specified word count and wordlist.\r\n     * \r\n     * @param size - The number of words (default is 24).\r\n     * @param wordlists - The wordlist to use (default is English).\r\n     * @returns A mnemonic phrase.\r\n     */\r\n    public static generateMnenomic(\r\n        size: number = 24, \r\n        wordlists: string[] = bip39.wordlists.english\r\n    ): string {\r\n        const entropy = Wallet.getEntropyForWordCount(size);\r\n        return bip39.generateMnemonic(entropy, undefined, wordlists);\r\n    }\r\n\r\n    /**\r\n     * Converts entropy to a mnemonic phrase using a specified wordlist.\r\n     * \r\n     * @param entropy - The entropy to convert (as Buffer or hex string).\r\n     * @param wordlists - The wordlist to use (default is English).\r\n     * @returns A mnemonic phrase.\r\n     */\r\n    public static entropyToMnemonic(\r\n        entropy: Buffer | string, \r\n        wordlists: string[] = bip39.wordlists.english\r\n    ){\r\n        return bip39.entropyToMnemonic(entropy, wordlists);\r\n    }\r\n\r\n    /**\r\n     * Generates a random mnemonic phrase using 32 bytes of random entropy.\r\n     * \r\n     * @param wordlists - The wordlist to use (default is English).\r\n     * @returns A mnemonic phrase.\r\n     */\r\n    public static randomByteMnemonic(\r\n        wordlists: string[] = bip39.wordlists.english\r\n    ){\r\n        const entropy = crypto.randomBytes(32).toString(\"hex\");\r\n        return bip39.entropyToMnemonic(entropy, wordlists);\r\n    }\r\n\r\n    /**\r\n     * Converts a mnemonic phrase to a seed in hexadecimal format.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @returns The seed as a hex string.\r\n     */\r\n    public static getSeed(mnemonic: string){\r\n        return bip39.mnemonicToSeedSync(mnemonic).toString('hex');\r\n    }\r\n\r\n    /**\r\n     * Converts a mnemonic phrase to a seed as a Buffer.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @returns The seed as a Buffer.\r\n     */\r\n    public static getSeedBuffer(mnemonic: string){\r\n        return bip39.mnemonicToSeedSync(mnemonic);\r\n    }\r\n\r\n    /**\r\n     * Derives the root private key from a mnemonic phrase and optional passphrase.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @param passphrase - The passphrase to use (default is empty string).\r\n     * @returns The root private key as a hex string.\r\n     * @throws Error if the private key cannot be derived.\r\n     */\r\n    public static toPrivate(mnemonic: string, passphrase: string = ''){\r\n        const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);\r\n        const rootKey = bip32.fromSeed(seed);\r\n\r\n        if (rootKey.privateKey) \r\n            return Buffer.from(rootKey.privateKey).toString('hex');\r\n        \r\n        throw new Error('Error deriving private key.');\r\n    }\r\n\r\n    /**\r\n     * Creates a BIP derivation path based on the given parameters.\r\n     * \r\n     * @param bip - The BIP number (default is 44).\r\n     * @param coinType - The coin type (0 for Bitcoin, 60 for Ethereum, etc.).\r\n     * @param account - The account number (default is 0).\r\n     * @param change - Whether the address is for receiving (0) or change (1).\r\n     * @param addressIndex - The index of the address (default is 0).\r\n     * @returns A derivation path as a string.\r\n     */\r\n    public static createDerivationPath(\r\n        bip: number = 44,\r\n        coinType: number = 0,    // Coin Type (0 para Bitcoin, 60 para Ethereum, etc.)\r\n        account: number = 0,     // NÃºmero da conta (0 por padrÃ£o)\r\n        change: number = 0,      // 0 para recebimento, 1 para troco\r\n        addressIndex: number = 0 // Ãndice do endereÃ§o\r\n    ): string {\r\n        return `m/${bip}'/${coinType}'/${account}'/${change}/${addressIndex}'`;\r\n    }\r\n\r\n    /**\r\n     * Derives the private key from a mnemonic phrase using a specific derivation path.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @param derivationPath - The derivation path (default is \"m/44'/0'/0'/0/0\").\r\n     * @param passphrase - The passphrase to use (default is empty string).\r\n     * @returns The derived private key as a hex string.\r\n     * @throws Error if the private key cannot be derived.\r\n     */\r\n    public static toDerivatationPrivateKey(\r\n        mnemonic: string, \r\n        derivationPath: string = \"m/44'/0'/0'/0/0\", \r\n        passphrase: string = ''\r\n    ){\r\n        const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);\r\n        const rootKey = bip32.fromSeed(seed);\r\n        const child = rootKey.derivePath(derivationPath);\r\n\r\n        if (child.privateKey) \r\n            return Buffer.from(child.privateKey).toString('hex');\r\n\r\n        throw new Error('Error deriving private key.');\r\n    }\r\n\r\n    /**\r\n     * Derives the root key in Base58 format from a mnemonic phrase and optional network.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @param passphrase - The passphrase to protect the mnemonic (optional).\r\n     * @param network - The network parameters (optional).\r\n     * @returns The root key in Base58 format.\r\n     */\r\n    public static toRootKey(\r\n        mnemonic: string,\r\n        passphrase: string = '',\r\n        network?: Network\r\n    ) {\r\n        const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);\r\n        const rootKey = bip32.fromSeed(seed, network);\r\n        return rootKey.toBase58();\r\n    }\r\n\r\n    /**\r\n     * Derives the public key from a mnemonic phrase using a specific derivation path.\r\n     * \r\n     * @param mnemonic - The mnemonic phrase.\r\n     * @param derivationPath - The derivation path (default is \"m/44'/0'/0'/0/0\").\r\n     * @param passphrase - The passphrase to use (default is empty string).\r\n     * @returns The derived public key as a hex string.\r\n     * @throws Error if the public key cannot be derived.\r\n     */\r\n    public static toPublic(\r\n        mnemonic: string, \r\n        derivationPath: string = \"m/44'/0'/0'/0/0\", \r\n        passphrase: string = ''\r\n    ): string {\r\n        const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);\r\n        const rootKey = bip32.fromSeed(seed);\r\n        const child = rootKey.derivePath(derivationPath);\r\n\r\n        if (child.publicKey) \r\n            return Buffer.from(child.publicKey).toString('hex');\r\n        \r\n        throw new Error('Error deriving public key.');\r\n    }\r\n\r\n    /**\r\n     * Derives the public key from a given private key.\r\n     * \r\n     * @param privateKey - The private key in hex string format.\r\n     * @returns The derived public key as a hex string.\r\n     * @throws Error if the public key cannot be derived.\r\n     */\r\n    public static privateToPublic(privateKey: string | Uint8Array): string {\r\n        if(typeof privateKey !== \"string\")\r\n            privateKey = Buffer.from(privateKey).toString(\"hex\");\r\n\r\n        const keyPair = bip32.fromPrivateKey(Buffer.from(privateKey, 'hex'), Buffer.alloc(32));\r\n        \r\n        if (keyPair.publicKey) \r\n            return Buffer.from(keyPair.publicKey).toString('hex');\r\n        \r\n        throw new Error('Error deriving public key from private key.');\r\n    }\r\n\r\n    /**\r\n     * Derives the public key directly from a derived BIP32 key (from mnemonic or path).\r\n     * \r\n     * @param bip32Key - The derived BIP32 key object from which to get the public key.\r\n     * @returns The public key in hex format.\r\n     */\r\n    public static bip32ToPublic(bip32Key: any): string {\r\n        if (bip32Key.publicKey) \r\n            return Buffer.from(bip32Key.publicKey).toString('hex');\r\n                \r\n        throw new Error('Error deriving public key from BIP32 key.');\r\n    }\r\n\r\n    /**\r\n     * Converts a private key into WIF (Wallet Import Format).\r\n     * \r\n     * @param privateKey - The private key in hexadecimal format.\r\n     * @param compressed - Whether the public key will be compressed (default is true).\r\n     * @returns The private key in WIF format (Base58).\r\n     */\r\n    public static privateKeyToWIF(privateKey: string, compressed: boolean = true): string {\r\n        const prefix = Buffer.from([0x80]); \r\n        const privateKeyBuffer = Buffer.from(privateKey, 'hex');\r\n        const suffix = compressed ? Buffer.from([0x01]) : Buffer.alloc(0);\r\n        const extendedKey = Buffer.concat([prefix, privateKeyBuffer, suffix]);\r\n        const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedKey).digest()).digest().subarray(0, 4);\r\n        const finalKey = Buffer.concat([extendedKey, checksum]);\r\n        return bs58.encode(finalKey);\r\n    }\r\n\r\n    /**\r\n     * Converts a WIF (Wallet Import Format) key back into a private key.\r\n     * \r\n     * @param wif - The WIF encoded private key.\r\n     * @returns The private key in hexadecimal format.\r\n     * @throws Error if the WIF key is invalid.\r\n     */\r\n    public static wifToPrivateKey(wif: string): { privateKey: string, compressed: boolean } {\r\n        const decoded = bs58.decode(wif);\r\n        const privateKey = decoded.slice(1, 33); // 32 bytes of private key\r\n        const suffix = decoded.slice(33, 34); // Optional suffix for compressed keys\r\n\r\n        const checksum = decoded.slice(decoded.length - 4);\r\n        const keyWithoutChecksum = decoded.slice(0, decoded.length - 4);\r\n        \r\n        const newChecksum = crypto.createHash('sha256').update(\r\n            crypto.createHash('sha256').update(keyWithoutChecksum).digest()\r\n        ).digest().subarray(0, 4);\r\n        \r\n        if (!Buffer.from(checksum).equals(newChecksum)) \r\n            throw new Error('Invalid WIF checksum');\r\n\r\n        const compressed = Buffer.from(suffix).equals(Buffer.from([0x01]));\r\n\r\n        return {\r\n            privateKey: Buffer.from(privateKey).toString('hex'),\r\n            compressed\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates a public address (Base58) from a private key.\r\n     * \r\n     * @param privateKey - The private key in hexadecimal format.\r\n     * @returns The public address in Base58 format.\r\n     */\r\n    public static privateKeyToAddress(\r\n        privateKey: string | Uint8Array | undefined\r\n    ): string {\r\n        if(typeof privateKey !== \"string\")\r\n            privateKey = Buffer.from(privateKey).toString(\"hex\");\r\n\r\n        const keyPair = ec.keyFromPrivate(privateKey);\r\n        const publicKey = keyPair.getPublic(true, 'hex'); // Compressed form\r\n        const sha256Hash = crypto.createHash('sha256').update(Buffer.from(publicKey, 'hex')).digest();\r\n        const ripemd160Hash = crypto.createHash('ripemd160').update(sha256Hash).digest();\r\n\r\n        const prefix = Buffer.from([0x00]);\r\n        const extendedPublicKey = Buffer.concat([prefix, ripemd160Hash]);\r\n\r\n        const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedPublicKey).digest()).digest().slice(0, 4);\r\n        const finalPublicKey = Buffer.concat([extendedPublicKey, checksum]);\r\n\r\n        return bs58.encode(finalPublicKey);\r\n    }\r\n\r\n    /**\r\n     * Generates a public address (Base58) from a public key.\r\n     * \r\n     * @param publicKey - The public key in hexadecimal format.\r\n     * @returns The public address in Base58 format.\r\n     */\r\n    public static publicKeyToAddress(publicKey: string): string {\r\n        const sha256Hash = crypto.createHash('sha256').update(Buffer.from(publicKey, 'hex')).digest();\r\n        const ripemd160Hash = crypto.createHash('ripemd160').update(sha256Hash).digest();\r\n\r\n        const prefix = Buffer.from([0x00]); \r\n        const extendedPublicKey = Buffer.concat([prefix, ripemd160Hash]);\r\n        const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedPublicKey).digest()).digest().slice(0, 4);\r\n        const finalPublicKey = Buffer.concat([extendedPublicKey, checksum]);\r\n\r\n        return bs58.encode(finalPublicKey);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "wordToEntropyMap",
    "snippet": "const wordToEntropyMap: { [key: number]: number } = {\r\n            3: 32, 6: 64, 9: 96, 12: 128, 15: 160, \r\n            18: 192, 21: 224, 24: 256\r\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "entropy",
    "snippet": "const entropy = Wallet.getEntropyForWordCount(size);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "entropy",
    "snippet": "const entropy = crypto.randomBytes(32).toString(\"hex\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "seed",
    "snippet": "const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "rootKey",
    "snippet": "const rootKey = bip32.fromSeed(seed);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "seed",
    "snippet": "const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "rootKey",
    "snippet": "const rootKey = bip32.fromSeed(seed);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "child",
    "snippet": "const child = rootKey.derivePath(derivationPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "seed",
    "snippet": "const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "rootKey",
    "snippet": "const rootKey = bip32.fromSeed(seed, network);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "seed",
    "snippet": "const seed = bip39.mnemonicToSeedSync(mnemonic, passphrase);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "rootKey",
    "snippet": "const rootKey = bip32.fromSeed(seed);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "child",
    "snippet": "const child = rootKey.derivePath(derivationPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "keyPair",
    "snippet": "const keyPair = bip32.fromPrivateKey(Buffer.from(privateKey, 'hex'), Buffer.alloc(32));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = Buffer.from([0x80]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "privateKeyBuffer",
    "snippet": "const privateKeyBuffer = Buffer.from(privateKey, 'hex');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "suffix",
    "snippet": "const suffix = compressed ? Buffer.from([0x01]) : Buffer.alloc(0);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "extendedKey",
    "snippet": "const extendedKey = Buffer.concat([prefix, privateKeyBuffer, suffix]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "checksum",
    "snippet": "const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedKey).digest()).digest().subarray(0, 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "finalKey",
    "snippet": "const finalKey = Buffer.concat([extendedKey, checksum]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "decoded",
    "snippet": "const decoded = bs58.decode(wif);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "privateKey",
    "snippet": "const privateKey = decoded.slice(1, 33);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "suffix",
    "snippet": "const suffix = decoded.slice(33, 34);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "checksum",
    "snippet": "const checksum = decoded.slice(decoded.length - 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "keyWithoutChecksum",
    "snippet": "const keyWithoutChecksum = decoded.slice(0, decoded.length - 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "newChecksum",
    "snippet": "const newChecksum = crypto.createHash('sha256').update(\r\n            crypto.createHash('sha256').update(keyWithoutChecksum).digest()\r\n        ).digest().subarray(0, 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "compressed",
    "snippet": "const compressed = Buffer.from(suffix).equals(Buffer.from([0x01]));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "keyPair",
    "snippet": "const keyPair = ec.keyFromPrivate(privateKey);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "publicKey",
    "snippet": "const publicKey = keyPair.getPublic(true, 'hex');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "sha256Hash",
    "snippet": "const sha256Hash = crypto.createHash('sha256').update(Buffer.from(publicKey, 'hex')).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "ripemd160Hash",
    "snippet": "const ripemd160Hash = crypto.createHash('ripemd160').update(sha256Hash).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = Buffer.from([0x00]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "extendedPublicKey",
    "snippet": "const extendedPublicKey = Buffer.concat([prefix, ripemd160Hash]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "checksum",
    "snippet": "const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedPublicKey).digest()).digest().slice(0, 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "finalPublicKey",
    "snippet": "const finalPublicKey = Buffer.concat([extendedPublicKey, checksum]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "sha256Hash",
    "snippet": "const sha256Hash = crypto.createHash('sha256').update(Buffer.from(publicKey, 'hex')).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "ripemd160Hash",
    "snippet": "const ripemd160Hash = crypto.createHash('ripemd160').update(sha256Hash).digest();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = Buffer.from([0x00]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "extendedPublicKey",
    "snippet": "const extendedPublicKey = Buffer.concat([prefix, ripemd160Hash]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "checksum",
    "snippet": "const checksum = crypto.createHash('sha256').update(crypto.createHash('sha256').update(extendedPublicKey).digest()).digest().slice(0, 4);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-encryptor/src/wallet.ts",
    "type": "Constant",
    "value": "finalPublicKey",
    "snippet": "const finalPublicKey = Buffer.concat([extendedPublicKey, checksum]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/sample/listeners.service.ts",
    "type": "Class",
    "value": "Listerner",
    "snippet": "@Service('listerner')\nexport class Listerner {\n  constructor(private readonly eventsService: EventsService) {}\n\n  @OnEvent('hello-world')\n  public async OnReciveMessage(payload: any) {\n    console.log('hello-world', payload);\n    //this.eventsService.emit(\"hello-world\", { hello: \"world\" });\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.decorator.ts",
    "type": "Function",
    "value": "OnEvent",
    "snippet": "function OnEvent(message: string): MethodDecorator {\n  return (\n    target,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor,\n  ) => {\n    EventsRegistry.registerConsumeHandler(\n      target,\n      message,\n      propertyKey as string,\n      descriptor.value,\n    );\n  };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.module.ts",
    "type": "Constant",
    "value": "EventsModule",
    "snippet": "const EventsModule = new Module('events', {\n  providers: [EventsService],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.registry.ts",
    "type": "Class",
    "value": "EventsRegistry",
    "snippet": "class EventsRegistry {\n  public static events = new Map<string, { consumes: any[] }>();\n\n  public static registerConsumeHandler(\n    target: any,\n    message: string,\n    handlerName: string,\n    callback: Function,\n  ) {\n    let events = this.events.get(message);\n\n    if (!events) {\n      this.events.set(message, {\n        consumes: [],\n      });\n\n      events = this.events.get(message);\n    }\n\n    if (events) {\n      const handler = events.consumes.find(\n        (msg) => msg.handlerName === handlerName,\n      );\n\n      if (!handler) events.consumes.push({ handlerName, cb: callback });\n      else handler.cb = callback;\n    }\n  }\n\n  public static getEvents() {\n    return Array.from(this.events.entries());\n  }\n\n  public static getConsumes(target: any): any[] {\n    const events = this.events.get(target);\n    return events ? events.consumes : [];\n  }\n\n  public static clear() {\n    EventsRegistry.events = new Map<string, { consumes: any[] }>();\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.registry.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = events.consumes.find(\n        (msg) => msg.handlerName === handlerName,\n      );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.registry.ts",
    "type": "Constant",
    "value": "events",
    "snippet": "const events = this.events.get(target);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.service.ts",
    "type": "Class",
    "value": "EventsService",
    "snippet": "@Service('events')\nexport class EventsService extends Singleton {\n  public logger: Logger = new Logger('EventsService');\n  public emitter: EventEmitter2;\n\n  public static async loadConfig(application: Application): Promise<void> {\n    const instance = EventsService.getInstance();\n    const config = Config.get('events', {});\n\n    try {\n      instance.emitter = new EventEmitter2(config);\n      const events: any = EventsRegistry.getEvents();\n\n      events.forEach(async ([message, metadata]) => {\n        metadata?.consumes.forEach(({ cb }) => {\n          instance.emitter.on(message, (payload) => cb(payload));\n        });\n      });\n    } catch (e) {\n      instance.logger.error(e.message);\n      console.error(e);\n    }\n  }\n\n  public emit(message: string, payload: any) {\n    const instance = EventsService.getInstance();\n    instance.emitter.emit(message, payload);\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = EventsService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.service.ts",
    "type": "Constant",
    "value": "config",
    "snippet": "const config = Config.get('events', {});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.service.ts",
    "type": "Constant",
    "value": "events",
    "snippet": "const events: any = EventsRegistry.getEvents();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-events/src/events.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = EventsService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "compression",
    "snippet": "const compression = require('compression');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Interface",
    "value": "ExpressRequest",
    "snippet": "interface ExpressRequest extends express.Request {\n    requestId?: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Class",
    "value": "ExpressAdapter",
    "snippet": "class ExpressAdapter extends AbstractHttpAdapter<\n    http.Server | https.Server\n> {\n    protected readonly openConnections = new Set<Duplex>();\n\n    constructor(protected instance?: any) {\n        super(instance || express());\n    }\n\n    public async init(application: Application, settings?: IHTTPSettings) {\n        let publicDirs = Config.get<string[]>('server.publicDirs', [\n            'public/views',\n        ]);\n\n        const renderEngine = Config.get<string>('server.render', 'cmmv');\n\n        if (publicDirs.length > 0)\n            publicDirs = publicDirs.map(dir => path.join(process.cwd(), dir));\n\n        this.application = application;\n\n        this.instance = this.instance || express();\n\n        if (!Config.get<boolean>('server.poweredBy', false))\n            this.instance.disable('x-powered-by');\n\n        if (Config.get<boolean>('server.compress.enabled', true))\n            this.instance.use(compression({ level: 6 }));\n\n        if (renderEngine === '@cmmv/view' || renderEngine === 'cmmv') {\n            for (const publicDir of publicDirs) {\n                this.instance.use(\n                    express.static(publicDir, {\n                        setHeaders: (res, path) => {\n                            if (path.endsWith('.html')) {\n                                res.setHeader('Cache-Control', 'no-cache');\n                            } else {\n                                res.setHeader(\n                                    'Cache-Control',\n                                    'public, max-age=31536000, immutable',\n                                );\n                            }\n                        },\n                    }),\n                );\n            }\n\n            const { CMMVRenderer } = await import('@cmmv/view');\n            const render = new CMMVRenderer();\n\n            this.instance.set('views', publicDirs);\n            this.instance.set('view engine', 'html');\n            this.instance.engine('html', (filePath, options, callback) => {\n                render.renderFile(\n                    filePath,\n                    options,\n                    { nonce: options.nonce || '' },\n                    callback,\n                );\n            });\n        } else if (renderEngine) {\n            this.instance.set('views', publicDirs);\n            this.instance.set('view engine', renderEngine);\n        }\n\n        this.instance.use(express.json());\n        this.instance.use(bodyParser.json({ limit: '50mb' }));\n        this.instance.use(\n            bodyParser.urlencoded({\n                limit: '50mb',\n                extended: true,\n            }),\n        );\n\n        if (Config.get<boolean>('server.cors', true)) {\n            this.instance.use(\n                cors({\n                    methods: ['GET', 'POST', 'PUT', 'DELETE'],\n                    allowedHeaders: ['Content-Type', 'Authorization'],\n                }),\n            );\n        }\n\n        if (Config.get<boolean>('server.helmet.enabled', true)) {\n            this.instance.use(\n                helmet(\n                    Config.get('server.helmet.options', {\n                        contentSecurityPolicy: false,\n                    }),\n                ),\n            );\n        }\n\n        if (Config.get<boolean>('server.session.enabled', false)) {\n            this.instance.use(\n                session(\n                    Config.get('server.session.options', {\n                        secret: process.env.SESSION_SECRET,\n                        resave: false,\n                        saveUninitialized: false,\n                        cookie: { secure: true },\n                    }),\n                ),\n            );\n        }\n\n        this.setMiddleware();\n        this.registerControllers();\n        this.initHttpServer(settings);\n    }\n\n    public initHttpServer(options: any) {\n        const isHttpsEnabled = options && options.httpsOptions;\n\n        if (isHttpsEnabled) {\n            this.httpServer = https.createServer(\n                options.httpsOptions,\n                this.instance,\n            );\n        } else {\n            this.httpServer = http.createServer(this.instance);\n        }\n\n        if (!this.httpServer) throw new Error('Unable to start HTTP adapter');\n\n        this.trackOpenConnections();\n    }\n\n    private trackOpenConnections() {\n        this.httpServer.on('connection', (socket: Duplex) => {\n            this.openConnections.add(socket);\n            socket.on('close', () => this.openConnections.delete(socket));\n        });\n    }\n\n    private closeOpenConnections() {\n        for (const socket of this.openConnections) {\n            socket.destroy();\n            this.openConnections.delete(socket);\n        }\n    }\n\n    private setMiddleware() {\n        this.instance.use((req, res, next) => {\n            req.requestId = uuidv4();\n\n            res.locals.nonce = uuidv4().substring(0, 8);\n            const customHeaders = Config.get('headers') || {};\n\n            for (const headerName in customHeaders) {\n                let headerValue = customHeaders[headerName];\n\n                if (Array.isArray(headerValue)) {\n                    headerValue = headerValue\n                        .map(value => {\n                            if (headerName === 'Content-Security-Policy')\n                                return value.indexOf('style-src') == -1\n                                    ? `${value} 'nonce-${res.locals.nonce}'`\n                                    : value;\n\n                            return value;\n                        })\n                        .join('; ');\n                } else if (typeof headerValue === 'string') {\n                    if (headerName === 'Content-Security-Policy')\n                        headerValue =\n                            headerValue.indexOf('style-src') == -1\n                                ? `${headerValue} 'nonce-${res.locals.nonce}'`\n                                : headerValue;\n                }\n\n                res.setHeader(headerName, headerValue);\n            }\n\n            if (req.method === 'GET') {\n                if (!Config.get<boolean>('server.removePolicyHeaders', false)) {\n                    res.setHeader(\n                        'Strict-Transport-Security',\n                        'max-age=15552000; includeSubDomains',\n                    );\n                    res.setHeader('X-Content-Type-Options', 'nosniff');\n                    res.setHeader('X-Frame-Options', 'SAMEORIGIN');\n                    res.setHeader('X-XSS-Protection', '0');\n                }\n            }\n\n            if (['POST', 'PUT', 'DELETE'].includes(req.method)) {\n                if (!Config.get<boolean>('server.removePolicyHeaders', false)) {\n                    res.removeHeader('X-DNS-Prefetch-Control');\n                    res.removeHeader('X-Download-Options');\n                    res.removeHeader('X-Permitted-Cross-Domain-Policies');\n                    res.removeHeader('Strict-Transport-Security');\n                    res.removeHeader('Content-Security-Policy');\n                    res.removeHeader('Cross-Origin-Opener-Policy');\n                    res.removeHeader('Cross-Origin-Resource-Policy');\n                    res.removeHeader('Origin-Agent-Cluster');\n                    res.removeHeader('Referrer-Policy');\n                }\n            }\n\n            next();\n        });\n\n        this.instance.use((req, res, next) => {\n            Telemetry.start('Request Process', req.requestId);\n            const publicDir = path.join(process.cwd(), 'public/views');\n            const requestPath =\n                req.path === '/' ? 'index' : req.path.substring(1);\n            const ext = path.extname(req.path);\n\n            if (req.path.indexOf('.html') === -1 && req.path !== '/')\n                return next();\n\n            const possiblePaths = [\n                path.join(publicDir, `${requestPath}.html`),\n                path.join(publicDir, requestPath, 'index.html'),\n                path.join(publicDir, `${requestPath}`),\n                path.join(publicDir, requestPath, 'index.html'),\n            ];\n\n            let fileFound = false;\n\n            for (const filePath of possiblePaths) {\n                if (fs.existsSync(filePath)) {\n                    fileFound = true;\n\n                    const config = Config.getAll();\n\n                    return res.render(filePath, {\n                        nonce: res.locals.nonce,\n                        services: ServiceRegistry.getServicesArr(),\n                        requestId: req.requestId,\n                        config,\n                    });\n                }\n            }\n\n            if (!fileFound) res.status(404).send('Page not found');\n        });\n    }\n\n    private registerControllers() {\n        const controllers = ControllerRegistry.getControllers();\n\n        controllers.forEach(([controllerClass, metadata]) => {\n            const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\n            const instances = paramTypes.map((paramType: any) =>\n                this.application.providersMap.get(paramType.name),\n            );\n\n            const instance = new controllerClass(...instances);\n            const prefix = metadata.prefix;\n            const routes = metadata.routes;\n\n            routes.forEach(route => {\n                const fullPath = `/${prefix}${route.path ? '/' + route.path : ''}`;\n                const method = route.method.toLowerCase();\n\n                if (this.instance[method]) {\n                    const handler = async (\n                        req: ExpressRequest | any,\n                        res: express.Response,\n                        next: any,\n                    ) => {\n                        const startTime = Date.now();\n\n                        try {\n                            req.contextId = crypto\n                                .createHash('md5')\n                                .update(`${req.method}::${req.route.path}`)\n                                .digest('hex');\n\n                            if (\n                                Application.appModule.httpInterceptors.length >\n                                0\n                            ) {\n                                for (const interceptor of Application.appModule\n                                    .httpInterceptors) {\n                                    const breakProcess = await interceptor(\n                                        `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                        {\n                                            req,\n                                            res,\n                                            next,\n                                            handler:\n                                                instance[route.handlerName],\n                                        },\n                                    );\n\n                                    if (breakProcess) return;\n                                }\n                            }\n\n                            const args = this.buildRouteArgs(\n                                req,\n                                res,\n                                next,\n                                route.params,\n                            );\n\n                            Telemetry.start(\n                                'Controller Handler',\n                                req.requestId,\n                            );\n\n                            const result = await instance[route.handlerName](\n                                ...args,\n                            );\n\n                            Telemetry.end('Controller Handler', req.requestId);\n\n                            const processingTime = Date.now() - startTime;\n                            Telemetry.end('Request Process', req.requestId);\n                            const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );\n\n                            if (this.isJson(result)) {\n                                const response = {\n                                    status: 200,\n                                    processingTime,\n                                    data: result,\n                                };\n\n                                if (req.query.debug) {\n                                    response['requestId'] = req.requestId;\n                                    response['telemetry'] = telemetry;\n                                }\n\n                                if (\n                                    Application.appModule.httpAfterRender\n                                        .length > 0\n                                ) {\n                                    for (const afterRender of Application\n                                        .appModule.httpAfterRender) {\n                                        await afterRender(\n                                            `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                            {\n                                                req,\n                                                res,\n                                                next,\n                                                handler:\n                                                    instance[route.handlerName],\n                                                content: response,\n                                            },\n                                        );\n                                    }\n                                }\n\n                                res.json(response);\n                            } else if (result) {\n                                if (\n                                    Application.appModule.httpAfterRender\n                                        .length > 0\n                                ) {\n                                    for (const afterRender of Application\n                                        .appModule.httpAfterRender) {\n                                        await afterRender(\n                                            `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                            {\n                                                req,\n                                                res,\n                                                next,\n                                                handler:\n                                                    instance[route.handlerName],\n                                                content: result,\n                                            },\n                                        );\n                                    }\n                                }\n\n                                res.status(200).send(result);\n                            }\n                        } catch (error) {\n                            console.error(error);\n                            const processingTime = Date.now() - startTime;\n                            Telemetry.end('Request Process', req.requestId);\n                            const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );\n\n                            const response = {\n                                status: 500,\n                                processingTime,\n                                message:\n                                    error.message || 'Internal Server Error',\n                            };\n\n                            if (req.query.debug) {\n                                response['requestId'] = req.requestId;\n                                response['telemetry'] = telemetry;\n                            }\n\n                            res.status(500).json(response);\n                        }\n\n                        Telemetry.clearTelemetry(req.requestId);\n                    };\n\n                    if (route.middlewares) {\n                        this.instance[method](\n                            fullPath,\n                            async (req, res, next) => {\n                                try {\n                                    if (\n                                        Array.isArray(route.middlewares) &&\n                                        route.middlewares.length > 0\n                                    ) {\n                                        for (const middleware of route.middlewares) {\n                                            await new Promise(\n                                                (resolve, reject) => {\n                                                    middleware(\n                                                        req,\n                                                        res,\n                                                        err => {\n                                                            if (err)\n                                                                return reject(\n                                                                    err,\n                                                                );\n                                                            resolve(null);\n                                                        },\n                                                    );\n                                                },\n                                            );\n                                        }\n                                    }\n\n                                    await handler(req, res, next);\n                                } catch (error) {\n                                    console.error(\n                                        'Error processing middlewares or handler:',\n                                        error,\n                                    );\n                                    next(error);\n                                }\n                            },\n                        );\n                    } else {\n                        this.instance[method](fullPath, handler);\n                    }\n                }\n            });\n        });\n    }\n\n    private buildRouteArgs(\n        req: express.Request | any,\n        res: express.Response,\n        next: any,\n        params: any[],\n    ) {\n        const args: any[] = [];\n\n        params?.forEach(param => {\n            const [paramType, paramName] = param.paramType.split(':');\n            switch (paramType) {\n                case 'body':\n                    args[param.index] = req.body;\n                    break;\n                case 'param':\n                    args[param.index] = req.params[paramName];\n                    break;\n                case 'query':\n                    args[param.index] = req.query[paramName];\n                    break;\n                case 'queries':\n                    args[param.index] = req.query;\n                    break;\n                case 'header':\n                    args[param.index] = req.headers[paramName.toLowerCase()];\n                    break;\n                case 'headers':\n                    args[param.index] = req.headers;\n                    break;\n                case 'request':\n                    args[param.index] = req;\n                    break;\n                case 'response':\n                    args[param.index] = res;\n                    break;\n                case 'next':\n                    args[param.index] = next;\n                    break;\n                case 'session':\n                    args[param.index] = req.session;\n                    break;\n                case 'user':\n                    args[param.index] = req.user;\n                    break;\n                case 'ip':\n                    args[param.index] = req.ip;\n                    break;\n                case 'hosts':\n                    args[param.index] = req.hosts;\n                    break;\n                default:\n                    args[param.index] = undefined;\n                    break;\n            }\n        });\n\n        return args;\n    }\n\n    public listen(bind: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const [host, port] = bind.split(':');\n\n            this.httpServer.listen(parseInt(port, 10), host, (err?: any) => {\n                if (err) return reject(err);\n\n                resolve();\n            });\n        });\n    }\n\n    public connected() {\n        return this.instance.enabled;\n    }\n\n    public close() {\n        this.closeOpenConnections();\n\n        if (!this.httpServer) return undefined;\n\n        return new Promise((resolve, reject) => {\n            if (this.connected()) {\n                try {\n                    this.httpServer.close(err => {\n                        if (err) reject(err);\n                        else resolve('');\n                    });\n                } catch (err) {\n                    reject(err);\n                }\n            } else {\n                resolve('');\n            }\n        });\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "renderEngine",
    "snippet": "const renderEngine = Config.get<string>('server.render', 'cmmv');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "publicDir",
    "snippet": "const publicDir"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "render",
    "snippet": "const render = new CMMVRenderer();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "isHttpsEnabled",
    "snippet": "const isHttpsEnabled = options && options.httpsOptions;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "socket",
    "snippet": "const socket"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "customHeaders",
    "snippet": "const customHeaders = Config.get('headers') || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "headerName",
    "snippet": "const headerName"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "publicDir",
    "snippet": "const publicDir = path.join(process.cwd(), 'public/views');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "requestPath",
    "snippet": "const requestPath =\n                req.path === '/' ? 'index' : req.path.substring(1);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "ext",
    "snippet": "const ext = path.extname(req.path);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "possiblePaths",
    "snippet": "const possiblePaths = [\n                path.join(publicDir, `${requestPath}.html`),\n                path.join(publicDir, requestPath, 'index.html'),\n                path.join(publicDir, `${requestPath}`),\n                path.join(publicDir, requestPath, 'index.html'),\n            ];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "filePath",
    "snippet": "const filePath"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "config",
    "snippet": "const config = Config.getAll();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "controllers",
    "snippet": "const controllers = ControllerRegistry.getControllers();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\n                this.application.providersMap.get(paramType.name),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = metadata.prefix;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "routes",
    "snippet": "const routes = metadata.routes;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "fullPath",
    "snippet": "const fullPath = `/${prefix}${route.path ? '/' + route.path : ''}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method = route.method.toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = async (\n                        req: ExpressRequest | any,\n                        res: express.Response,\n                        next: any,\n                    ) => {\n                        const startTime = Date.now();\n\n                        try {\n                            req.contextId = crypto\n                                .createHash('md5')\n                                .update(`${req.method}::${req.route.path}`)\n                                .digest('hex');\n\n                            if (\n                                Application.appModule.httpInterceptors.length >\n                                0\n                            ) {\n                                for (const interceptor of Application.appModule\n                                    .httpInterceptors) {\n                                    const breakProcess = await interceptor(\n                                        `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                        {\n                                            req,\n                                            res,\n                                            next,\n                                            handler:\n                                                instance[route.handlerName],\n                                        },\n                                    );\n\n                                    if (breakProcess) return;\n                                }\n                            }\n\n                            const args = this.buildRouteArgs(\n                                req,\n                                res,\n                                next,\n                                route.params,\n                            );\n\n                            Telemetry.start(\n                                'Controller Handler',\n                                req.requestId,\n                            );\n\n                            const result = await instance[route.handlerName](\n                                ...args,\n                            );\n\n                            Telemetry.end('Controller Handler', req.requestId);\n\n                            const processingTime = Date.now() - startTime;\n                            Telemetry.end('Request Process', req.requestId);\n                            const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );\n\n                            if (this.isJson(result)) {\n                                const response = {\n                                    status: 200,\n                                    processingTime,\n                                    data: result,\n                                };\n\n                                if (req.query.debug) {\n                                    response['requestId'] = req.requestId;\n                                    response['telemetry'] = telemetry;\n                                }\n\n                                if (\n                                    Application.appModule.httpAfterRender\n                                        .length > 0\n                                ) {\n                                    for (const afterRender of Application\n                                        .appModule.httpAfterRender) {\n                                        await afterRender(\n                                            `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                            {\n                                                req,\n                                                res,\n                                                next,\n                                                handler:\n                                                    instance[route.handlerName],\n                                                content: response,\n                                            },\n                                        );\n                                    }\n                                }\n\n                                res.json(response);\n                            } else if (result) {\n                                if (\n                                    Application.appModule.httpAfterRender\n                                        .length > 0\n                                ) {\n                                    for (const afterRender of Application\n                                        .appModule.httpAfterRender) {\n                                        await afterRender(\n                                            `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                            {\n                                                req,\n                                                res,\n                                                next,\n                                                handler:\n                                                    instance[route.handlerName],\n                                                content: result,\n                                            },\n                                        );\n                                    }\n                                }\n\n                                res.status(200).send(result);\n                            }\n                        } catch (error) {\n                            console.error(error);\n                            const processingTime = Date.now() - startTime;\n                            Telemetry.end('Request Process', req.requestId);\n                            const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );\n\n                            const response = {\n                                status: 500,\n                                processingTime,\n                                message:\n                                    error.message || 'Internal Server Error',\n                            };\n\n                            if (req.query.debug) {\n                                response['requestId'] = req.requestId;\n                                response['telemetry'] = telemetry;\n                            }\n\n                            res.status(500).json(response);\n                        }\n\n                        Telemetry.clearTelemetry(req.requestId);\n                    };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "startTime",
    "snippet": "const startTime = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "interceptor",
    "snippet": "const interceptor"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "breakProcess",
    "snippet": "const breakProcess = await interceptor(\n                                        `${req.method}::${req.route.path}`.toLocaleLowerCase(),\n                                        {\n                                            req,\n                                            res,\n                                            next,\n                                            handler:\n                                                instance[route.handlerName],\n                                        },\n                                    );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "args",
    "snippet": "const args = this.buildRouteArgs(\n                                req,\n                                res,\n                                next,\n                                route.params,\n                            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance[route.handlerName](\n                                ...args,\n                            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "processingTime",
    "snippet": "const processingTime = Date.now() - startTime;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "telemetry",
    "snippet": "const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = {\n                                    status: 200,\n                                    processingTime,\n                                    data: result,\n                                };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "afterRender",
    "snippet": "const afterRender"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "afterRender",
    "snippet": "const afterRender"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "processingTime",
    "snippet": "const processingTime = Date.now() - startTime;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "telemetry",
    "snippet": "const telemetry = Telemetry.getTelemetry(\n                                req.requestId,\n                            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = {\n                                status: 500,\n                                processingTime,\n                                message:\n                                    error.message || 'Internal Server Error',\n                            };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.adapter.ts",
    "type": "Constant",
    "value": "args",
    "snippet": "const args: any[] = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-express/src/express.module.ts",
    "type": "Constant",
    "value": "ExpressModule",
    "snippet": "const ExpressModule = new Module('express', {});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Interface",
    "value": "FastifyRequestCustom",
    "snippet": "interface FastifyRequestCustom extends FastifyRequest {\n    requestId?: string;\n    nonce?: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Class",
    "value": "FastifyAdapter",
    "snippet": "class FastifyAdapter extends AbstractHttpAdapter<FastifyInstance> {\n    protected readonly openConnections = new Set<Duplex>();\n\n    constructor(instance?: FastifyInstance) {\n        super(instance || require('fastify')());\n    }\n\n    public async init(application: Application, settings?: IHTTPSettings) {\n        let publicDirs = Config.get<string[]>('server.publicDirs', [\n            'public/views',\n        ]);\n\n        this.application = application;\n\n        this.instance.register(fastifyCompress);\n\n        this.instance.register(fastifyStatic, {\n            root: publicDirs,\n            prefix: '/assets',\n        });\n\n        this.instance.register(fastifyView, {\n            engine: { ejs: require('@cmmv/view') },\n            root: publicDirs,\n            defaultContext: {},\n            propertyName: 'view',\n        });\n\n        this.instance.register(require('@fastify/formbody'));\n        this.instance.register(fastifyCors);\n        this.instance.register(fastifyHelmet, { contentSecurityPolicy: false });\n\n        this.instance.register(fastifySecureSession, {\n            secret: Config.get<string>('sessionSecret') || '',\n            cookieName:\n                Config.get<string>('sessionCookieName') || 'cmmv-session',\n        });\n\n        this.setMiddleware();\n        this.registerControllers();\n        this.initHttpServer(settings);\n    }\n\n    public async initHttpServer(options: any) {\n        await this.instance.listen(\n            options.port || 3000,\n            options.host || '0.0.0.0',\n        );\n    }\n\n    private async setMiddleware() {\n        const renderEngine = Config.get<string>('server.render', 'cmmv');\n        let render = null;\n\n        if (renderEngine === '@cmmv/view' || renderEngine === 'cmmv') {\n            const { CMMVRenderer } = await import('@cmmv/view');\n            render = new CMMVRenderer();\n        }\n\n        this.instance.addHook(\n            'onRequest',\n            async (request: FastifyRequestCustom, reply: FastifyReply) => {\n                request.requestId = uuidv4();\n                Telemetry.start('Request Process', request.requestId);\n\n                const nonce = uuidv4().substring(0, 8);\n                request.nonce = nonce;\n\n                const customHeaders = Config.get('headers') || {};\n\n                for (const headerName in customHeaders) {\n                    let headerValue = customHeaders[headerName];\n\n                    if (Array.isArray(headerValue)) {\n                        headerValue = headerValue\n                            .map(value => {\n                                if (headerName === 'Content-Security-Policy')\n                                    return `${value} 'nonce-${nonce}'`;\n\n                                return value;\n                            })\n                            .join('; ');\n                    } else if (typeof headerValue === 'string') {\n                        if (headerName === 'Content-Security-Policy')\n                            headerValue = `${headerValue} 'nonce-${nonce}'`;\n                    }\n\n                    reply.header(headerName, headerValue);\n                }\n\n                if (request.method === 'GET') {\n                    reply.header(\n                        'Strict-Transport-Security',\n                        'max-age=15552000; includeSubDomains',\n                    );\n                    reply.header('X-Content-Type-Options', 'nosniff');\n                    reply.header('X-Frame-Options', 'SAMEORIGIN');\n                    reply.header('X-XSS-Protection', '0');\n                }\n\n                if (['POST', 'PUT', 'DELETE'].includes(request.method)) {\n                    reply.removeHeader('X-DNS-Prefetch-Control');\n                    reply.removeHeader('X-Download-Options');\n                    reply.removeHeader('X-Permitted-Cross-Domain-Policies');\n                    reply.removeHeader('Strict-Transport-Security');\n                    reply.removeHeader('Content-Security-Policy');\n                    reply.removeHeader('Cross-Origin-Opener-Policy');\n                    reply.removeHeader('Cross-Origin-Resource-Policy');\n                    reply.removeHeader('Origin-Agent-Cluster');\n                    reply.removeHeader('Referrer-Policy');\n                }\n            },\n        );\n\n        this.instance.get(\n            '*',\n            async (request: FastifyRequestCustom, reply: FastifyReply) => {\n                const publicDir = path.join(process.cwd(), 'public/views');\n                const requestPath =\n                    request.url === '/' ? 'index' : request.url.substring(1);\n                const ext = path.extname(request.url);\n\n                if ((ext || ext !== '.html') && requestPath !== 'index')\n                    return reply.callNotFound();\n\n                const possiblePaths = [\n                    path.join(publicDir, `${requestPath}.html`),\n                    path.join(publicDir, requestPath, 'index.html'),\n                ];\n\n                for (const filePath of possiblePaths) {\n                    if (fs.existsSync(filePath) && render) {\n                        return reply.type('text/html').send(\n                            await render.renderFile(\n                                filePath,\n                                {\n                                    nonce: request.nonce,\n                                },\n                                {},\n                                () => {},\n                            ),\n                        );\n                    }\n                }\n\n                reply.status(404).send('Page not found');\n            },\n        );\n    }\n\n    private registerControllers() {\n        const controllers = ControllerRegistry.getControllers();\n\n        controllers.forEach(([controllerClass, metadata]) => {\n            const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\n            const instances = paramTypes.map((paramType: any) =>\n                this.application.providersMap.get(paramType.name),\n            );\n\n            const instance = new controllerClass(...instances);\n            const prefix = metadata.prefix;\n            const routes = metadata.routes;\n\n            routes.forEach(route => {\n                const fullPath = `/${prefix}${route.path ? '/' + route.path : ''}`;\n                const method = route.method.toLowerCase();\n\n                if (this.instance[method]) {\n                    this.instance[method](\n                        fullPath,\n                        async (\n                            req: FastifyRequestCustom,\n                            reply: FastifyReply,\n                        ) => {\n                            const startTime = Date.now();\n\n                            try {\n                                const args = this.buildRouteArgs(\n                                    req,\n                                    reply,\n                                    route.params,\n                                );\n                                const result = await instance[\n                                    route.handlerName\n                                ](...args);\n\n                                const processingTime = Date.now() - startTime;\n\n                                reply.send({\n                                    status: 'success',\n                                    processingTime,\n                                    data: result,\n                                });\n                            } catch (error) {\n                                console.error(error);\n                                const processingTime = Date.now() - startTime;\n\n                                reply.status(500).send({\n                                    status: 'error',\n                                    processingTime,\n                                    message:\n                                        error.message ||\n                                        'Internal Server Error',\n                                });\n                            }\n                        },\n                    );\n                }\n            });\n        });\n    }\n\n    private buildRouteArgs(\n        req: FastifyRequest,\n        reply: FastifyReply,\n        params: any[],\n    ) {\n        const args: any[] = [];\n        params?.forEach(param => {\n            const [paramType, paramName] = param.paramType.split(':');\n            switch (paramType) {\n                case 'body':\n                    args[param.index] = req.body;\n                    break;\n                case 'param':\n                    args[param.index] = req.params[paramName];\n                    break;\n                case 'query':\n                    args[param.index] = req.query[paramName];\n                    break;\n                case 'queries':\n                    args[param.index] = req.query;\n                    break;\n                case 'header':\n                    args[param.index] = req.headers[paramName.toLowerCase()];\n                    break;\n                case 'headers':\n                    args[param.index] = req.headers;\n                    break;\n                case 'request':\n                    args[param.index] = req;\n                    break;\n                case 'response':\n                    args[param.index] = reply;\n                    break;\n                case 'next':\n                    args[param.index] = null;\n                    break;\n                case 'session':\n                    args[param.index] = req.session;\n                    break;\n                case 'ip':\n                    args[param.index] = req.ip;\n                    break;\n                case 'hosts':\n                    args[param.index] = req.hostname || req.headers['host'];\n                    break;\n                default:\n                    args[param.index] = undefined;\n                    break;\n            }\n        });\n        return args;\n    }\n\n    public listen(bind: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const [host, port] = bind.split(':');\n\n            this.instance.listen(parseInt(port, 10), host, (err?: any) => {\n                if (err) return reject(err);\n\n                resolve();\n            });\n        });\n    }\n\n    public connected() {\n        return this.instance.server && this.instance.server.listening;\n    }\n\n    public close() {\n        if (!this.httpServer) return undefined;\n\n        return this.httpServer.close();\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "renderEngine",
    "snippet": "const renderEngine = Config.get<string>('server.render', 'cmmv');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "nonce",
    "snippet": "const nonce = uuidv4().substring(0, 8);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "customHeaders",
    "snippet": "const customHeaders = Config.get('headers') || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "headerName",
    "snippet": "const headerName"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "publicDir",
    "snippet": "const publicDir = path.join(process.cwd(), 'public/views');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "requestPath",
    "snippet": "const requestPath =\n                    request.url === '/' ? 'index' : request.url.substring(1);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "ext",
    "snippet": "const ext = path.extname(request.url);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "possiblePaths",
    "snippet": "const possiblePaths = [\n                    path.join(publicDir, `${requestPath}.html`),\n                    path.join(publicDir, requestPath, 'index.html'),\n                ];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "filePath",
    "snippet": "const filePath"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "controllers",
    "snippet": "const controllers = ControllerRegistry.getControllers();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\n                this.application.providersMap.get(paramType.name),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = metadata.prefix;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "routes",
    "snippet": "const routes = metadata.routes;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "fullPath",
    "snippet": "const fullPath = `/${prefix}${route.path ? '/' + route.path : ''}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method = route.method.toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "startTime",
    "snippet": "const startTime = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "args",
    "snippet": "const args = this.buildRouteArgs(\n                                    req,\n                                    reply,\n                                    route.params,\n                                );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance[\n                                    route.handlerName\n                                ](...args);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "processingTime",
    "snippet": "const processingTime = Date.now() - startTime;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "processingTime",
    "snippet": "const processingTime = Date.now() - startTime;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.adapter.ts",
    "type": "Constant",
    "value": "args",
    "snippet": "const args: any[] = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.module.ts",
    "type": "Constant",
    "value": "FastifyModule",
    "snippet": "const FastifyModule = new Module('fastify', {\n    transpilers: [FastifyTranspiler],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Class",
    "value": "FastifyTranspiler",
    "snippet": "class FastifyTranspiler implements ITranspile {\n    private logger: Logger = new Logger('FastifyTranspiler');\n\n    run(): void {\n        const contracts = Scope.getArray<any>('__contracts');\n        const controllers = [];\n        const providers = [];\n\n        contracts?.forEach((contract: any) => {\n            if (contract.generateController) {\n                this.generateService(contract);\n                this.generateController(contract);\n                controllers.push(`${contract.controllerName}Controller`);\n                providers.push(`${contract.controllerName}Service`);\n            }\n        });\n\n        this.generateModule(controllers, providers);\n    }\n\n    private generateService(contract: any): void {\n        const outputPath = path.resolve(contract.protoPath);\n        const outputDir = path.dirname(outputPath);\n        const serviceName = `${contract.controllerName}Service`;\n        const modelName = `${contract.controllerName}`;\n        const modelInterfaceName = `I${modelName}`;\n        const serviceFileName = `${contract.controllerName.toLowerCase()}.service.ts`;\n\n        const serviceTemplate = `// Generated automatically by CMMV\n\nimport { validate } from 'class-validator';\nimport { instanceToPlain, plainToClass } from 'class-transformer';\nimport { AbstractService, Service } from '@cmmv/core';\nimport { ${modelName}, ${modelInterfaceName} } from '../models/${modelName.toLowerCase()}.model';\n\n@Service(\"${contract.controllerName.toLowerCase()}\")\nexport class ${serviceName} extends AbstractService {\n    public override name = \"${contract.controllerName.toLowerCase()}\";\n    private items: ${modelName}[] = [];\n\n    async getAll(queries?: any, req?: any): Promise<${modelName}[]> {\n        return this.items;\n    }\n\n    async getById(id: string, req?: any): Promise<${modelName}> {\n        const item = this.items.find(i => i.id === id);\n\n        if (item) \n            return item;\n        \n        throw new Error('Item not found');\n    }\n\n    async add(item: ${modelInterfaceName}, req?: any): Promise<${modelName}> {\n        return new Promise((resolve, reject) => {\n            item['id'] = this.items.length + 1;\n\n            const newItem = plainToClass(${modelName}, item, { \n                excludeExtraneousValues: true \n            });\n\n            validate(newItem, { skipMissingProperties: true }).then(err => {\n                if(!err){\n                    this.items.push(newItem);\n                    resolve(newItem);\n                }\n                else{\n                    reject(err);\n                }\n            });            \n        });\n    }\n\n    async update(id: string, item: ${modelInterfaceName}, req?: any): Promise<${modelName}> {\n        return new Promise((resolve, reject) => {\n            const index = this.items.findIndex(i => i.id === parseInt(id));\n\n            if (index !== -1){\n                let itemRaw = instanceToPlain(this.items[index]);\n                let updateItem = { ...itemRaw, ...item };\n\n                const editedItem = plainToClass(${modelName}, updateItem, { \n                    excludeExtraneousValues: true \n                });\n                \n                validate(editedItem, { skipMissingProperties: true }).then(err => {\n                    if(!err){\n                        this.items[index] = editedItem;\n                        resolve(editedItem);\n                    } \n                    else reject(err);\n                }); \n            }\n            else{\n                reject('Item not found');\n            }                        \n        });\n    }\n\n    async delete(id: string, req?: any): Promise<{ success: boolean, affected: number }> {\n        const index = this.items.findIndex(i => i.id === parseInt(id));\n\n        if (index !== -1) {\n            this.items.splice(index, 1);\n            return { success: true, affected: 1 };\n        }\n                    \n        throw new Error('Item not found');\n    }\n}`;\n\n        const dirname = path.resolve(outputDir, '../services');\n\n        if (!fs.existsSync(dirname)) fs.mkdirSync(dirname, { recursive: true });\n\n        const outputFilePath = path.join(\n            outputDir,\n            '../services',\n            serviceFileName,\n        );\n\n        fs.writeFileSync(outputFilePath, serviceTemplate, 'utf8');\n    }\n\n    private generateController(contract: any): void {\n        const outputPath = path.resolve(contract.protoPath);\n        const outputDir = path.dirname(outputPath);\n        const controllerName = `${contract.controllerName}Controller`;\n        const serviceName = `${contract.controllerName}Service`;\n        const controllerFileName = `${contract.controllerName.toLowerCase()}.controller.ts`;\n\n        const hasCache =\n            contract.cache !== undefined && contract.cache !== null;\n        const cacheKeyPrefix = hasCache\n            ? contract.cache.key || `${contract.controllerName.toLowerCase()}:`\n            : '';\n        const cacheTtl = hasCache ? contract.cache.ttl || 300 : 0;\n        const cacheCompress =\n            hasCache && contract.cache.compress ? 'true' : 'false';\n\n        const controllerTemplate = `// Generated automatically by CMMV\n\nimport { Telemetry } from \"@cmmv/core\";\n${hasCache ? `import { Cache, CacheService } from \"@cmmv/cache\";` : ''}\nimport { \n    Controller, Get, Post, Put, Delete, \n    Queries, Param, Body, Request \n} from '@cmmv/http';\n\nimport { ${serviceName} } from '../services/${contract.controllerName.toLowerCase()}.service';\nimport { ${contract.controllerName}, ${contract.controllerName}FastSchema } from '../models/${contract.controllerName.toLowerCase()}.model';\n\n@Controller('${contract.controllerName.toLowerCase()}')\nexport class ${controllerName} {\n    constructor(private readonly ${serviceName.toLowerCase()}: ${serviceName}) {}\n\n    @Get()${hasCache ? `\\n    @Cache(\"${cacheKeyPrefix}getAll\", { ttl: ${cacheTtl}, compress: ${cacheCompress}, schema: ${contract.controllerName}FastSchema })` : ''}\n    async getAll(@Queries() queries: any, @Request() req) {\n        Telemetry.start('${controllerName}::GetAll', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.getAll(queries, req);\n        Telemetry.end('${controllerName}::GetAll', req.requestId);\n        return result;\n    }\n\n    @Get(':id')${hasCache ? `\\n    @Cache(\"${cacheKeyPrefix}{id}\", { ttl: ${cacheTtl}, compress: ${cacheCompress}, schema: ${contract.controllerName}FastSchema })` : ''}\n    async getById(@Param('id') id: string, @Request() req) {\n        Telemetry.start('${controllerName}::GetById', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.getById(id, req);\n        Telemetry.end('${controllerName}::GetById', req.requestId);\n        return result;\n    }\n\n    @Post()\n    async add(@Body() item: ${contract.controllerName}, @Request() req) {\n        Telemetry.start('${controllerName}::Add', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.add(item, req);\n        ${hasCache ? `CacheService.set(\\`${cacheKeyPrefix}\\${${Config.get('repository.type') === 'mongodb' ? `result._id` : `result.id`}}\\`, ${contract.controllerName}FastSchema(result), ${cacheTtl});` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Add', req.requestId);\n        return result;\n    }\n\n    @Put(':id')\n    async update(@Param('id') id: string, @Body() item: ${contract.controllerName}, @Request() req) {\n        Telemetry.start('${controllerName}::Update', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.update(id, item, req);\n        ${hasCache ? `CacheService.set(\\`${cacheKeyPrefix}\\${${Config.get('repository.type') === 'mongodb' ? `result._id` : `result.id`}}\\`, ${contract.controllerName}FastSchema(result), ${cacheTtl});` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Update', req.requestId);\n        return result;\n    }\n\n    @Delete(':id')\n    async delete(@Param('id') id: string, @Request() req): Promise<{ success: boolean, affected: number }> {\n        Telemetry.start('${controllerName}::Delete', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.delete(id, req);\n        ${hasCache ? `CacheService.del(\\`${cacheKeyPrefix}\\${id}\\`);` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Delete', req.requestId);\n        return result;\n    }\n}\n`;\n        const dirname = path.resolve(outputDir, '../controllers');\n\n        if (!fs.existsSync(dirname)) fs.mkdirSync(dirname, { recursive: true });\n\n        const outputFilePath = path.join(\n            outputDir,\n            '../controllers',\n            controllerFileName,\n        );\n        fs.writeFileSync(outputFilePath, controllerTemplate, 'utf8');\n    }\n\n    private generateModule(controllers: string[], providers: string[]): void {\n        Application.appModule.controllers = [\n            ...Application.appModule.controllers,\n            ...controllers.map(name => {\n                return {\n                    name,\n                    path: `./controllers/${name.replace('Controller', '').toLowerCase()}.controller`,\n                };\n            }),\n        ];\n\n        Application.appModule.providers = [\n            ...Application.appModule.providers,\n            ...providers.map(name => {\n                return {\n                    name,\n                    path: `./services/${name.replace('Service', '').toLowerCase()}.service`,\n                };\n            }),\n        ];\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "contracts",
    "snippet": "const contracts = Scope.getArray<any>('__contracts');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "controllers",
    "snippet": "const controllers = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "providers",
    "snippet": "const providers = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputPath",
    "snippet": "const outputPath = path.resolve(contract.protoPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputDir",
    "snippet": "const outputDir = path.dirname(outputPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "serviceName",
    "snippet": "const serviceName = `${contract.controllerName}Service`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "modelName",
    "snippet": "const modelName = `${contract.controllerName}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "modelInterfaceName",
    "snippet": "const modelInterfaceName = `I${modelName}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "serviceFileName",
    "snippet": "const serviceFileName = `${contract.controllerName.toLowerCase()}.service.ts`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "serviceTemplate",
    "snippet": "const serviceTemplate = `// Generated automatically by CMMV\n\nimport { validate } from 'class-validator';\nimport { instanceToPlain, plainToClass } from 'class-transformer';\nimport { AbstractService, Service } from '@cmmv/core';\nimport { ${modelName}, ${modelInterfaceName} } from '../models/${modelName.toLowerCase()}.model';\n\n@Service(\"${contract.controllerName.toLowerCase()}\")\nexport class ${serviceName} extends AbstractService {\n    public override name = \"${contract.controllerName.toLowerCase()}\";\n    private items: ${modelName}[] = [];\n\n    async getAll(queries?: any, req?: any): Promise<${modelName}[]> {\n        return this.items;\n    }\n\n    async getById(id: string, req?: any): Promise<${modelName}> {\n        const item = this.items.find(i => i.id === id);\n\n        if (item) \n            return item;\n        \n        throw new Error('Item not found');\n    }\n\n    async add(item: ${modelInterfaceName}, req?: any): Promise<${modelName}> {\n        return new Promise((resolve, reject) => {\n            item['id'] = this.items.length + 1;\n\n            const newItem = plainToClass(${modelName}, item, { \n                excludeExtraneousValues: true \n            });\n\n            validate(newItem, { skipMissingProperties: true }).then(err => {\n                if(!err){\n                    this.items.push(newItem);\n                    resolve(newItem);\n                }\n                else{\n                    reject(err);\n                }\n            });            \n        });\n    }\n\n    async update(id: string, item: ${modelInterfaceName}, req?: any): Promise<${modelName}> {\n        return new Promise((resolve, reject) => {\n            const index = this.items.findIndex(i => i.id === parseInt(id));\n\n            if (index !== -1){\n                let itemRaw = instanceToPlain(this.items[index]);\n                let updateItem = { ...itemRaw, ...item };\n\n                const editedItem = plainToClass(${modelName}, updateItem, { \n                    excludeExtraneousValues: true \n                });\n                \n                validate(editedItem, { skipMissingProperties: true }).then(err => {\n                    if(!err){\n                        this.items[index] = editedItem;\n                        resolve(editedItem);\n                    } \n                    else reject(err);\n                }); \n            }\n            else{\n                reject('Item not found');\n            }                        \n        });\n    }\n\n    async delete(id: string, req?: any): Promise<{ success: boolean, affected: number }> {\n        const index = this.items.findIndex(i => i.id === parseInt(id));\n\n        if (index !== -1) {\n            this.items.splice(index, 1);\n            return { success: true, affected: 1 };\n        }\n                    \n        throw new Error('Item not found');\n    }\n}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "dirname",
    "snippet": "const dirname = path.resolve(outputDir, '../services');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputFilePath",
    "snippet": "const outputFilePath = path.join(\n            outputDir,\n            '../services',\n            serviceFileName,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputPath",
    "snippet": "const outputPath = path.resolve(contract.protoPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputDir",
    "snippet": "const outputDir = path.dirname(outputPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "controllerName",
    "snippet": "const controllerName = `${contract.controllerName}Controller`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "serviceName",
    "snippet": "const serviceName = `${contract.controllerName}Service`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "controllerFileName",
    "snippet": "const controllerFileName = `${contract.controllerName.toLowerCase()}.controller.ts`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "hasCache",
    "snippet": "const hasCache =\n            contract.cache !== undefined && contract.cache !== null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "cacheKeyPrefix",
    "snippet": "const cacheKeyPrefix = hasCache\n            ? contract.cache.key || `${contract.controllerName.toLowerCase()}:`\n            : '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "cacheTtl",
    "snippet": "const cacheTtl = hasCache ? contract.cache.ttl || 300 : 0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "cacheCompress",
    "snippet": "const cacheCompress =\n            hasCache && contract.cache.compress ? 'true' : 'false';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "controllerTemplate",
    "snippet": "const controllerTemplate = `// Generated automatically by CMMV\n\nimport { Telemetry } from \"@cmmv/core\";\n${hasCache ? `import { Cache, CacheService } from \"@cmmv/cache\";` : ''}\nimport { \n    Controller, Get, Post, Put, Delete, \n    Queries, Param, Body, Request \n} from '@cmmv/http';\n\nimport { ${serviceName} } from '../services/${contract.controllerName.toLowerCase()}.service';\nimport { ${contract.controllerName}, ${contract.controllerName}FastSchema } from '../models/${contract.controllerName.toLowerCase()}.model';\n\n@Controller('${contract.controllerName.toLowerCase()}')\nexport class ${controllerName} {\n    constructor(private readonly ${serviceName.toLowerCase()}: ${serviceName}) {}\n\n    @Get()${hasCache ? `\\n    @Cache(\"${cacheKeyPrefix}getAll\", { ttl: ${cacheTtl}, compress: ${cacheCompress}, schema: ${contract.controllerName}FastSchema })` : ''}\n    async getAll(@Queries() queries: any, @Request() req) {\n        Telemetry.start('${controllerName}::GetAll', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.getAll(queries, req);\n        Telemetry.end('${controllerName}::GetAll', req.requestId);\n        return result;\n    }\n\n    @Get(':id')${hasCache ? `\\n    @Cache(\"${cacheKeyPrefix}{id}\", { ttl: ${cacheTtl}, compress: ${cacheCompress}, schema: ${contract.controllerName}FastSchema })` : ''}\n    async getById(@Param('id') id: string, @Request() req) {\n        Telemetry.start('${controllerName}::GetById', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.getById(id, req);\n        Telemetry.end('${controllerName}::GetById', req.requestId);\n        return result;\n    }\n\n    @Post()\n    async add(@Body() item: ${contract.controllerName}, @Request() req) {\n        Telemetry.start('${controllerName}::Add', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.add(item, req);\n        ${hasCache ? `CacheService.set(\\`${cacheKeyPrefix}\\${${Config.get('repository.type') === 'mongodb' ? `result._id` : `result.id`}}\\`, ${contract.controllerName}FastSchema(result), ${cacheTtl});` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Add', req.requestId);\n        return result;\n    }\n\n    @Put(':id')\n    async update(@Param('id') id: string, @Body() item: ${contract.controllerName}, @Request() req) {\n        Telemetry.start('${controllerName}::Update', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.update(id, item, req);\n        ${hasCache ? `CacheService.set(\\`${cacheKeyPrefix}\\${${Config.get('repository.type') === 'mongodb' ? `result._id` : `result.id`}}\\`, ${contract.controllerName}FastSchema(result), ${cacheTtl});` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Update', req.requestId);\n        return result;\n    }\n\n    @Delete(':id')\n    async delete(@Param('id') id: string, @Request() req): Promise<{ success: boolean, affected: number }> {\n        Telemetry.start('${controllerName}::Delete', req.requestId);\n        let result = await this.${serviceName.toLowerCase()}.delete(id, req);\n        ${hasCache ? `CacheService.del(\\`${cacheKeyPrefix}\\${id}\\`);` : ''}\n        ${hasCache ? `CacheService.del(\"${cacheKeyPrefix}getAll\");` : ''}\n        Telemetry.end('${controllerName}::Delete', req.requestId);\n        return result;\n    }\n}\n`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "dirname",
    "snippet": "const dirname = path.resolve(outputDir, '../controllers');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-fastify/src/fastify.transpiler.ts",
    "type": "Constant",
    "value": "outputFilePath",
    "snippet": "const outputFilePath = path.join(\n            outputDir,\n            '../controllers',\n            controllerFileName,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.module.ts",
    "type": "Constant",
    "value": "RepositoryModule",
    "snippet": "const RepositoryModule = new Module('inspector', {\n    providers: [Inspector],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Class",
    "value": "Inspector",
    "snippet": "class Inspector extends Singleton {\n    public static logger: Logger = new Logger('Inspector');\n    public started: boolean = false;\n    public session: Session;\n    public profile: Profiler.Profile;\n    private static finalizationCallbacks: Array<() => Promise<void>> = [];\n\n    public static async start() {\n        const instance = Inspector.getInstance();\n        instance.started = true;\n        instance.session = new Session();\n        instance.session.connect();\n        await instance.session.post('Profiler.enable');\n        await instance.session.post('Profiler.start');\n    }\n\n    public static async pause() {\n        const instance = Inspector.getInstance();\n        await instance.session.post('Debugger.pause');\n    }\n\n    public static async stop() {\n        const instance = Inspector.getInstance();\n\n        if (instance.started && instance.session) {\n            instance.started = false;\n            try {\n                const result = await instance.session.post('Profiler.stop');\n\n                if (!result || !result.profile)\n                    throw new Error('Profiler.stop did not return a profile');\n\n                instance.profile = result.profile;\n                instance.session.disconnect();\n            } catch (e) {\n                Inspector.logger.error(e);\n            }\n        }\n    }\n\n    public static bindKillProcess() {\n        ['uncaughtException', 'beforeExit', 'SIGINT', 'SIGTERM'].forEach(\n            event => {\n                process.once(event, async () => {\n                    for (const callback of this.finalizationCallbacks) {\n                        try {\n                            await callback();\n                        } catch (e) {\n                            Inspector.logger.error(\n                                `Error during finalization callback: ${e}`,\n                            );\n                        }\n                    }\n\n                    await Inspector.stop();\n\n                    if (process.env.NODE_ENV !== 'test') process.exit(0);\n                });\n            },\n        );\n    }\n\n    public static once(finalizationCallback: () => Promise<void>) {\n        this.finalizationCallbacks.push(finalizationCallback);\n    }\n\n    public static async saveProfile(dirName: string, restart: boolean = true) {\n        const instance = Inspector.getInstance();\n\n        if (!fs.existsSync(dirName)) {\n            fs.mkdirSync(dirName, { recursive: true });\n        }\n\n        if (!instance.profile) {\n            await Inspector.stop();\n        }\n\n        fs.writeFileSync(\n            join(dirName, `cpu-profile-${new Date().toISOString()}.cpuprofile`),\n            JSON.stringify(instance.profile),\n        );\n\n        if (restart) {\n            Inspector.start();\n        }\n    }\n\n    public static async takeHeapSnapshot(dirName: string) {\n        const instance = Inspector.getInstance();\n\n        if (!fs.existsSync(dirName)) {\n            fs.mkdirSync(dirName, { recursive: true });\n        }\n\n        const filePath = join(\n            dirName,\n            `heap-${new Date().toISOString()}.heapsnapshot`,\n        );\n        const fileStream = fs.createWriteStream(filePath);\n\n        instance.session = new Session();\n        instance.session.connect();\n\n        try {\n            await instance.session.post('HeapProfiler.enable');\n            const result = await instance.session.post(\n                'HeapProfiler.takeHeapSnapshot',\n                null,\n            );\n            Inspector.logger.log(\n                `HeapProfiler.takeHeapSnapshot done: ${result}`,\n            );\n\n            await new Promise((resolve, reject) => {\n                instance.session.on('HeapProfiler.addHeapSnapshotChunk', m => {\n                    fileStream.write(m.params.chunk);\n                });\n\n                instance.session.once(\n                    'HeapProfiler.heapSnapshotProgress',\n                    ({ done }) => {\n                        if (done) {\n                            fileStream.end();\n                            resolve(undefined);\n                        }\n                    },\n                );\n\n                instance.session.once('error', reject);\n            });\n\n            Inspector.logger.log(`Heap snapshot saved to ${filePath}`);\n        } catch (e) {\n            Inspector.logger.error(`Error while taking heap snapshot: ${e}`);\n        } finally {\n            instance.session.disconnect();\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = Inspector.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = Inspector.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = Inspector.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance.session.post('Profiler.stop');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "callback",
    "snippet": "const callback"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = Inspector.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = Inspector.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "filePath",
    "snippet": "const filePath = join(\n            dirName,\n            `heap-${new Date().toISOString()}.heapsnapshot`,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "fileStream",
    "snippet": "const fileStream = fs.createWriteStream(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-inspector/src/inspector.service.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = await instance.session.post(\n                'HeapProfiler.takeHeapSnapshot',\n                null,\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Function",
    "value": "_",
    "snippet": "async function _(this: any, fn?, hook = \"onRequest\") {\r\n    return (req, res, next) => {\r\n        if (req.app && typeof req.app.addHook === 'function') {\r\n            req.app.addHook(hook, processMiddleware.bind({ fn }));\r\n        } else {\r\n            next();\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Function",
    "value": "processMiddleware",
    "snippet": "async function processMiddleware(this: any, req, res, payload, done) {\r\n    let handle = this.fn;\r\n    const request = createMockRequest(req);\r\n    const response = createMockResponse(res);\r\n\r\n    handle(request, response, (...args) => {\r\n        req.app.addHook(\"onSend\", (req, res, payload, next) => {\r\n            try{\r\n                response.body = payload;\r\n                \r\n                if (response._header || response.headersSent) \r\n                    return; \r\n                \r\n                if (response && typeof response.writeHead === 'function')\r\n                    response.writeHead.call(response, res.statusCode)\r\n                            \r\n                if(typeof next === \"function\")\r\n                    next.call(this, null, payload);\r\n\r\n                return payload;\r\n            }\r\n            catch(err){\r\n                if(typeof next === \"function\")\r\n                    next.call(this, null, payload);\r\n\r\n                return payload;\r\n            }\r\n        });\r\n\r\n        if(typeof next === \"function\")\r\n            next.bind(this);\r\n\r\n        return payload;\r\n    });\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Constant",
    "value": "request",
    "snippet": "const request = createMockRequest(req);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = createMockResponse(res);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Function",
    "value": "createMockRequest",
    "snippet": "function createMockRequest(req) {\r\n    const request = Object.create(IncomingMessage.prototype);\r\n    merge(request, EventEmitter);\r\n\r\n    Object.keys(req).forEach((key) => {\r\n        request[key] = req[key];\r\n    });\r\n\r\n    [\r\n        \"on\", \"emit\", \"pipe\", \"unpipe\", \"pause\", \"resume\",\r\n        \"query\", \"querystring\", \"search\", \"socket\",\r\n        \"protocol\", \"headers\", \"url\", \"origin\", \"href\",\r\n        \"secure\", \"method\", \"path\", \"host\", \"hostname\",\r\n        \"URL\", \"idempotent\", \"ip\",\r\n        \"ips\", \"length\", \"subdomains\", \"xhr\", \"cookies\",\r\n        \"signedCookies\", \"header\", \"get\", \"accept\",\r\n        \"type\", \"accepts\", \"acceptsEncodings\", \"acceptsCharsets\",\r\n        \"acceptsLanguages\", \"range\", \"is\"\r\n    ].forEach((method) => {\r\n        if (typeof req[method] === 'function') {\r\n            request[method] = req[method].bind(req);\r\n        } else if (req[method] !== undefined) {\r\n            request[method] = req[method];\r\n        }\r\n    });\r\n\r\n    return request;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Constant",
    "value": "request",
    "snippet": "const request = Object.create(IncomingMessage.prototype);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Function",
    "value": "createMockResponse",
    "snippet": "function createMockResponse(res) {\r\n    const response = Object.create(ServerResponse.prototype);\r\n\r\n    Object.keys(res).forEach((key) => {\r\n        response[key] = res[key];\r\n    });\r\n\r\n    [\r\n        \"setHeader\", \"getHeader\", \"removeHeader\", \r\n        \"writeHead\", \"end\", \"write\", \"statusCode\", \r\n        \"on\", \"emit\", \"get\"\r\n    ].forEach((method) => {\r\n        if (typeof res[method] === 'function') {\r\n            response[method] = res[method].bind(res);\r\n        } else if (res[method] !== undefined) {\r\n            response[method] = res[method];\r\n        }\r\n    });\r\n\r\n    response.status = (statusCode: number) => {\r\n        //return response.statusCode = statusCode;\r\n    }\r\n\r\n    response.setHeader = response.setHeader || ((name, value) => {\r\n        if (!response.headers) {\r\n            response.headers = {};\r\n        }\r\n        response.headers[name.toLowerCase()] = value;\r\n    });\r\n\r\n    response.getHeader = response.getHeader || ((name) => {\r\n        return response.headers ? response.headers[name.toLowerCase()] : undefined;\r\n    });\r\n\r\n    response.removeHeader = response.removeHeader || ((name) => {\r\n        if (response.headers) {\r\n            delete response.headers[name.toLowerCase()];\r\n        }\r\n    });\r\n\r\n    response.writeHead = response.writeHead || ((statusCode, statusMessage, headers) => {\r\n        response.statusCode = statusCode;\r\n        if (typeof statusMessage === 'string') {\r\n            response.statusMessage = statusMessage;\r\n            if (headers) {\r\n                Object.assign(response.headers, headers);\r\n            }\r\n        } else {\r\n            Object.assign(response.headers, statusMessage);\r\n        }\r\n    });\r\n\r\n    return response;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/index.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = Object.create(ServerResponse.prototype);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-middleware/src/sample.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = cmmv();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "Router",
    "snippet": "const Router: typeof import('find-my-way') =\n  process.env.NODE_ENV === 'test' ? FindMyWay : require('find-my-way');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Interface",
    "value": "ApplicationOptions",
    "snippet": "interface ApplicationOptions {\n  debug?: boolean;\n  etag?: boolean;\n  lastModified?: boolean;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Class",
    "value": "HttpMini",
    "snippet": "class HttpMini extends EventEmitter {\n  private readonly logger = new Logger('HTTP');\n  private options?: ApplicationOptions;\n  private server: ServerType;\n\n  private readonly router = Router({\n    caseSensitive: false,\n    ignoreTrailingSlash: true,\n    ignoreDuplicateSlashes: true,\n    allowUnsafeRegex: true,\n  });\n\n  constructor(\n    applicationOptions?: ApplicationOptions,\n    serverOptions?: ServerOptions,\n  ) {\n    super();\n\n    this.options = {\n      debug: applicationOptions?.debug === true || false,\n      etag: applicationOptions?.etag === true || false,\n      lastModified: applicationOptions?.etag === true || true,\n    };\n\n    this.createServer(serverOptions);\n    Pooling.init();\n  }\n\n  public option(name: string): any {\n    return this.options[name];\n  }\n\n  public createServer(options?: ServerOptions) {\n    if (options && 'allowHTTP1' in options) {\n      this.server =\n        options && 'key' in options\n          ? http2.createSecureServer(options, this.handler.bind(this))\n          : http2.createServer(options, this.handler.bind(this));\n    } else {\n      this.server =\n        options && 'key' in options\n          ? https.createServer(\n              options as http.ServerOptions,\n              this.handler.bind(this),\n            )\n          : http.createServer(\n              options as http.ServerOptions,\n              this.handler.bind(this),\n            );\n    }\n  }\n\n  public async handler(req: ServerRequest, res: ServerResponse) {\n    const httpMethod = req.method?.toUpperCase() as FindMyWay.HTTPMethod;\n    const route = this.router.find(httpMethod, req.url);\n    const startRequest = Date.now();\n\n    if (route && route.handler) {\n      const { request, response, index } = Pooling.acquire(\n        this,\n        req,\n        res,\n        route.params,\n        route.searchParams,\n      );\n\n      try {\n        const content = await route.handler.call(this, request, response);\n\n        if (!response.sent) response.send(content);\n\n        const endRequest = Date.now();\n        Pooling.release(index);\n\n        this.printLog(\n          'verbose',\n          httpMethod,\n          req.url,\n          endRequest - startRequest,\n          response.statusCode,\n        );\n      } catch (error) {\n        const endRequest = Date.now();\n        Pooling.release(index);\n\n        this.printLog(\n          'error',\n          httpMethod,\n          req.url,\n          endRequest - startRequest,\n          500,\n        );\n\n        res.writeHead(500, { 'Content-Type': 'text/html' });\n        res.end('Internal Server Error');\n      }\n    } else {\n      const endRequest = Date.now();\n\n      this.printLog(\n        'verbose',\n        httpMethod,\n        req.url,\n        endRequest - startRequest,\n        404,\n      );\n\n      res.writeHead(404, { 'Content-Type': 'text/html' });\n      res.end('Not Found');\n    }\n  }\n\n  public get(path: string, handler: RouteHandler): void {\n    this.router.on('GET', path, (req, res) => handler.call(this, req, res));\n  }\n\n  public post(path: string, handler: RouteHandler): void {\n    this.router.on('POST', path, (req, res) => handler.call(this, req, res));\n  }\n\n  public listen(address: { host: string; port: number }) {\n    return new Promise((resolve, reject) => {\n      this.server.once('error', reject);\n      this.server.listen(address.port, address.host, () => {\n        this.server.off('error', reject);\n        resolve(address);\n      });\n    });\n  }\n\n  public close() {\n    this.server.close();\n  }\n\n  public printLog(\n    type: string,\n    method: string,\n    path: string,\n    timer: number,\n    status: number,\n  ) {\n    if (this.option('debug')) {\n      const logContent = `${method.toUpperCase()} ${path} (${timer}ms) ${status}`;\n\n      switch (type) {\n        case 'error':\n          this.logger.error(logContent);\n          break;\n        case 'warning':\n          this.logger.warning(logContent);\n          break;\n        case 'verbose':\n          this.logger.verbose(logContent);\n          break;\n        default:\n          this.logger.log(logContent);\n          break;\n      }\n    }\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "httpMethod",
    "snippet": "const httpMethod = req.method?.toUpperCase() as FindMyWay.HTTPMethod;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "route",
    "snippet": "const route = this.router.find(httpMethod, req.url);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "startRequest",
    "snippet": "const startRequest = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "content",
    "snippet": "const content = await route.handler.call(this, request, response);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "endRequest",
    "snippet": "const endRequest = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "endRequest",
    "snippet": "const endRequest = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "endRequest",
    "snippet": "const endRequest = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/application.ts",
    "type": "Constant",
    "value": "logContent",
    "snippet": "const logContent = `${method.toUpperCase()} ${path} (${timer}ms) ${status}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/pooling.ts",
    "type": "Class",
    "value": "Pooling",
    "snippet": "class Pooling {\n  public static size: number;\n  public static index: number;\n  public static stack: Uint8Array;\n  public static requestPool: any[];\n  public static responsePool: any[];\n\n  static init(poolSize: number = 100) {\n    Pooling.size = poolSize;\n    Pooling.index = poolSize;\n    Pooling.stack = new Uint8Array(poolSize);\n    Pooling.requestPool = new Array(poolSize);\n    Pooling.responsePool = new Array(poolSize);\n\n    for (let i = 0; i < poolSize; i++) {\n      Pooling.stack[i] = i;\n      Pooling.requestPool[i] = Request(null, null, {}, {});\n      Pooling.responsePool[i] = Response(null, null, null);\n    }\n  }\n\n  static create(): number {\n    const idx = Pooling.size++;\n\n    Pooling.requestPool[idx] = Request(null, null, {}, {});\n    Pooling.responsePool[idx] = Response(null, null, null);\n\n    return idx;\n  }\n\n  static acquire(\n    context: HttpMini,\n    rawReq: http.IncomingMessage | http2.Http2ServerRequest,\n    rawRes: http.ServerResponse | http2.Http2ServerResponse,\n    params: object,\n    searchParams: object,\n  ) {\n    let idx =\n      Pooling.index > 0 ? Pooling.stack[--Pooling.index] : Pooling.create();\n\n    const request = Pooling.requestPool[idx];\n    const response = Pooling.responsePool[idx];\n\n    request.flush();\n    response.flush();\n\n    request.context = context;\n    request.raw = rawReq;\n    request.params = params;\n    request.searchParams = searchParams;\n\n    response.context = context;\n    response.raw = rawRes;\n    response.sent = false;\n    response.req = request;\n\n    return { request, response, index: idx };\n  }\n\n  static release(index: number) {\n    if (index < 0 || index >= Pooling.size) return;\n    Pooling.stack[Pooling.index++] = index;\n  }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/pooling.ts",
    "type": "Constant",
    "value": "idx",
    "snippet": "const idx = Pooling.size++;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/pooling.ts",
    "type": "Constant",
    "value": "request",
    "snippet": "const request = Pooling.requestPool[idx];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/pooling.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = Pooling.responsePool[idx];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/request.ts",
    "type": "Constant",
    "value": "Request",
    "snippet": "const Request = {\n  context: null,\n  raw: null,\n  params: {},\n  searchParams: {},\n  headersMap: {},\n\n  get method() {\n    return this.raw.method!;\n  },\n\n  flush() {\n    this.context = null;\n    this.raw = null;\n    this.params = {};\n    this.searchParams = {};\n    this.headersMap = {};\n  },\n\n  headers(header: string): string | string[] | undefined {\n    return this.raw.headers[header.toLowerCase()];\n  },\n\n  param(paramName: string): string | undefined {\n    return this.params[paramName];\n  },\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/request.ts",
    "type": "Constant",
    "value": "newRequest",
    "snippet": "const newRequest = Object.create(Request);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "Response",
    "snippet": "const Response = {\n  statusCode: 200,\n  contentType: null,\n  lastModified: null,\n  sent: false,\n  context: null,\n  raw: null,\n  req: null,\n  headers: {},\n\n  flush() {\n    this.statusCode = 200;\n    this.contentType = null;\n    this.lastModified = null;\n    this.sent = false;\n    this.context = null;\n    this.raw = null;\n    this.req = null;\n    this.headers = {};\n  },\n\n  status(code: number) {\n    this.statusCode = code;\n    return this;\n  },\n\n  set(key: string, value: string) {\n    this.headers[key.toLowerCase()] = value;\n  },\n\n  setContentType(value: string) {\n    this.contentType = value;\n    return this;\n  },\n\n  setLastModified(date: Date) {\n    this.lastModified = date.toUTCString();\n    return this;\n  },\n\n  json(objectJson: object) {\n    this.setContentType('application/json');\n    this.send(JSON.stringify(objectJson));\n  },\n\n  fnv1a(str: string): string {\n    let hash = new Uint32Array([2166136261]);\n\n    for (let i = 0; i < str.length; i++) {\n      hash[0] ^= str.charCodeAt(i);\n      hash[0] +=\n        (hash[0] << 1) +\n        (hash[0] << 4) +\n        (hash[0] << 7) +\n        (hash[0] << 8) +\n        (hash[0] << 24);\n    }\n\n    return hash[0].toString(16);\n  },\n\n  etag(content: string): string {\n    return `\"${this.fnv1a(content)}\"`;\n  },\n\n  send(content?: string, status: number = 200) {\n    if (this.sent || this.raw.headersSent) return;\n\n    this.statusCode = status;\n    this.contentType ||= 'text/html';\n    this.end(content);\n    return;\n  },\n\n    end(content?: string) {\n        if (this.sent || this.raw.headersSent) return;\n\n        const raw = this.raw;\n        const req = this.req;\n        const context = this.context;\n\n        const contentSent =\n            content ??\n            (typeof req.body === 'object'\n                ? JSON.stringify(req.body)\n                : req.body || '');\n\n        let computedEtag: string | undefined;\n        const useEtag = context.option('etag');\n        const ifNoneMatch = req.headers('if-none-match');\n\n        if (useEtag || ifNoneMatch) {\n            computedEtag = this.etag(contentSent);\n            if (ifNoneMatch === computedEtag) {\n                raw.writeHead(304).end();\n                this.sent = true;\n                return;\n            }\n        }\n\n        const ifModifiedSince = req.headers('if-modified-since');\n        if (this.lastModified && ifModifiedSince && typeof ifModifiedSince === 'string') {\n            const sinceDate = new Date(ifModifiedSince);\n            if (sinceDate >= new Date(this.lastModified)) {\n                raw.writeHead(304).end();\n                this.sent = true;\n                return;\n            }\n        }\n\n        const headers: Record<string, string | number> = {\n            'content-type': this.contentType || 'text/plain',\n        };\n\n        if (useEtag) headers['etag'] = computedEtag!;\n        if (context.option('lastModified')) headers['last-modified'] = this.lastModified || new Date().toUTCString();\n\n        let contentBuffer: Buffer | string = contentSent;\n        if (typeof contentSent === 'string' && contentSent.length > 0) {\n            contentBuffer = Buffer.from(contentSent);\n            headers['content-length'] = contentBuffer.byteLength;\n        } else if (typeof contentSent === 'string') {\n            contentBuffer = '';\n        }\n\n        raw.cork();\n\n        raw.writeHead(this.statusCode, headers);\n\n        if (req.method.toLowerCase() === 'head') {\n            raw.end();\n        } else {\n            raw.end(contentBuffer);\n        }\n\n        raw.uncork();\n\n        this.sent = true;\n    }\n\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "raw",
    "snippet": "const raw = this.raw;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "req",
    "snippet": "const req = this.req;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "context",
    "snippet": "const context = this.context;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "contentSent",
    "snippet": "const contentSent =\n            content ??\n            (typeof req.body === 'object'\n                ? JSON.stringify(req.body)\n                : req.body || '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "useEtag",
    "snippet": "const useEtag = context.option('etag');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "ifNoneMatch",
    "snippet": "const ifNoneMatch = req.headers('if-none-match');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "ifModifiedSince",
    "snippet": "const ifModifiedSince = req.headers('if-modified-since');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "sinceDate",
    "snippet": "const sinceDate = new Date(ifModifiedSince);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "headers",
    "snippet": "const headers: Record<string, string | number> = {\n            'content-type': this.contentType || 'text/plain',\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/response.ts",
    "type": "Constant",
    "value": "newResponse",
    "snippet": "const newResponse = Object.create(Response);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/src/sample.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = httpmini({\n    debug: false,\n    etag: false,\n    lastModified: false,\n  });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/tests/serverMock.ts",
    "type": "Constant",
    "value": "host",
    "snippet": "const host = \"127.0.0.1\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/tests/serverMock.ts",
    "type": "Constant",
    "value": "port",
    "snippet": "const port = 55995;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-http-mini/tests/serverMock.ts",
    "type": "Constant",
    "value": "serverAddress",
    "snippet": "const serverAddress = `http://${host}:${port}`"
  },
  {
    "filename": "/mnt/f/Node/cmmv-morgan/src/sample.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = cmmv();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/customers.contract.ts",
    "type": "Class",
    "value": "CustomersContract",
    "snippet": "@Contract({\n    controllerName: 'Customers',\n    protoPath: 'src/protos/customers.proto',\n    protoPackage: 'customers',\n    generateController: false,\n})\nexport class CustomersContract extends AbstractContract {\n    @ContractField({ protoType: 'string' })\n    name: string;\n\n    @ContractField({ protoType: 'string' })\n    phone: string;\n\n    @ContractField({ protoType: 'date' })\n    createdAt: Date;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigJson.ts",
    "type": "Interface",
    "value": "Customer",
    "snippet": "interface Customer {\n    id: number;\n    name: string;\n    email: string;\n    phoneNumber: string;\n    address: string;\n    city: string;\n    state: string;\n    zipCode: string;\n    registrationDate: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "generateCustomerData",
    "snippet": "const generateCustomerData = (id: number): Customer => ({\n    id,\n    name: faker.person.fullName(),\n    email: faker.internet.email(),\n    phoneNumber: faker.phone.number({ style: 'national' }),\n    address: faker.location.streetAddress(),\n    city: faker.location.city(),\n    state: faker.location.state(),\n    zipCode: faker.location.zipCode(),\n    registrationDate: faker.date.past().toISOString(),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "generateLargeJSON",
    "snippet": "const generateLargeJSON = async (\n    filePath: string,\n    totalRecords: number,\n): Promise<void> => {\n    const writeStream = fs.createWriteStream(filePath);\n    writeStream.write('[');\n\n    for (let i = 1; i <= totalRecords; i++) {\n        const customer = generateCustomerData(i);\n        writeStream.write(JSON.stringify(customer));\n\n        if (i < totalRecords) writeStream.write(',');\n\n        if (i % 10000 === 0) console.log(`Generated ${i} records...`);\n    }\n\n    writeStream.write(']');\n    writeStream.end();\n\n    console.log(\n        `JSON file with ${totalRecords} records generated at ${filePath}`,\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "writeStream",
    "snippet": "const writeStream = fs.createWriteStream(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "customer",
    "snippet": "const customer = generateCustomerData(i);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigXML.ts",
    "type": "Interface",
    "value": "Customer",
    "snippet": "interface Customer {\n    id: number;\n    name: string;\n    email: string;\n    phoneNumber: string;\n    address: string;\n    city: string;\n    state: string;\n    zipCode: string;\n    registrationDate: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigXML.ts",
    "type": "Constant",
    "value": "generateCustomerData",
    "snippet": "const generateCustomerData = (id: number): Customer => ({\n    id,\n    name: faker.person.fullName(),\n    email: faker.internet.email(),\n    phoneNumber: faker.phone.number({ style: 'national' }),\n    address: faker.location.streetAddress(),\n    city: faker.location.city(),\n    state: faker.location.state(),\n    zipCode: faker.location.zipCode(),\n    registrationDate: faker.date.past().toISOString(),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigXML.ts",
    "type": "Constant",
    "value": "generateLargeXML",
    "snippet": "const generateLargeXML = async (\n    filePath: string,\n    totalRecords: number,\n): Promise<void> => {\n    const writeStream = fs.createWriteStream(filePath);\n    writeStream.write('<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n');\n    writeStream.write('<customers>\\n');\n\n    for (let i = 1; i <= totalRecords; i++) {\n        const customer = generateCustomerData(i);\n\n        writeStream.write('  <customer>\\n');\n        writeStream.write(`    <id>${customer.id}</id>\\n`);\n        writeStream.write(`    <name>${customer.name}</name>\\n`);\n        writeStream.write(`    <email>${customer.email}</email>\\n`);\n        writeStream.write(\n            `    <phoneNumber>${customer.phoneNumber}</phoneNumber>\\n`,\n        );\n        writeStream.write(`    <address>${customer.address}</address>\\n`);\n        writeStream.write(`    <city>${customer.city}</city>\\n`);\n        writeStream.write(`    <state>${customer.state}</state>\\n`);\n        writeStream.write(`    <zipCode>${customer.zipCode}</zipCode>\\n`);\n        writeStream.write(\n            `    <registrationDate>${customer.registrationDate}</registrationDate>\\n`,\n        );\n        writeStream.write('  </customer>\\n');\n\n        if (i % 10000 === 0) console.log(`Generated ${i} records...`);\n    }\n\n    writeStream.write('</customers>\\n');\n    writeStream.end();\n\n    console.log(\n        `XML file with ${totalRecords} records generated at ${filePath}`,\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigXML.ts",
    "type": "Constant",
    "value": "writeStream",
    "snippet": "const writeStream = fs.createWriteStream(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigXML.ts",
    "type": "Constant",
    "value": "customer",
    "snippet": "const customer = generateCustomerData(i);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Interface",
    "value": "Customer",
    "snippet": "interface Customer {\n    id: number;\n    name: string;\n    email: string;\n    phoneNumber: string;\n    address: string;\n    city: string;\n    state: string;\n    zipCode: string;\n    registrationDate: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Constant",
    "value": "generateCustomerData",
    "snippet": "const generateCustomerData = (id: number): Customer => ({\n    id,\n    name: faker.person.fullName(),\n    email: faker.internet.email(),\n    phoneNumber: faker.phone.number({ style: 'national' }),\n    address: faker.location.streetAddress(),\n    city: faker.location.city(),\n    state: faker.location.state(),\n    zipCode: faker.location.zipCode(),\n    registrationDate: faker.date.past().toISOString(),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Constant",
    "value": "generateLargeYAML",
    "snippet": "const generateLargeYAML = async (\n    filePath: string,\n    totalRecords: number,\n): Promise<void> => {\n    const writeStream = fs.createWriteStream(filePath);\n\n    for (let i = 1; i <= totalRecords; i++) {\n        const customer = generateCustomerData(i);\n        const yamlData = stringify([customer]).trim();\n\n        writeStream.write(`${yamlData}\\n`);\n\n        if (i % 10000 === 0) console.log(`Generated ${i} records...`);\n    }\n\n    writeStream.end();\n    console.log(\n        `YAML file with ${totalRecords} records generated at ${filePath}`,\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Constant",
    "value": "writeStream",
    "snippet": "const writeStream = fs.createWriteStream(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Constant",
    "value": "customer",
    "snippet": "const customer = generateCustomerData(i);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/generateBigYAML.ts",
    "type": "Constant",
    "value": "yamlData",
    "snippet": "const yamlData = stringify([customer]).trim();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserJson.ts",
    "type": "Constant",
    "value": "keys",
    "snippet": "const keys = ECKeys.generateKeys();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserJson.ts",
    "type": "Constant",
    "value": "tokenizer",
    "snippet": "const tokenizer = Tokenizer({\n    publicKey: ECKeys.getPublicKey(keys),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserJson.ts",
    "type": "Class",
    "value": "CustomerParserSchema",
    "snippet": "class CustomerParserSchema extends AbstractParserSchema {\n    public field = {\n        id: {\n            to: 'id',\n            transform: [ToObjectId],\n        },\n        name: { to: 'name' },\n        email: {\n            to: 'email',\n            validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n            transform: [ToLowerCase],\n        },\n        phoneNumber: {\n            to: 'phone',\n            transform: [tokenizer],\n        },\n        registrationDate: {\n            to: 'createdAt',\n            transform: [ToDate],\n        },\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserXML.ts",
    "type": "Constant",
    "value": "keys",
    "snippet": "const keys = ECKeys.generateKeys();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserXML.ts",
    "type": "Constant",
    "value": "tokenizer",
    "snippet": "const tokenizer = Tokenizer({\n    publicKey: ECKeys.getPublicKey(keys),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserXML.ts",
    "type": "Class",
    "value": "CustomerParserSchema",
    "snippet": "class CustomerParserSchema extends AbstractParserSchema {\n    public field = {\n        id: {\n            to: 'id',\n            transform: [ToInt, ToObjectId],\n        },\n        name: { to: 'name' },\n        email: {\n            to: 'email',\n            validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n            transform: [ToLowerCase],\n        },\n        phoneNumber: {\n            to: 'phone',\n            transform: [tokenizer],\n        },\n        registrationDate: {\n            to: 'createdAt',\n            transform: [ToDate],\n        },\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserYAML.ts",
    "type": "Constant",
    "value": "keys",
    "snippet": "const keys = ECKeys.generateKeys();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserYAML.ts",
    "type": "Constant",
    "value": "tokenizer",
    "snippet": "const tokenizer = Tokenizer({\n    publicKey: ECKeys.getPublicKey(keys),\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/sample/parserYAML.ts",
    "type": "Class",
    "value": "CustomerParserSchema",
    "snippet": "class CustomerParserSchema extends AbstractParserSchema {\n    public field = {\n        id: {\n            to: 'id',\n            transform: [ToObjectId],\n        },\n        name: { to: 'name' },\n        email: {\n            to: 'email',\n            validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n            transform: [ToLowerCase],\n        },\n        phoneNumber: {\n            to: 'phone',\n            transform: [tokenizer],\n        },\n        registrationDate: {\n            to: 'createdAt',\n            transform: [ToDate],\n        },\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/generateBigJson.ts",
    "type": "Interface",
    "value": "Customer",
    "snippet": "interface Customer {\r\n    id: number;\r\n    name: string;\r\n    email: string;\r\n    phoneNumber: string;\r\n    address: string;\r\n    city: string;\r\n    state: string;\r\n    zipCode: string;\r\n    registrationDate: string;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "generateCustomerData",
    "snippet": "const generateCustomerData = (id: number): Customer => ({\r\n    id,\r\n    name: faker.person.fullName(),\r\n    email: faker.internet.email(),\r\n    phoneNumber: faker.phone.number({ style: 'national' }),\r\n    address: faker.location.streetAddress(),\r\n    city: faker.location.city(),\r\n    state: faker.location.state(),\r\n    zipCode: faker.location.zipCode(),\r\n    registrationDate: faker.date.past().toISOString(),\r\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "generateLargeJSON",
    "snippet": "const generateLargeJSON = async (\r\n    filePath: string,\r\n    totalRecords: number,\r\n): Promise<void> => {\r\n    const writeStream = fs.createWriteStream(filePath);\r\n    writeStream.write('[');\r\n\r\n    for (let i = 1; i <= totalRecords; i++) {\r\n        const customer = generateCustomerData(i);\r\n        writeStream.write(JSON.stringify(customer));\r\n\r\n        if (i < totalRecords) writeStream.write(',');\r\n\r\n        if (i % 10000 === 0) console.log(`Generated ${i} records...`);\r\n    }\r\n\r\n    writeStream.write(']');\r\n    writeStream.end();\r\n\r\n    console.log(\r\n        `JSON file with ${totalRecords} records generated at ${filePath}`,\r\n    );\r\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "writeStream",
    "snippet": "const writeStream = fs.createWriteStream(filePath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/generateBigJson.ts",
    "type": "Constant",
    "value": "customer",
    "snippet": "const customer = generateCustomerData(i);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Class",
    "value": "ReadBigFileWithParallel",
    "snippet": "class ReadBigFileWithParallel extends AbstractParallel {\r\n    @Hook(HooksType.onInitialize)\r\n    async start() {\r\n        const finalData = new Array<any>();\r\n        const poolNamespace= \"parserLine\";\r\n        const pool = ThreadPool.getThreadPool(poolNamespace);\r\n        const filename = path.resolve('./sample/large-customers.json');\r\n\r\n        if(pool){\r\n            let start;\r\n            console.log('Parser With Multi-Thread...');\r\n            const readStream = fs.createReadStream(path.resolve(filename));\r\n            const jsonStream = readStream.pipe(parser()).pipe(streamArray());\r\n\r\n            pool.on('data', async (response) => {\r\n                finalData[response.index] = response.data\r\n            });\r\n            pool.on('end', () => {\r\n                const end = Date.now();\r\n                console.log(`Parallel parser: ${finalData.length} | ${(end - start).toFixed(2)}s`);\r\n            });\r\n    \r\n            jsonStream.on('data', async ({ value, key }) => {\r\n                if(!start)\r\n                    start = Date.now();\r\n\r\n                pool.send({ value, index: key })\r\n            });\r\n            jsonStream.on('end', () => pool.endData());\r\n            jsonStream.on('error', error => console.error(error));\r\n\r\n            await pool.awaitEnd();\r\n        }\r\n        else {\r\n            throw new Error(`Thread pool '${poolNamespace}' not found`);\r\n        }\r\n    }\r\n\r\n    @Parallel({\r\n        namespace: \"parserLine\",\r\n        threads: 6\r\n    })\r\n    async parserLine(@Tread() thread: any, @ThreadData() payload: any) {\r\n        return { \r\n            data: await thread.jsonParser.parser(payload.value), \r\n            index: payload.index \r\n        }\r\n    }\r\n\r\n    @TreadContext(\"parserLine\")\r\n    async threadContext() {\r\n        const { \r\n            JSONParser, AbstractParserSchema,\r\n            ToObjectId, ToLowerCase, ToDate \r\n        } = await import(\"@cmmv/normalizer\");\r\n\r\n        const msgpack = await import(\"msgpack-lite\");\r\n\r\n        class CustomerSchema extends AbstractParserSchema {\r\n            public field = {\r\n                id: {\r\n                    to: 'id'\r\n                },\r\n                name: { to: 'name' },\r\n                email: {\r\n                    to: 'email',\r\n                    validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\r\n                    transform: [ToLowerCase],\r\n                },\r\n                registrationDate: {\r\n                    to: 'createdAt',\r\n                    transform: [ToDate],\r\n                },\r\n            };\r\n        }\r\n\r\n        const jsonParser = new JSONParser({ schema: CustomerSchema });\r\n        return { jsonParser, msgpack }; \r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "finalData",
    "snippet": "const finalData = new Array<any>();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "poolNamespace",
    "snippet": "const poolNamespace= \"parserLine\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "pool",
    "snippet": "const pool = ThreadPool.getThreadPool(poolNamespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "filename",
    "snippet": "const filename = path.resolve('./sample/large-customers.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "readStream",
    "snippet": "const readStream = fs.createReadStream(path.resolve(filename));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "jsonStream",
    "snippet": "const jsonStream = readStream.pipe(parser()).pipe(streamArray());"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "end",
    "snippet": "const end = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "msgpack",
    "snippet": "const msgpack = await import(\"msgpack-lite\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Class",
    "value": "CustomerSchema",
    "snippet": "class CustomerSchema extends AbstractParserSchema {\r\n            public field = {\r\n                id: {\r\n                    to: 'id'\r\n                },\r\n                name: { to: 'name' },\r\n                email: {\r\n                    to: 'email',\r\n                    validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\r\n                    transform: [ToLowerCase],\r\n                },\r\n                registrationDate: {\r\n                    to: 'createdAt',\r\n                    transform: [ToDate],\r\n                },\r\n            };\r\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "jsonParser",
    "snippet": "const jsonParser = new JSONParser({ schema: CustomerSchema });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Class",
    "value": "ReadBigFileWithoutParallel",
    "snippet": "class ReadBigFileWithoutParallel {\r\n    @Hook(HooksType.onInitialize)\r\n    async start() {\r\n        const { \r\n            JSONParser, AbstractParserSchema,\r\n            ToObjectId, ToLowerCase, ToDate \r\n        } = await import(\"@cmmv/normalizer\");\r\n        const finalData = new Array<any>();\r\n        const poolNamespace= \"parserLine\";\r\n        const pool = ThreadPool.getThreadPool(poolNamespace);\r\n        const filename = path.resolve('./sample/large-customers.json');\r\n\r\n        if(pool){\r\n            const start = Date.now();\r\n            console.log('Parser Without Multi-Thread...');\r\n\r\n            class CustomerSchema extends AbstractParserSchema {\r\n                public field = {\r\n                    id: {\r\n                        to: 'id',\r\n                        transform: [ToObjectId],\r\n                    },\r\n                    name: { to: 'name' },\r\n                    email: {\r\n                        to: 'email',\r\n                        validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\r\n                        transform: [ToLowerCase],\r\n                    },\r\n                    registrationDate: {\r\n                        to: 'createdAt',\r\n                        transform: [ToDate],\r\n                    },\r\n                };\r\n            }\r\n\r\n            const jsonParser = new JSONParser({ \r\n                schema: CustomerSchema,\r\n                input: filename\r\n            })\r\n            .pipe(async data => finalData.push(data))\r\n            .once('end', () => {\r\n                const end = Date.now();\r\n                console.log(`Single parser: ${finalData.length} | ${(end - start).toFixed(2)}s`);\r\n            })\r\n            .once('error', (error) => console.error(error))\r\n            .start();\r\n        }\r\n        else {\r\n            throw new Error(`Thread pool '${poolNamespace}' not found`);\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "finalData",
    "snippet": "const finalData = new Array<any>();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "poolNamespace",
    "snippet": "const poolNamespace= \"parserLine\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "pool",
    "snippet": "const pool = ThreadPool.getThreadPool(poolNamespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "filename",
    "snippet": "const filename = path.resolve('./sample/large-customers.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "start",
    "snippet": "const start = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Class",
    "value": "CustomerSchema",
    "snippet": "class CustomerSchema extends AbstractParserSchema {\r\n                public field = {\r\n                    id: {\r\n                        to: 'id',\r\n                        transform: [ToObjectId],\r\n                    },\r\n                    name: { to: 'name' },\r\n                    email: {\r\n                        to: 'email',\r\n                        validation: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\r\n                        transform: [ToLowerCase],\r\n                    },\r\n                    registrationDate: {\r\n                        to: 'createdAt',\r\n                        transform: [ToDate],\r\n                    },\r\n                };\r\n            }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "jsonParser",
    "snippet": "const jsonParser = new JSONParser({ \r\n                schema: CustomerSchema,\r\n                input: filename\r\n            })\r\n            .pipe(async data => finalData.push(data))\r\n            .once('end', () => {\r\n                const end = Date.now();\r\n                console.log(`Single parser: ${finalData.length} | ${(end - start).toFixed(2)}s`);\r\n            })\r\n            .once('error', (error) => console.error(error))\r\n            .start();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/sample/sample.ts",
    "type": "Constant",
    "value": "end",
    "snippet": "const end = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.abstract.ts",
    "type": "AbstractClass",
    "value": "AbstractParallel",
    "snippet": "abstract class AbstractParallel extends Singleton {\r\n    private pools = new Map<Symbol, ThreadPool>();\r\n\r\n    public getThreadPool(namespace: string){\r\n        const symbolName = Symbol(namespace);\r\n\r\n        return this.pools.has(symbolName) ? \r\n            this.pools.get(symbolName): null;\r\n    }\r\n\r\n    public creataThreadPool(\r\n        options: IParallelOptions, \r\n        fn: Function, \r\n        schema: any\r\n    ){\r\n        const symbolName = Symbol(options.namespace);\r\n        this.pools.set(symbolName, new ThreadPool(options, fn, schema));\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.abstract.ts",
    "type": "Constant",
    "value": "symbolName",
    "snippet": "const symbolName = Symbol(namespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.abstract.ts",
    "type": "Constant",
    "value": "symbolName",
    "snippet": "const symbolName = Symbol(options.namespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.config.ts",
    "type": "Constant",
    "value": "ParallelConfig",
    "snippet": "const ParallelConfig: ConfigSchema = {\r\n    parallel: {\r\n        maxThreads: {\r\n            required: false,\r\n            type: 'number',\r\n            default: 6,\r\n        },\r\n    },\r\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.decorator.ts",
    "type": "Function",
    "value": "Parallel",
    "snippet": "function Parallel(options: IParallelOptions): MethodDecorator {\r\n    return (target, propertyKey: string | symbol) => {\r\n        ParallelRegistry.registerHandler(target, propertyKey as string, options);\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.decorator.ts",
    "type": "Function",
    "value": "TreadContext",
    "snippet": "function TreadContext(namespace: string): MethodDecorator {\r\n    return (target, propertyKey: string | symbol, context?: any) => {\r\n        ParallelRegistry.registerContext(target, namespace, context.value);\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.decorator.ts",
    "type": "Function",
    "value": "Tread",
    "snippet": "function Tread(): ParameterDecorator {\r\n    return (target, propertyKey: string | symbol, parameterIndex: number) => {\r\n        ParallelRegistry.registerParam(\r\n            target,\r\n            propertyKey as string,\r\n            'thread',\r\n            parameterIndex\r\n        );\r\n    } ;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.decorator.ts",
    "type": "Function",
    "value": "ThreadData",
    "snippet": "function ThreadData(): ParameterDecorator {\r\n    return (target, propertyKey: string | symbol, parameterIndex: number) => {\r\n        ParallelRegistry.registerParam(\r\n            target,\r\n            propertyKey as string,\r\n            'data',\r\n            parameterIndex,\r\n        );\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.interface.ts",
    "type": "Symbol",
    "value": "parallel_options",
    "snippet": "Symbol(\"parallel_options\")"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.interface.ts",
    "type": "Interface",
    "value": "IParallelOptions",
    "snippet": "interface IParallelOptions {\r\n    namespace: string;\r\n    threads: number;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.model.ts",
    "type": "Constant",
    "value": "ParallelModule",
    "snippet": "const ParallelModule = new Module('parallel', {\r\n    configs: [ParallelConfig],\r\n    providers: [ParallelProvider],\r\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.provider.ts",
    "type": "Class",
    "value": "ParallelProvider",
    "snippet": "@Service(\"parallel\")\r\nexport class ParallelProvider extends Singleton {\r\n    public static async loadConfig(application: Application): Promise<void> {\r\n        const controllers: any = ParallelRegistry.getControllers();\r\n\r\n        controllers.forEach(async ([controllerClass, metadata]) => {\r\n            \r\n            const paramTypes =\r\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\r\n\r\n            const instances = paramTypes.map((paramType: any) =>\r\n                application.providersMap.get(paramType.name)\r\n            );\r\n\r\n            const controllerInstance = new controllerClass(...instances);\r\n\r\n            metadata.handlers.forEach(handlerMetadata => {\r\n                const { handlerName, options, context } = handlerMetadata;\r\n\r\n                if(options && !ThreadPool.hasThreadPool(options.namespace)){\r\n                    if(controllerInstance instanceof AbstractParallel) {\r\n                        ThreadPool.createThreadPool(\r\n                            options, \r\n                            controllerInstance[handlerName],\r\n                            handlerMetadata,\r\n                            context\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        })\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.provider.ts",
    "type": "Constant",
    "value": "controllers",
    "snippet": "const controllers: any = ParallelRegistry.getControllers();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.provider.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\r\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.provider.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\r\n                application.providersMap.get(paramType.name)\r\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.provider.ts",
    "type": "Constant",
    "value": "controllerInstance",
    "snippet": "const controllerInstance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "META_OPTIONS",
    "snippet": "const META_OPTIONS = Symbol('controller_options');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Symbol",
    "value": "controller_options",
    "snippet": "Symbol('controller_options')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Class",
    "value": "ParallelRegistry",
    "snippet": "class ParallelRegistry extends GenericRegistry<any> {\r\n    public static indexByName = new Map<any, Record<string, string>>();\r\n\r\n    public static override registerHandler(\r\n        target: any, \r\n        handlerName: string,\r\n        options?: any\r\n    ) {\r\n        let controller = this.controllers.get(target.constructor);\r\n        \r\n        if (!controller) {\r\n            const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};\r\n            this.registerController(target.constructor, options);\r\n            controller = this.controllers.get(target.constructor);\r\n        }\r\n\r\n        if (controller) {\r\n            const handler = controller.handlers\r\n                .find(msg => msg.handlerName === handlerName);\r\n                \r\n            if (!handler) {\r\n                const headlerData = { \r\n                    namespace: options.namespace, \r\n                    handlerName,\r\n                    params: [], \r\n                    context : null, \r\n                    options \r\n                };\r\n\r\n                controller.handlers.push(headlerData);\r\n            }\r\n            else {\r\n                handler.namespace = options.namespace;\r\n                handler.options = options;\r\n                handler.handlerName = handlerName;\r\n            }\r\n\r\n            \r\n        }\r\n    }\r\n\r\n    public static registerContext(\r\n        target: any, \r\n        namespace: string,\r\n        handlerContext: Function\r\n    ) {\r\n        let controller = this.controllers.get(target.constructor);\r\n\r\n        if (!controller) {\r\n            const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};\r\n            this.registerController(target.constructor, options);\r\n            controller = this.controllers.get(target.constructor);\r\n        }\r\n\r\n        if (controller) {\r\n            const handler = controller.handlers.find(msg => msg.namespace === namespace);\r\n\r\n            if (!handler) {\r\n                controller.handlers.push({ \r\n                    namespace, params: [], \r\n                    context : handlerContext, \r\n                    options: {} \r\n                });\r\n            }\r\n            else handler.context = handlerContext;\r\n        }\r\n    }\r\n\r\n    public static override registerParam(\r\n        target: any,\r\n        handlerName: string,\r\n        paramType: string,\r\n        index: number,\r\n    ) {\r\n        let controller = this.controllers.get(target.constructor);\r\n        const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};\r\n   \r\n        if (!controller) {\r\n            this.registerController(target.constructor, options);\r\n            controller = this.controllers.get(target.constructor);\r\n        }\r\n\r\n        if (controller) {\r\n            let handler = controller.handlers.find(\r\n                msg => msg.handlerName === handlerName,\r\n            );\r\n\r\n            if (!handler) {\r\n                handler = { handlerName, params: [] };\r\n                controller.handlers.push(handler);\r\n            }\r\n\r\n            handler.params = handler.params || [];\r\n            handler.params.push({ paramType, index });\r\n\r\n            controller.handlers.find(\r\n                (msg, index) => {\r\n                    if(msg.handlerName === handlerName)\r\n                        controller.handlers[index] = handler;\r\n                },\r\n            );\r\n\r\n            this.controllers.set(target.constructor, controller);            \r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = controller.handlers\r\n                .find(msg => msg.handlerName === handlerName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "headlerData",
    "snippet": "const headlerData = { \r\n                    namespace: options.namespace, \r\n                    handlerName,\r\n                    params: [], \r\n                    context : null, \r\n                    options \r\n                };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = controller.handlers.find(msg => msg.namespace === namespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/parallel.registry.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options = Reflect.getMetadata(META_OPTIONS, target.constructor) || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/threadpool.ts",
    "type": "Class",
    "value": "ThreadPool",
    "snippet": "class ThreadPool extends EventEmitter {\r\n    public static pools = new Map<string, ThreadPool>();\r\n    protected threads: Array<Worker> = [];\r\n    private totalDataSend: number = 0;\r\n    private totalTreadReturn: number = 0;\r\n    private threadWorkPointer: number = 0;\r\n    private endDataMark: boolean = false;\r\n    private threadIndex = 0;\r\n    private sentEnd = false;\r\n    \r\n    private messageBuffer: any[] = []; // ðŸ”¹ Buffer para acumular mensagens antes de enviar\r\n    private batchSize: number = 10;    // ðŸ”¹ NÃºmero de mensagens antes de enviar\r\n    private flushInterval: number = 50; // ðŸ”¹ Tempo (ms) antes de enviar buffer acumulado\r\n\r\n    constructor(\r\n        options: IParallelOptions,\r\n        fn: Function,\r\n        schema: any,\r\n        context?: Function\r\n    ) {\r\n        super();\r\n        this.createThreads(options, fn, schema, context);\r\n        setInterval(() => this.flushMessages(), this.flushInterval);\r\n    }\r\n\r\n    public static getThreadPool(namespace: string) {\r\n        return ThreadPool.pools.has(namespace) ? \r\n            ThreadPool.pools.get(namespace) : null;\r\n    }\r\n\r\n    public static hasThreadPool(namespace: string) {\r\n        return ThreadPool.pools.has(namespace);\r\n    }\r\n\r\n    public static createThreadPool(\r\n        options: IParallelOptions, \r\n        fn: Function, \r\n        schema: any,\r\n        context?: Function\r\n    ) {\r\n        ThreadPool.pools.set(options.namespace, new ThreadPool(options, fn, schema, context));\r\n    }\r\n\r\n    public createThreads(\r\n        options: IParallelOptions, \r\n        fn: Function,\r\n        schema: any,\r\n        context?: Function\r\n    ) {\r\n        const workerCode = `\r\n        const { parentPort, workerData, threadId } = require('worker_threads');\r\n        const msgpack = require(\"msgpack-lite\");\r\n\r\n        (async () => {\r\n            try {\r\n                let { schema } = workerData;\r\n                const contextFn = ${context ? this.transformFunction(context) : 'null'};\r\n                const scope = (contextFn) ? await contextFn() : {};\r\n                const executeFn = ${this.transformFunction(fn)};\r\n                schema = JSON.parse(schema);\r\n\r\n                parentPort.on('message', async (payloads) => {\r\n                    try {\r\n                        const results = [];\r\n\r\n                        for (const payload of payloads) {\r\n                            const args = new Array(schema.params.length);\r\n        \r\n                            for (const param of schema.params) {\r\n                                if (param.paramType === \"data\") \r\n                                    args[param.index] = msgpack.decode(payload);\r\n                                else if (param.paramType === \"thread\") \r\n                                    args[param.index] = { threadId, parentPort, ...scope };            \r\n                            }\r\n\r\n                            results.push(await executeFn(...args));\r\n                        }\r\n                        \r\n                        parentPort.postMessage(msgpack.encode(results));\r\n                    } catch (error) {\r\n                        console.error(\\`Thread [\\${workerData.threadId}]: \\`, error.message);\r\n                        parentPort.postMessage({ error: error.message });\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                console.log(error);\r\n                parentPort.postMessage({ error: error.message });\r\n            }\r\n        })();`;\r\n        \r\n        for(let i = 0; i < options.threads; i++){\r\n            const worker = new Worker(workerCode, {\r\n                eval: true,\r\n                stdout: true,\r\n                workerData: { \r\n                    fn: this.transformFunction(fn), \r\n                    schema: JSON.stringify(schema)\r\n                }\r\n            });\r\n\r\n            worker.stdout.on(\"data\", (data) => {\r\n                console.log(`[Worker] ${data.toString().trim()}`);\r\n            });\r\n            \r\n            worker.stderr.on(\"data\", (data) => {\r\n                console.error(`[Worker Error] ${data.toString().trim()}`);\r\n            });\r\n    \r\n            worker.on(\"message\", (data) => {\r\n                data = msgpack.decode(data)\r\n                this.totalTreadReturn += data.length;\r\n                data.forEach(d => this.emit('data', d));\r\n\r\n                if(this.endDataMark && !this.sentEnd && this.totalDataSend === this.totalTreadReturn){\r\n                    this.sentEnd = true;\r\n                    this.emit('end');\r\n                }                    \r\n            });\r\n            \r\n            worker.on(\"error\", () => this.emit('error'));\r\n            worker.on(\"exit\", (code) => {\r\n                this.emit('error', `Worker stopped with exit code ${code}`);\r\n            });\r\n\r\n            this.threads.push(worker);\r\n        }\r\n    }\r\n\r\n    public send(payload: object | string, schema?: any) {\r\n        if (this.threads.length === 0) {\r\n            console.error(\"No workers available\");\r\n            throw new Error(\"No workers available\");\r\n        }  \r\n\r\n        if (typeof payload === \"object\" && !schema) {\r\n            payload = msgpack.encode(payload);\r\n        } else if (typeof payload === \"object\" && schema) {\r\n            payload = schema(payload);\r\n        }\r\n\r\n        this.messageBuffer.push(payload);\r\n\r\n        if (this.messageBuffer.length >= this.batchSize) \r\n            this.flushMessages();\r\n    }\r\n\r\n    private flushMessages() {\r\n        if (this.messageBuffer.length === 0) return;\r\n\r\n        this.threadWorkPointer++;\r\n        const worker = this.threads[this.threadIndex];\r\n        this.threadIndex = (this.threadIndex + 1) % this.threads.length;\r\n\r\n        if (worker) {\r\n            this.totalDataSend += this.messageBuffer.length;\r\n            worker.postMessage(this.messageBuffer.splice(0, this.batchSize)); // ðŸ”¹ Envia o lote\r\n        }\r\n    }\r\n\r\n    public endData() {\r\n        this.endDataMark = true;\r\n    }\r\n\r\n    public flush() {\r\n        this.totalDataSend = 0;\r\n        this.totalTreadReturn = 0;\r\n        this.threadWorkPointer = 0;\r\n        this.endDataMark = false;\r\n        this.messageBuffer = [];\r\n    }\r\n\r\n    private transformFunction(fn: Function): string {\r\n        const fnString = fn.toString().replace(/^async\\s+\\w+\\s*\\((.*?)\\)/, 'async ($1) =>');\r\n        return `(${fnString})`;\r\n    }\r\n\r\n    private awaitEnd() {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                let persistence = setInterval(() => {\r\n                    if (this.endDataMark && !this.sentEnd && this.totalDataSend === this.totalTreadReturn) {\r\n                        this.sentEnd = true;\r\n                        clearInterval(persistence);\r\n                        this.emit('end');                        \r\n                        resolve(true);\r\n                    }\r\n                }, 100);\r\n            }\r\n            catch { resolve(false); }\r\n        });\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/threadpool.ts",
    "type": "Constant",
    "value": "workerCode",
    "snippet": "const workerCode = `\r\n        const { parentPort, workerData, threadId } = require('worker_threads');\r\n        const msgpack = require(\"msgpack-lite\");\r\n\r\n        (async () => {\r\n            try {\r\n                let { schema } = workerData;\r\n                const contextFn = ${context ? this.transformFunction(context) : 'null'};\r\n                const scope = (contextFn) ? await contextFn() : {};\r\n                const executeFn = ${this.transformFunction(fn)};\r\n                schema = JSON.parse(schema);\r\n\r\n                parentPort.on('message', async (payloads) => {\r\n                    try {\r\n                        const results = [];\r\n\r\n                        for (const payload of payloads) {\r\n                            const args = new Array(schema.params.length);\r\n        \r\n                            for (const param of schema.params) {\r\n                                if (param.paramType === \"data\") \r\n                                    args[param.index] = msgpack.decode(payload);\r\n                                else if (param.paramType === \"thread\") \r\n                                    args[param.index] = { threadId, parentPort, ...scope };            \r\n                            }\r\n\r\n                            results.push(await executeFn(...args));\r\n                        }\r\n                        \r\n                        parentPort.postMessage(msgpack.encode(results));\r\n                    } catch (error) {\r\n                        console.error(\\`Thread [\\${workerData.threadId}]: \\`, error.message);\r\n                        parentPort.postMessage({ error: error.message });\r\n                    }\r\n                });\r\n            } catch (error) {\r\n                console.log(error);\r\n                parentPort.postMessage({ error: error.message });\r\n            }\r\n        })();`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/threadpool.ts",
    "type": "Constant",
    "value": "worker",
    "snippet": "const worker = new Worker(workerCode, {\r\n                eval: true,\r\n                stdout: true,\r\n                workerData: { \r\n                    fn: this.transformFunction(fn), \r\n                    schema: JSON.stringify(schema)\r\n                }\r\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/threadpool.ts",
    "type": "Constant",
    "value": "worker",
    "snippet": "const worker = this.threads[this.threadIndex];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-parallel/src/threadpool.ts",
    "type": "Constant",
    "value": "fnString",
    "snippet": "const fnString = fn.toString().replace(/^async\\s+\\w+\\s*\\((.*?)\\)/, 'async ($1) =>');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.config.ts",
    "type": "Constant",
    "value": "QueueConfig",
    "snippet": "const QueueConfig: ConfigSchema = {\n    queue: {\n        type: {\n            required: true,\n            type: 'string',\n            default: 'rabbitmq',\n        },\n        url: {\n            required: true,\n            type: 'string',\n            default: 'amqp://guest:guest@localhost:5672/cmmv',\n        },\n    },\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "Channel",
    "snippet": "function Channel(\n    queueName: string,\n    options?: QueueOptions,\n): ClassDecorator {\n    return (target: object) => {\n        Reflect.defineMetadata('channel_queue', queueName, target);\n        Reflect.defineMetadata('channel_options', options, target);\n        QueueRegistry.registerChannel(target, queueName, options);\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "createConsumeDecorator",
    "snippet": "function createConsumeDecorator(message: string): MethodDecorator {\n    return (target, propertyKey: string | symbol) => {\n        QueueRegistry.registerConsumeHandler(\n            target,\n            message,\n            propertyKey as string,\n        );\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "Consume",
    "snippet": "function Consume(message: string): MethodDecorator {\n    return createConsumeDecorator(message);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "QueueMessage",
    "snippet": "function QueueMessage(): ParameterDecorator {\n    return (target, propertyKey: string | symbol, parameterIndex: number) => {\n        QueueRegistry.registerParam(\n            target,\n            propertyKey as string,\n            'message',\n            parameterIndex,\n        );\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "QueueConn",
    "snippet": "function QueueConn(): ParameterDecorator {\n    return (target, propertyKey: string | symbol, parameterIndex: number) => {\n        QueueRegistry.registerParam(\n            target,\n            propertyKey as string,\n            'conn',\n            parameterIndex,\n        );\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.decorator.ts",
    "type": "Function",
    "value": "QueueChannel",
    "snippet": "function QueueChannel(): ParameterDecorator {\n    return (target, propertyKey: string | symbol, parameterIndex: number) => {\n        QueueRegistry.registerParam(\n            target,\n            propertyKey as string,\n            'channel',\n            parameterIndex,\n        );\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.interface.ts",
    "type": "Interface",
    "value": "QueueOptions",
    "snippet": "interface QueueOptions {\n    exchangeName?: string;\n    pubSub?: boolean;\n    exclusive?: boolean;\n    autoDelete?: boolean;\n    durable?: boolean;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.module.ts",
    "type": "Constant",
    "value": "QueueModule",
    "snippet": "const QueueModule = new Module('queue', {\n    configs: [QueueConfig],\n    providers: [QueueService],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Class",
    "value": "QueueRegistry",
    "snippet": "class QueueRegistry {\n    public static queues = new Map<\n        any,\n        {\n            queueName: string;\n            exchangeName: string;\n            pubSub: boolean;\n            durable: boolean;\n            autoDelete: boolean;\n            exclusive: boolean;\n            consumes: any[];\n        }\n    >();\n\n    public static registerChannel(\n        target: any,\n        queueName: string,\n        options: any,\n    ) {\n        const pubSub = options?.pubSub === true;\n        const durable = options?.durable === true;\n        const autoDelete = options?.autoDelete === true;\n        const exclusive = options?.exclusive === true;\n        const exchangeName = options?.exchangeName || 'exchange-name';\n\n        if (!this.queues.has(target)) {\n            this.queues.set(target, {\n                queueName,\n                consumes: [],\n                pubSub,\n                durable,\n                autoDelete,\n                exclusive,\n                exchangeName,\n            });\n        } else {\n            this.queues.set(target, {\n                ...this.queues.get(target),\n                queueName,\n                pubSub,\n                durable,\n                autoDelete,\n                exclusive,\n                exchangeName,\n            });\n        }\n    }\n\n    public static registerConsumeHandler(\n        target: any,\n        message: string,\n        handlerName: string,\n    ) {\n        let queue = this.queues.get(target.constructor);\n\n        if (!queue) {\n            const queueName =\n                Reflect.getMetadata('channel_queue', target.constructor) || '';\n            const options =\n                Reflect.getMetadata('channel_options', target.constructor) ||\n                {};\n            this.registerChannel(target.constructor, queueName, options);\n            queue = this.queues.get(target.constructor);\n        }\n\n        if (queue) {\n            const handler = queue.consumes.find(\n                msg => msg.handlerName === handlerName,\n            );\n\n            if (!handler)\n                queue.consumes.push({ message, handlerName, params: [] });\n            else handler.message = message;\n        }\n    }\n\n    public static registerParam(\n        target: any,\n        handlerName: string,\n        paramType: string,\n        index: number,\n    ) {\n        let queue = this.queues.get(target.constructor);\n\n        if (!queue) {\n            const queueName =\n                Reflect.getMetadata('channel_queue', target.constructor) || '';\n            const options =\n                Reflect.getMetadata('channel_options', target.constructor) ||\n                {};\n            this.registerChannel(target.constructor, queueName, options);\n            queue = this.queues.get(target.constructor);\n        }\n\n        if (queue) {\n            let handler = queue.consumes.find(\n                msg => msg.handlerName === handlerName,\n            );\n\n            if (!handler) {\n                handler = { message: '', handlerName, params: [] };\n                queue.consumes.push(handler);\n            }\n\n            handler.params = handler.params || [];\n            handler.params.push({ paramType, index });\n        } else {\n            console.log(`${target.constructor.name} not found`);\n        }\n    }\n\n    public static getQueues() {\n        return Array.from(this.queues.entries());\n    }\n\n    public static getConsumes(target: any): any[] {\n        const queues = this.queues.get(target);\n        return queues ? queues.consumes : [];\n    }\n\n    public static getParams(target: any, handlerName: string): any[] {\n        const queues = this.queues.get(target.constructor);\n\n        if (!queues) return [];\n\n        const handler = queues.consumes.find(\n            msg => msg.handlerName === handlerName,\n        );\n\n        return handler ? handler.params : [];\n    }\n\n    public static clear() {\n        QueueRegistry.queues = new Map<\n            any,\n            {\n                queueName: string;\n                exchangeName: string;\n                pubSub: boolean;\n                durable: boolean;\n                autoDelete: boolean;\n                exclusive: boolean;\n                consumes: any[];\n            }\n        >();\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "pubSub",
    "snippet": "const pubSub = options?.pubSub === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "durable",
    "snippet": "const durable = options?.durable === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "autoDelete",
    "snippet": "const autoDelete = options?.autoDelete === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "exclusive",
    "snippet": "const exclusive = options?.exclusive === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "exchangeName",
    "snippet": "const exchangeName = options?.exchangeName || 'exchange-name';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "queueName",
    "snippet": "const queueName =\n                Reflect.getMetadata('channel_queue', target.constructor) || '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options =\n                Reflect.getMetadata('channel_options', target.constructor) ||\n                {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = queue.consumes.find(\n                msg => msg.handlerName === handlerName,\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "queueName",
    "snippet": "const queueName =\n                Reflect.getMetadata('channel_queue', target.constructor) || '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options =\n                Reflect.getMetadata('channel_options', target.constructor) ||\n                {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "queues",
    "snippet": "const queues = this.queues.get(target);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "queues",
    "snippet": "const queues = this.queues.get(target.constructor);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.registry.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = queues.consumes.find(\n            msg => msg.handlerName === handlerName,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Class",
    "value": "QueueService",
    "snippet": "@Service('queue')\nexport class QueueService extends Singleton {\n    public logger: Logger = new Logger('QueueService');\n    public queueConn: any;\n    public channels: Map<string, any> = new Map<string, any>();\n    public queues: Map<string, any> = new Map<string, any>();\n    private kafkaProducer: Producer;\n    private kafkaConsumers: Consumer[] = [];\n    private redisClient: Redis;\n\n    private registeredConsumers: Map<\n        string,\n        { instance: any; handlerName: string; params: any[] }\n    > = new Map();\n\n    public static async loadConfig(application: Application): Promise<void> {\n        const instance = QueueService.getInstance();\n        const queueType = Config.get<string>('queue.type', 'rabbitmq');\n        const queueUrl: string = Config.get<string>('queue.url', '');\n\n        try {\n            switch (queueType) {\n                case 'rabbitmq':\n                    if (queueUrl.startsWith('amqp:')) {\n                        instance.queueConn = amqp.connect(queueUrl);\n                        instance.queueConn.on('connect', () =>\n                            instance.logger.log('RabbitMQ connected!'),\n                        );\n                        instance.queueConn.on('disconnect', error =>\n                            instance.logger.error(error.toString()),\n                        );\n\n                        await instance.setupRabbitMQ(application);\n                    } else {\n                        throw new Error(\n                            \"Invalid RabbitMQ URL. Please check 'queue.url' configuration.\",\n                        );\n                    }\n                    break;\n\n                case 'kafka':\n                    const kafka = new Kafka({ brokers: queueUrl.split(',') });\n                    instance.kafkaProducer = kafka.producer();\n                    await instance.kafkaProducer.connect();\n\n                    instance.logger.log('Kafka connected!');\n\n                    await instance.setupKafka(application, kafka);\n                    break;\n\n                case 'redis':\n                    instance.redisClient = new Redis(queueUrl);\n                    instance.redisClient.on('connect', () =>\n                        instance.logger.log('Redis connected!'),\n                    );\n                    instance.redisClient.on('error', error =>\n                        instance.logger.error(error.toString()),\n                    );\n\n                    await instance.setupRedis(application);\n                    break;\n\n                default:\n                    throw new Error(`Unsupported queue type: ${queueType}`);\n            }\n        } catch (e) {\n            instance.logger.error(e.message);\n            console.error(e);\n        }\n    }\n\n    private async setupRabbitMQ(application: Application): Promise<void> {\n        const instance = QueueService.getInstance();\n        const queues: any = QueueRegistry.getQueues();\n\n        queues.forEach(async ([controllerClass, metadata]) => {\n            const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\n\n            const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );\n\n            const controllerInstance = new controllerClass(...instances);\n\n            metadata.consumes.forEach(consumeMetadata => {\n                const { message, handlerName, params } = consumeMetadata;\n\n                instance.registeredConsumers.set(message, {\n                    instance: controllerInstance,\n                    handlerName,\n                    params,\n                });\n            });\n\n            const channelWrapper = instance.queueConn.createChannel({\n                json: true,\n                name: metadata.queueName,\n                setup: channel => {\n                    const promises = metadata.consumes.map(consume => {\n                        const pubSub = metadata.pubSub === true;\n                        const exclusive = metadata.exclusive === true;\n                        const autoDelete = metadata.autoDelete === true;\n                        const exchangeName =\n                            metadata.exchangeName || 'exchange-name';\n\n                        if (pubSub) {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.assertExchange(exchangeName, 'topic'),\n                                channel.prefetch(1),\n                                channel.bindQueue(\n                                    consume.message,\n                                    exchangeName,\n                                    '#',\n                                ),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        } else {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        }\n                    });\n\n                    return Promise.all(promises);\n                },\n            });\n\n            await channelWrapper.waitForConnect();\n            instance.channels.set(metadata.queueName, channelWrapper);\n        });\n    }\n\n    private async setupKafka(\n        application: Application,\n        kafka: Kafka,\n    ): Promise<void> {\n        const instance = QueueService.getInstance();\n        const queues: any = QueueRegistry.getQueues();\n\n        queues.forEach(async ([controllerClass, metadata]) => {\n            const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\n\n            const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );\n\n            const controllerInstance = new controllerClass(...instances);\n\n            metadata.consumes.forEach(async consumeMetadata => {\n                const { message, handlerName, params } = consumeMetadata;\n\n                instance.registeredConsumers.set(message, {\n                    instance: controllerInstance,\n                    handlerName,\n                    params,\n                });\n\n                const consumer = kafka.consumer({\n                    groupId: `${metadata.queueName}-${message}`,\n                });\n                await consumer.connect();\n                await consumer.subscribe({\n                    topic: message,\n                    fromBeginning: true,\n                });\n\n                consumer.run({\n                    eachMessage: async ({ message }) => {\n                        try {\n                            const data = JSON.parse(message.value.toString());\n                            await instance.processMessage(\n                                null,\n                                message.value.toString(),\n                                data,\n                            );\n                        } catch (error) {\n                            instance.logger.error(error.message);\n                        }\n                    },\n                });\n\n                instance.kafkaConsumers.push(consumer);\n            });\n        });\n    }\n\n    private async setupRedis(application: Application): Promise<void> {\n        const instance = QueueService.getInstance();\n        const queues: any = QueueRegistry.getQueues();\n\n        queues.forEach(([controllerClass, metadata]) => {\n            const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];\n\n            const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );\n\n            const controllerInstance = new controllerClass(...instances);\n\n            metadata.consumes.forEach(consumeMetadata => {\n                const { message, handlerName, params } = consumeMetadata;\n\n                instance.registeredConsumers.set(message, {\n                    instance: controllerInstance,\n                    handlerName,\n                    params,\n                });\n\n                instance.redisClient.subscribe(\n                    message,\n                    async (channel, data: any) => {\n                        try {\n                            const parsedData = JSON.parse(data);\n                            await instance.processMessage(\n                                null,\n                                channel.toString(),\n                                parsedData,\n                            );\n                        } catch (error) {\n                            instance.logger.error(error.message);\n                        }\n                    },\n                );\n            });\n        });\n    }\n\n    private async processMessage(\n        channel: any,\n        queueName: string,\n        data: any,\n    ): Promise<void> {\n        const consumer = this.registeredConsumers.get(queueName);\n\n        if (consumer) {\n            const { instance, handlerName, params } = consumer;\n\n            const args = params\n                .sort((a, b) => a.index - b.index)\n                .map(param => {\n                    switch (param.paramType) {\n                        case 'message':\n                            return data;\n                        case 'queueName':\n                            return queueName;\n                        case 'channel':\n                            return channel;\n                        default:\n                            return undefined;\n                    }\n                });\n\n            try {\n                await instance[handlerName](...args);\n            } catch (e) {\n                this.logger.error(`Error in handler: ${e.message}`);\n            }\n        } else {\n            this.logger.log(`No consumer registered for queue: ${queueName}`);\n        }\n    }\n\n    public async send(\n        channelName: string,\n        queueName: string,\n        data: any,\n    ): Promise<boolean> {\n        try {\n            const instance = QueueService.getInstance();\n            const queueType = Config.get<string>('queue.type', 'rabbitmq');\n\n            if (instance.channels.has(channelName)) {\n                switch (queueType) {\n                    case 'rabbitmq':\n                        if (instance.channels.has(channelName)) {\n                            const channel =\n                                await instance.channels.get(channelName);\n                            return await channel.sendToQueue(queueName, data);\n                        }\n                        break;\n                    case 'kafka':\n                        if (instance.kafkaProducer) {\n                            await instance.kafkaProducer.send({\n                                topic: queueName,\n                                messages: [{ value: JSON.stringify(data) }],\n                            });\n\n                            return true;\n                        }\n                        break;\n                    case 'redis':\n                        if (instance.redisClient) {\n                            await instance.redisClient.rpush(\n                                queueName,\n                                JSON.stringify(data),\n                            );\n                            return true;\n                        }\n                        break;\n                    default:\n                        throw new Error(`Unsupported queue type: ${queueType}`);\n                }\n            }\n\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    public async publish(\n        channelName: string,\n        exchangeName: string,\n        data: any,\n        persistent: boolean = true,\n    ) {\n        try {\n            const instance = QueueService.getInstance();\n            const queueType = Config.get<string>('queue.type', 'rabbitmq');\n\n            if (instance.channels.has(channelName)) {\n                const channel = await instance.channels.get(channelName);\n\n                switch (queueType) {\n                    case 'rabbitmq':\n                        if (instance.channels.has(channelName)) {\n                            const channel =\n                                await instance.channels.get(channelName);\n                            return channel.publish(\n                                exchangeName,\n                                '',\n                                Buffer.from(JSON.stringify(data)),\n                                {\n                                    contentType: 'application/json',\n                                    persistent,\n                                },\n                            );\n                        }\n                        break;\n                    case 'kafka':\n                        if (instance.kafkaProducer) {\n                            await instance.kafkaProducer.send({\n                                topic: exchangeName,\n                                messages: [{ value: JSON.stringify(data) }],\n                            });\n                            return true;\n                        }\n                        break;\n                    case 'redis':\n                        if (instance.redisClient) {\n                            await instance.redisClient.publish(\n                                exchangeName,\n                                JSON.stringify(data),\n                            );\n                            return true;\n                        }\n                        break;\n                    default:\n                        throw new Error(`Unsupported queue type: ${queueType}`);\n                }\n            }\n\n            return false;\n        } catch (e) {\n            return false;\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queueType",
    "snippet": "const queueType = Config.get<string>('queue.type', 'rabbitmq');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queueUrl",
    "snippet": "const queueUrl: string = Config.get<string>('queue.url', '');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "kafka",
    "snippet": "const kafka = new Kafka({ brokers: queueUrl.split(',') });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queues",
    "snippet": "const queues: any = QueueRegistry.getQueues();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "controllerInstance",
    "snippet": "const controllerInstance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "channelWrapper",
    "snippet": "const channelWrapper = instance.queueConn.createChannel({\n                json: true,\n                name: metadata.queueName,\n                setup: channel => {\n                    const promises = metadata.consumes.map(consume => {\n                        const pubSub = metadata.pubSub === true;\n                        const exclusive = metadata.exclusive === true;\n                        const autoDelete = metadata.autoDelete === true;\n                        const exchangeName =\n                            metadata.exchangeName || 'exchange-name';\n\n                        if (pubSub) {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.assertExchange(exchangeName, 'topic'),\n                                channel.prefetch(1),\n                                channel.bindQueue(\n                                    consume.message,\n                                    exchangeName,\n                                    '#',\n                                ),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        } else {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        }\n                    });\n\n                    return Promise.all(promises);\n                },\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "promises",
    "snippet": "const promises = metadata.consumes.map(consume => {\n                        const pubSub = metadata.pubSub === true;\n                        const exclusive = metadata.exclusive === true;\n                        const autoDelete = metadata.autoDelete === true;\n                        const exchangeName =\n                            metadata.exchangeName || 'exchange-name';\n\n                        if (pubSub) {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.assertExchange(exchangeName, 'topic'),\n                                channel.prefetch(1),\n                                channel.bindQueue(\n                                    consume.message,\n                                    exchangeName,\n                                    '#',\n                                ),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        } else {\n                            return Promise.all([\n                                channel.assertQueue(consume.message, {\n                                    exclusive,\n                                    autoDelete,\n                                    durable: true,\n                                }),\n                                channel.consume(consume.message, async msg => {\n                                    if (msg) {\n                                        try {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                JSON.parse(\n                                                    msg.content.toString(),\n                                                ),\n                                            );\n                                            channel.ack(msg); // Acknowledge the message\n                                        } catch (error) {\n                                            await instance.processMessage(\n                                                channel,\n                                                consume.message,\n                                                msg.content,\n                                            );\n                                            channel.ack(msg);\n                                        }\n                                    }\n                                }),\n                            ]);\n                        }\n                    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "pubSub",
    "snippet": "const pubSub = metadata.pubSub === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "exclusive",
    "snippet": "const exclusive = metadata.exclusive === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "autoDelete",
    "snippet": "const autoDelete = metadata.autoDelete === true;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "exchangeName",
    "snippet": "const exchangeName =\n                            metadata.exchangeName || 'exchange-name';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queues",
    "snippet": "const queues: any = QueueRegistry.getQueues();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "controllerInstance",
    "snippet": "const controllerInstance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "consumer",
    "snippet": "const consumer = kafka.consumer({\n                    groupId: `${metadata.queueName}-${message}`,\n                });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "data",
    "snippet": "const data = JSON.parse(message.value.toString());"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queues",
    "snippet": "const queues: any = QueueRegistry.getQueues();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "paramTypes",
    "snippet": "const paramTypes =\n                Reflect.getMetadata('design:paramtypes', controllerClass) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instances",
    "snippet": "const instances = paramTypes.map((paramType: any) =>\n                application.providersMap.get(paramType.name),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "controllerInstance",
    "snippet": "const controllerInstance = new controllerClass(...instances);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "parsedData",
    "snippet": "const parsedData = JSON.parse(data);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "consumer",
    "snippet": "const consumer = this.registeredConsumers.get(queueName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "args",
    "snippet": "const args = params\n                .sort((a, b) => a.index - b.index)\n                .map(param => {\n                    switch (param.paramType) {\n                        case 'message':\n                            return data;\n                        case 'queueName':\n                            return queueName;\n                        case 'channel':\n                            return channel;\n                        default:\n                            return undefined;\n                    }\n                });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queueType",
    "snippet": "const queueType = Config.get<string>('queue.type', 'rabbitmq');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "channel",
    "snippet": "const channel =\n                                await instance.channels.get(channelName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = QueueService.getInstance();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "queueType",
    "snippet": "const queueType = Config.get<string>('queue.type', 'rabbitmq');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "channel",
    "snippet": "const channel = await instance.channels.get(channelName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/src/queue.service.ts",
    "type": "Constant",
    "value": "channel",
    "snippet": "const channel =\n                                await instance.channels.get(channelName);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/src/index.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = cmmv({\n        /*http2: true,\n        https: {\n            key: readFileSync(\"./cert/private-key.pem\"),\n            cert: readFileSync(\"./cert/certificate.pem\"),\n            passphrase: \"1234\"\n        }*/\n    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/src/index.ts",
    "type": "Constant",
    "value": "host",
    "snippet": "const host = '0.0.0.0';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/src/index.ts",
    "type": "Constant",
    "value": "port",
    "snippet": "const port = 3000;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/src/index.ts",
    "type": "Constant",
    "value": "schema",
    "snippet": "const schema = {\n            type: 'object',\n            properties: {\n                hello: {\n                    type: 'string',\n                },\n            },\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-starter/src/app.controller.ts",
    "type": "Class",
    "value": "AppController",
    "snippet": "@Controller()\nexport class AppController {\n    constructor(private readonly appService: AppService) {}\n\n    @Get()\n    getHello(): string {\n        return this.appService.getHello();\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-starter/src/app.module.ts",
    "type": "Constant",
    "value": "AppModule",
    "snippet": "const AppModule = new Module('app', {\n    controllers: [AppController],\n    providers: [AppService],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-starter/src/app.service.ts",
    "type": "Class",
    "value": "AppService",
    "snippet": "@Service('app')\nexport class AppService {\n    getHello(): string {\n        return 'Hello World!';\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-module/src/main.ts",
    "type": "Constant",
    "value": "CmmvModule",
    "snippet": "const CmmvModule = new Module('module', {\n  configs: [ModuleConfig],\n  providers: [ModuleService],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-module/src/module.config.ts",
    "type": "Constant",
    "value": "ModuleConfig",
    "snippet": "const ModuleConfig: ConfigSchema = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-typescript-module/src/module.service.ts",
    "type": "Class",
    "value": "ModuleService",
    "snippet": "@Service('queue')\nexport class ModuleService extends Singleton {\n  public logger: Logger = new Logger('ModuleService');\n\n  public static async loadConfig(application: Application): Promise<void> {}\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Function",
    "value": "cmmvPlugin",
    "snippet": "function cmmvPlugin(): Plugin {\r\n    return {\r\n        name: 'vite-plugin-cmmv',\r\n        transform(src, id) {\r\n            if (id.endsWith('.cmmv')) {\r\n                const templateMatch = src.match(/<template>([\\s\\S]*?)<\\/template>/);\r\n                const scriptMatch = src.match(/<script.*?>([\\s\\S]*?)<\\/script>/);\r\n                const styleMatch = src.match(/<style.*?>([\\s\\S]*?)<\\/style>/);\r\n\r\n                const template = templateMatch ? templateMatch[1].trim() : '';\r\n                const style = styleMatch ? styleMatch[1].trim() : '';                \r\n                let scriptContent = scriptMatch ? scriptMatch[1].trim() : '';\r\n\r\n                if (scriptContent.includes('export default')) {\r\n                    scriptContent = scriptContent.replace(\r\n                        /export default\\s*{([\\s\\S]*?)}/,\r\n                        `export default { template: \\`${template}\\`, styles: \\`${style}\\`, $1 }`\r\n                    );\r\n                }\r\n\r\n                return {\r\n                    code: scriptContent,\r\n                    map: null \r\n                };\r\n            }\r\n        },\r\n        load(id) {\r\n            if (id.endsWith('.cmmv')) {\r\n                return fs.readFileSync(path.resolve(id), 'utf-8');\r\n            }\r\n        }\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Constant",
    "value": "templateMatch",
    "snippet": "const templateMatch = src.match(/<template>([\\s\\S]*?)<\\/template>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Constant",
    "value": "scriptMatch",
    "snippet": "const scriptMatch = src.match(/<script.*?>([\\s\\S]*?)<\\/script>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Constant",
    "value": "styleMatch",
    "snippet": "const styleMatch = src.match(/<style.*?>([\\s\\S]*?)<\\/style>/);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Constant",
    "value": "template",
    "snippet": "const template = templateMatch ? templateMatch[1].trim() : '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-vite-plugin/src/index.ts",
    "type": "Constant",
    "value": "style",
    "snippet": "const style = styleMatch ? styleMatch[1].trim() : '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-cli/lib/utils/exec.util.ts",
    "type": "Constant",
    "value": "run",
    "snippet": "const run = async (bin, args, opts = {}) => {\r\n    const chalk = (await import('chalk')).default;\r\n    const { execa } = await import('execa');\r\n\r\n    try {\r\n        await execa(bin, args, { stdio: 'inherit', ...opts });\r\n    } catch (err) {\r\n        console.error(chalk.red(`Error running command: ${bin} ${args.join(' ')}`));\r\n        console.error(err.message);\r\n        process.exit(1);\r\n    }\r\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-cli/lib/utils/exec.util.ts",
    "type": "Constant",
    "value": "chalk",
    "snippet": "const chalk = (await import('chalk')).default;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Function",
    "value": "useApi",
    "snippet": "function useApi() {\r\n    const router = useRouter()\r\n    const user = ref<any>(null)\r\n    const token = ref<string | null>(localStorage.getItem('token') || null)\r\n    const isAuthenticated = computed(() => !!token.value)\r\n\r\n    const authRequest = async (path: string, method: string, payload: any) => {\r\n        try {\r\n            const response = await fetch(`api/${path}`, {\r\n                method: method,\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    Authorization: `Bearer ${token}`,\r\n                },\r\n                body: JSON.stringify(payload),\r\n            })\r\n\r\n            const data = await response.json()\r\n            return data\r\n        } catch (error) {\r\n            return { success: false, message: error }\r\n        }\r\n    }\r\n\r\n    const login = async (credentials: { username: string; password: string; token?: string }) => {\r\n        const response = await fetch(`api/auth/login`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(credentials),\r\n        })\r\n\r\n        const data = await response.json()\r\n\r\n        if (response.ok && data.result.token) {\r\n            localStorage.setItem('token', data.result.token)\r\n            token.value = data.result.token\r\n            return data.result\r\n        } else {\r\n            throw new Error(data.result.message || 'Login failed')\r\n        }\r\n    }\r\n\r\n    const logout = () => {\r\n        localStorage.removeItem('token')\r\n        token.value = null\r\n        user.value = null\r\n        router.push('/login')\r\n    }\r\n\r\n    const checkSession = async () => {}\r\n\r\n    const methods = {}\r\n\r\n    return {\r\n        user,\r\n        token,\r\n        isAuthenticated,\r\n        login,\r\n        logout,\r\n        ...methods,\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "router",
    "snippet": "const router = useRouter()"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "user",
    "snippet": "const user = ref<any>(null)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "token",
    "snippet": "const token = ref<string | null>(localStorage.getItem('token') || null)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "isAuthenticated",
    "snippet": "const isAuthenticated = computed(() => !!token.value)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "authRequest",
    "snippet": "const authRequest = async (path: string, method: string, payload: any) => {\r\n        try {\r\n            const response = await fetch(`api/${path}`, {\r\n                method: method,\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    Authorization: `Bearer ${token}`,\r\n                },\r\n                body: JSON.stringify(payload),\r\n            })\r\n\r\n            const data = await response.json()\r\n            return data\r\n        } catch (error) {\r\n            return { success: false, message: error }\r\n        }\r\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = await fetch(`api/${path}`, {\r\n                method: method,\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                    Authorization: `Bearer ${token}`,\r\n                },\r\n                body: JSON.stringify(payload),\r\n            })"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "data",
    "snippet": "const data = await response.json()"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "login",
    "snippet": "const login = async (credentials: { username: string; password: string; token?: string }) => {\r\n        const response = await fetch(`api/auth/login`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(credentials),\r\n        })\r\n\r\n        const data = await response.json()\r\n\r\n        if (response.ok && data.result.token) {\r\n            localStorage.setItem('token', data.result.token)\r\n            token.value = data.result.token\r\n            return data.result\r\n        } else {\r\n            throw new Error(data.result.message || 'Login failed')\r\n        }\r\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = await fetch(`api/auth/login`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify(credentials),\r\n        })"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "data",
    "snippet": "const data = await response.json()"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "logout",
    "snippet": "const logout = () => {\r\n        localStorage.removeItem('token')\r\n        token.value = null\r\n        user.value = null\r\n        router.push('/login')\r\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "checkSession",
    "snippet": "const checkSession = async () => {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/composable/useApi.ts",
    "type": "Constant",
    "value": "methods",
    "snippet": "const methods = {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/router/index.ts",
    "type": "Constant",
    "value": "router",
    "snippet": "const router = createRouter({\n    history: createWebHistory(import.meta.env.BASE_URL),\n    routes: [\n        {\n            path: '/',\n            name: 'login',\n            component: LoginView,\n        },\n        {\n            path: '/admin',\n            name: 'admin',\n            component: IndexView,\n        },\n    ],\n})"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/stores/counter.ts",
    "type": "Constant",
    "value": "useCounterStore",
    "snippet": "const useCounterStore = defineStore('counter', () => {\n    const count = ref(0)\n    const doubleCount = computed(() => count.value * 2)\n    function increment() {\n        count.value++\n    }\n\n    return { count, doubleCount, increment }\n})"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/stores/counter.ts",
    "type": "Constant",
    "value": "count",
    "snippet": "const count = ref(0)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/stores/counter.ts",
    "type": "Constant",
    "value": "doubleCount",
    "snippet": "const doubleCount = computed(() => count.value * 2)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/src/stores/counter.ts",
    "type": "Function",
    "value": "increment",
    "snippet": "function increment() {\n        count.value++\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/blueprints/AppInstance.blueprint.ts",
    "type": "Class",
    "value": "AppInstance",
    "snippet": "@CClass(\"AppInstance\")\nexport class AppInstance extends Instance {\n    \n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/blueprints/BP_Test.blueprint.ts",
    "type": "Interface",
    "value": "GenerateHashReturn",
    "snippet": "interface GenerateHashReturn {\n    result: Property<undefined>,\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/blueprints/BP_Test.blueprint.ts",
    "type": "Class",
    "value": "BP_Test",
    "snippet": "@CClass(\"BP_Test\")\nexport class BP_Test extends Blueprint {\n    \n    constructor(name?: string){\n        super(name);\n        this.beginPlay = new BeginPlay(this);\n    }\n\n    @CFunction({})\n    public async generateHash (): Promise<GenerateHashReturn> {\n        const generateHash = new AbstractFunction(this);\n\n        generateHash.set(\"tmpHash\", new Property<string>(\"\"));\n        const cryptNode = $.createNodeInstance<NodeCrypto>(\"crypto\");\n        generateHash.get(\"tmpHash\")?.link(cryptNode.result, Convert.IntToString);\n \n        cryptNode.next = generateHash.endNode();\n        await generateHash.await();\n        return { result: generateHash.get(\"tmpHash\") };\n    }\n\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/blueprints/BP_Test.blueprint.ts",
    "type": "Constant",
    "value": "generateHash",
    "snippet": "const generateHash = new AbstractFunction(this);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/src/blueprints/BP_Test.blueprint.ts",
    "type": "Constant",
    "value": "cryptNode",
    "snippet": "const cryptNode = $.createNodeInstance<NodeCrypto>(\"crypto\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/config.ts",
    "type": "Constant",
    "value": "source",
    "snippet": "const source = 'packages';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/config.ts",
    "type": "Constant",
    "value": "packagePaths",
    "snippet": "const packagePaths = getDirs(source);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "AbstractClass",
    "value": "AbstractParser",
    "snippet": "abstract class AbstractParser extends EventEmitter {\n    protected options: ParserOptions | XMLParserOptions | ParserBufferOptions;\n    protected pipes: Array<(data: any) => any | Promise<any>> = [];\n    protected schema: AbstractParserSchema;\n\n    constructor(\n        options?: ParserOptions | XMLParserOptions | ParserBufferOptions,\n    ) {\n        super();\n        this.options = options;\n        this.schema = new this.options.schema();\n    }\n\n    /**\n     * Adds a function or promise to the pipeline.\n     *\n     * @param fn A function or promise to process data.\n     * @returns The current instance for chaining.\n     */\n    public pipe(fn: (data: any) => any | Promise<any>): AbstractParser {\n        this.pipes.push(fn);\n        return this;\n    }\n\n    /**\n     * Parses and transforms raw data based on the provided schema.\n     *\n     * @param rawData The raw data object to parse and transform.\n     * @returns The transformed object or null if validation fails.\n     */\n    public async parser(rawData: any): Promise<any> {\n        if (!this.schema) throw new Error('Schema is required to parse data.');\n\n        const result: Record<string, any> = {};\n\n        for (const key in rawData) rawData[key.toLowerCase()] = rawData[key];\n\n        for (const [fieldName, fieldOptions] of Object.entries(\n            this.schema.field,\n        )) {\n            const { to, validation, transform } = fieldOptions;\n\n            let value = rawData[fieldName.toLowerCase()];\n\n            if (value !== undefined && value !== null) {\n                if (transform && Array.isArray(transform)) {\n                    for (const transformer of transform)\n                        value = transformer(value);\n                }\n\n                if (validation && !validation.test(value)) {\n                    console.warn(\n                        `Validation failed for field \"${fieldName}\" with value \"${value}\".`,\n                    );\n                    return null;\n                }\n            } else {\n                value = null;\n            }\n\n            if (to) result[to] = value;\n            else result[fieldName] = value;\n        }\n\n        if ('model' in this.options && this.options.model) {\n            let newObject: any = plainToClass(this.options.model, result, {\n                excludeExtraneousValues: true,\n                exposeUnsetFields: false,\n                enableImplicitConversion: true,\n            });\n\n            newObject = this.removeUndefinedWithConstructor(\n                newObject,\n                this.options.model,\n            );\n\n            for (const key in result) {\n                if (result[key] instanceof ObjectId)\n                    newObject[key] = result[key];\n            }\n\n            const errors = await validate(newObject, {\n                forbidUnknownValues: false,\n                skipMissingProperties: true,\n                stopAtFirstError: true,\n            });\n\n            if (errors.length > 0) throw new Error(errors[0].toString());\n\n            return newObject;\n        }\n\n        return result;\n    }\n\n    /**\n     * Removes undefined values from an object.\n     *\n     * @param obj The object to clean up.\n     * @returns A new object with undefined values removed.\n     */\n    private removeUndefinedWithConstructor<T>(\n        obj: T,\n        Constructor: new (partial: Partial<T>) => T,\n    ): T {\n        const cleanObj = Object.keys(obj).reduce((acc, key) => {\n            const value = obj[key as keyof T];\n            if (value !== undefined) {\n                (acc as any)[key] = value;\n            }\n            return acc;\n        }, {} as Partial<T>);\n\n        return new Constructor(cleanObj);\n    }\n\n    /**\n     * Processes data through all pipes sequentially.\n     *\n     * @param data The initial data to be processed.\n     * @returns The final processed result after all pipes.\n     */\n    public async processData(data: any): Promise<any> {\n        let result = await this.parser(data);\n\n        for (const pipe of this.pipes) {\n            if (typeof pipe === 'function') result = await pipe(result);\n            else throw new Error('Pipe is not a function.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Finalizes the process and emits the 'end' event.\n     */\n    public finalize(): void {\n        this.emit('end');\n    }\n\n    public error(error: any): void {\n        this.emit('erro', error);\n    }\n\n    /**\n     * Abstract method to be implemented by subclasses.\n     */\n    public start() {\n        throw new Error(\"Method 'start()' must be implemented.\");\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result: Record<string, any> = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "transformer",
    "snippet": "const transformer"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "errors",
    "snippet": "const errors = await validate(newObject, {\n                forbidUnknownValues: false,\n                skipMissingProperties: true,\n                stopAtFirstError: true,\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "cleanObj",
    "snippet": "const cleanObj = Object.keys(obj).reduce((acc, key) => {\n            const value = obj[key as keyof T];\n            if (value !== undefined) {\n                (acc as any)[key] = value;\n            }\n            return acc;\n        }, {} as Partial<T>);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "value",
    "snippet": "const value = obj[key as keyof T];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parser.abstract.ts",
    "type": "Constant",
    "value": "pipe",
    "snippet": "const pipe"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/abstracts/parserSchema.abstract.ts",
    "type": "AbstractClass",
    "value": "AbstractParserSchema",
    "snippet": "abstract class AbstractParserSchema {\n    public abstract field: Record<\n        string,\n        {\n            to: string;\n            validation?: RegExp;\n            transform?: Array<(value: any) => any>;\n        }\n    >;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/interfaces/parserOptions.interface.ts",
    "type": "Interface",
    "value": "ParserOptions",
    "snippet": "interface ParserOptions {\n    contract: new () => AbstractContract;\n    schema: new () => AbstractParserSchema;\n    model?: new (...args: any[]) => any;\n    input: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/interfaces/parserOptions.interface.ts",
    "type": "Interface",
    "value": "ParserBufferOptions",
    "snippet": "interface ParserBufferOptions {\n    schema: new () => AbstractParserSchema;\n    model?: new (...args: any[]) => any;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/interfaces/parserOptions.interface.ts",
    "type": "Interface",
    "value": "XMLParserOptions",
    "snippet": "interface XMLParserOptions {\n    contract: new () => AbstractContract;\n    schema: new () => AbstractParserSchema;\n    model?: new (...args: any[]) => any;\n    input: string;\n    nodeName: string;\n    strict?: boolean;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/interfaces/tokenizerOptions.interface.ts",
    "type": "Interface",
    "value": "TokenizerOptions",
    "snippet": "interface TokenizerOptions {\n    publicKey: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/models/customers.model.ts",
    "type": "Interface",
    "value": "ICustomers",
    "snippet": "interface ICustomers {\n    id?: any;\n    name: string;\n    phone: string;\n    createdAt: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/models/customers.model.ts",
    "type": "Class",
    "value": "Customers",
    "snippet": "class Customers implements ICustomers {\n    @Expose()\n    id?: any;\n\n    @Expose()\n    name: string;\n\n    @Expose()\n    phone: string;\n\n    @Expose()\n    @Type(() => Date)\n    createdAt: string;\n\n    constructor(partial: Partial<Customers>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize() {\n        return instanceToPlain(this);\n    }\n\n    public toString() {\n        return CustomersFastSchema(this);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/models/customers.model.ts",
    "type": "Constant",
    "value": "CustomersFastSchema",
    "snippet": "const CustomersFastSchema = fastJson({\n    title: 'Customers Schema',\n    type: 'object',\n    properties: {\n        name: { type: 'string' },\n        phone: { type: 'string' },\n        createdAt: { type: 'string' },\n    },\n    required: [],\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/json.parser.ts",
    "type": "Class",
    "value": "JSONParser",
    "snippet": "class JSONParser extends AbstractParser {\n    constructor(options?: ParserOptions | ParserBufferOptions) {\n        super(options);\n    }\n\n    public override start() {\n        if (\n            'input' in this.options &&\n            fs.existsSync(path.resolve(this.options.input))\n        ) {\n            const readStream = fs.createReadStream(\n                path.resolve(this.options.input),\n            );\n            const jsonStream = readStream.pipe(parser()).pipe(streamArray());\n            jsonStream.on('data', ({ value }) =>\n                this.processData.call(this, value),\n            );\n            jsonStream.on('end', this.finalize.bind(this));\n            jsonStream.on('error', error => this.error.bind(this, error));\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/json.parser.ts",
    "type": "Constant",
    "value": "readStream",
    "snippet": "const readStream = fs.createReadStream(\n                path.resolve(this.options.input),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/json.parser.ts",
    "type": "Constant",
    "value": "jsonStream",
    "snippet": "const jsonStream = readStream.pipe(parser()).pipe(streamArray());"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/xml.parser.ts",
    "type": "Class",
    "value": "XMLParser",
    "snippet": "class XMLParser extends AbstractParser {\n    declare protected options: XMLParserOptions;\n\n    constructor(options?: XMLParserOptions | ParserBufferOptions) {\n        super(options);\n    }\n\n    public override start() {\n        if (fs.existsSync(path.resolve(this.options.input))) {\n            const fileStream = createReadStream(\n                path.resolve(this.options.input),\n            );\n            const saxParser = new SAXParser(this.options.strict);\n\n            let currentElement: string | null = null;\n            let record: Record<string, any> = {};\n\n            saxParser.onopentag = node => {\n                currentElement = node.name;\n            };\n\n            saxParser.ontext = text => {\n                if (\n                    currentElement &&\n                    currentElement.toLowerCase() !==\n                        this.options.nodeName.toLowerCase()\n                ) {\n                    record[currentElement.toLowerCase()] = text.trim();\n                }\n            };\n\n            saxParser.onclosetag = nodeName => {\n                if (\n                    nodeName.toLowerCase() ===\n                    this.options.nodeName.toLowerCase()\n                ) {\n                    this.processData.call(this, record);\n                    record = {};\n                }\n\n                currentElement = null;\n            };\n\n            saxParser.onend = () => {\n                this.finalize.call(this);\n            };\n\n            saxParser.onerror = err => {\n                this.error.call(this, err);\n                saxParser.resume();\n            };\n\n            // @ts-ignore\n            fileStream.on('data', chunk => saxParser.write(chunk));\n            fileStream.on('end', () => saxParser.end());\n        } else {\n            console.error('Input file does not exist!');\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/xml.parser.ts",
    "type": "Constant",
    "value": "fileStream",
    "snippet": "const fileStream = createReadStream(\n                path.resolve(this.options.input),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/xml.parser.ts",
    "type": "Constant",
    "value": "saxParser",
    "snippet": "const saxParser = new SAXParser(this.options.strict);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/yaml.parser.ts",
    "type": "Class",
    "value": "YAMLParser",
    "snippet": "class YAMLParser extends AbstractParser {\n    private buffer: string;\n\n    constructor(options?: ParserOptions | ParserBufferOptions) {\n        super(options);\n        this.buffer = '';\n    }\n\n    public override start() {\n        if (\n            'input' in this.options &&\n            fs.existsSync(path.resolve(this.options.input))\n        ) {\n            const readStream = fs.createReadStream(\n                path.resolve(this.options.input),\n                {\n                    encoding: 'utf-8',\n                    highWaterMark: 1024 * 64, // 64KB buffer\n                },\n            );\n\n            readStream.on('data', chunk => {\n                this.buffer += chunk;\n\n                let boundary = this.buffer.lastIndexOf('\\n---');\n                if (boundary === -1) return;\n\n                const processChunk = this.buffer.slice(0, boundary);\n                this.buffer = this.buffer.slice(boundary + 4);\n\n                try {\n                    const documents = parse(processChunk);\n                    documents.forEach(doc => this.processData(doc));\n                } catch (error) {\n                    this.error(error);\n                }\n            });\n\n            readStream.on('end', () => {\n                if (this.buffer.trim()) {\n                    try {\n                        const documents = parse(this.buffer);\n                        documents.forEach(doc => this.processData(doc));\n                    } catch (error) {\n                        this.error(error);\n                    }\n                }\n\n                this.finalize.call(this);\n            });\n\n            readStream.on('error', error => this.error.call(this, error));\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/yaml.parser.ts",
    "type": "Constant",
    "value": "readStream",
    "snippet": "const readStream = fs.createReadStream(\n                path.resolve(this.options.input),\n                {\n                    encoding: 'utf-8',\n                    highWaterMark: 1024 * 64, // 64KB buffer\n                },\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/yaml.parser.ts",
    "type": "Constant",
    "value": "processChunk",
    "snippet": "const processChunk = this.buffer.slice(0, boundary);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/yaml.parser.ts",
    "type": "Constant",
    "value": "documents",
    "snippet": "const documents = parse(processChunk);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/parsers/yaml.parser.ts",
    "type": "Constant",
    "value": "documents",
    "snippet": "const documents = parse(this.buffer);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toBoolean.normalize.ts",
    "type": "Function",
    "value": "ToBoolean",
    "snippet": "function ToBoolean(input: string | number | boolean): boolean {\n    switch (typeof input) {\n        case 'string':\n            const lowerInput = input.trim().toLowerCase();\n            if (lowerInput === 'true' || lowerInput === '1') return true;\n            if (lowerInput === 'false' || lowerInput === '0') return false;\n            throw new Error(\n                `Unable to process 'ToBoolean' because the string \"${input}\" is not a valid boolean value.`,\n            );\n\n        case 'number':\n            if (input === 1) return true;\n            if (input === 0) return false;\n            throw new Error(\n                `Unable to process 'ToBoolean' because the number \"${input}\" is not a valid boolean value.`,\n            );\n\n        case 'boolean':\n            return input;\n\n        default:\n            throw new Error(\n                `Unable to process 'ToBoolean' because the input type \"${typeof input}\" is not supported.`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toBoolean.normalize.ts",
    "type": "Constant",
    "value": "lowerInput",
    "snippet": "const lowerInput = input.trim().toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toDate.normalize.ts",
    "type": "Function",
    "value": "ToDate",
    "snippet": "function ToDate(input: string) {\n    try {\n        return new Date(input);\n    } catch (err) {\n        throw new Error(\n            `Unable to process 'ToDate' because the input is not supported`,\n        );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toFixed.normalizer.ts",
    "type": "Function",
    "value": "ToFixed",
    "snippet": "function ToFixed(input: number): string {\n    if (typeof input === 'number') return input.toFixed();\n    else\n        throw new Error(\n            `Unable to process 'ToFixed' because the input is not supported`,\n        );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toFloat.normalize.ts",
    "type": "Function",
    "value": "ToFloat",
    "snippet": "function ToFloat(input: string | number): number {\n    switch (typeof input) {\n        case 'string':\n            const value = parseFloat(input);\n            return isNaN(value) ? null : value;\n            break;\n        case 'number':\n            return input;\n        default:\n            throw new Error(\n                `Unable to process 'ToFloat' because the input is not supported`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toFloat.normalize.ts",
    "type": "Constant",
    "value": "value",
    "snippet": "const value = parseFloat(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toInt.normalize.ts",
    "type": "Function",
    "value": "ToInt",
    "snippet": "function ToInt(input: string | number): number {\n    switch (typeof input) {\n        case 'string':\n            const value = parseInt(input);\n            return isNaN(value) ? null : value;\n            break;\n        case 'number':\n            return parseInt(input.toFixed());\n        default:\n            throw new Error(\n                `Unable to process 'ToInt' because the input is not supported`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toInt.normalize.ts",
    "type": "Constant",
    "value": "value",
    "snippet": "const value = parseInt(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toLowerCase.normalize.ts",
    "type": "Function",
    "value": "ToLowerCase",
    "snippet": "function ToLowerCase(input: string | number): string {\n    switch (typeof input) {\n        case 'string':\n            return input.toLowerCase();\n        case 'number':\n            return input.toString().toLowerCase();\n        default:\n            throw new Error(\n                `Unable to process 'ToLowerCase' because the input is not supported`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Function",
    "value": "numberToObjectId",
    "snippet": "function numberToObjectId(num: number): ObjectId {\n    if (num < 0 || num > 0xffffff)\n        throw new Error(\n            'Number must be a non-negative integer and fit within 3 bytes (0-16777215).',\n        );\n\n    const timestamp = Math.floor(Date.now() / 1000);\n    const randomBytes = crypto.randomBytes(5);\n    const counter = Buffer.alloc(3);\n    counter.writeUIntBE(num, 0, 3);\n\n    const objectIdBuffer = Buffer.concat([\n        Buffer.alloc(4).writeUIntBE(timestamp, 0, 4) && Buffer.alloc(4),\n        randomBytes,\n        counter,\n    ]);\n\n    return new ObjectId(objectIdBuffer);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Constant",
    "value": "timestamp",
    "snippet": "const timestamp = Math.floor(Date.now() / 1000);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Constant",
    "value": "randomBytes",
    "snippet": "const randomBytes = crypto.randomBytes(5);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Constant",
    "value": "counter",
    "snippet": "const counter = Buffer.alloc(3);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Constant",
    "value": "objectIdBuffer",
    "snippet": "const objectIdBuffer = Buffer.concat([\n        Buffer.alloc(4).writeUIntBE(timestamp, 0, 4) && Buffer.alloc(4),\n        randomBytes,\n        counter,\n    ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toObjectId.normalize.ts",
    "type": "Function",
    "value": "ToObjectId",
    "snippet": "function ToObjectId(input: string | number | ObjectId): ObjectId {\n    if (typeof input === 'number') return numberToObjectId(input);\n\n    if (input instanceof ObjectId) return input;\n\n    if (typeof input === 'string' && /^[a-fA-F0-9]{24}$/.test(input))\n        return new ObjectId(input);\n\n    throw new Error(`Invalid ObjectId input: ${input}`);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toString.normalize.ts",
    "type": "Function",
    "value": "ToString",
    "snippet": "function ToString(input: string | number | object) {\n    switch (typeof input) {\n        case 'string':\n            return input;\n        case 'number':\n            return input.toString();\n        case 'object':\n            return JSON.stringify(input);\n        default:\n            throw new Error(\n                `Unable to process 'ToString' because the input is not supported`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/toUpperCase.normalize.ts",
    "type": "Function",
    "value": "ToUpperCase",
    "snippet": "function ToUpperCase(input: string | number): string {\n    switch (typeof input) {\n        case 'string':\n            return input.toUpperCase();\n        case 'number':\n            return input.toString().toUpperCase();\n        default:\n            throw new Error(\n                `Unable to process 'ToUpperCase' because the input is not supported`,\n            );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/tokenizer.normalize.ts",
    "type": "Function",
    "value": "Tokenizer",
    "snippet": "function Tokenizer(options: TokenizerOptions) {\n    return (data: string | object) => {\n        if (typeof data == 'object') data = JSON.stringify(data);\n        const encrypted = Encryptor.encryptPayload(options.publicKey, data);\n        return JSON.stringify(encrypted);\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-normalizer/src/normalizers/tokenizer.normalize.ts",
    "type": "Constant",
    "value": "encrypted",
    "snippet": "const encrypted = Encryptor.encryptPayload(options.publicKey, data);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/sample/consumers/helloworld.consumer.ts",
    "type": "Class",
    "value": "HelloWorldConsumer",
    "snippet": "@Channel('hello-world', { durable: true })\nexport class HelloWorldConsumer {\n    constructor(private readonly queueService: QueueService) {}\n\n    @Consume('hello-world')\n    public async OnReciveMessage(\n        @QueueMessage() message,\n        @QueueChannel() channel,\n        @QueueConn() conn,\n    ) {\n        console.log('hello-world', message);\n        this.queueService.send('hello-world', 'niceday', 'NiceDay');\n    }\n\n    @Consume('niceday')\n    public async OnReciveHaveANiceDay(@QueueMessage() message) {\n        console.log('Have a nice day!');\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-queue/sample/consumers/samplepubsub.consumer.ts",
    "type": "Class",
    "value": "SamplePubSubConsumer",
    "snippet": "@Channel('broadcast', {\n    exchangeName: 'broadcast',\n    pubSub: true,\n})\nexport class SamplePubSubConsumer {\n    constructor(private readonly queueService: QueueService) {}\n\n    @Consume('broadcast')\n    public async OnReciveMessage(@QueueMessage() message) {\n        console.log('pubsub message: ', message);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "json",
    "snippet": "const json = async function (\n    options?: BodyParserJSONOptions,\n): Promise<any> {\n    const middleware = new BodyParserJSONMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserJSONMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "jsonExpress",
    "snippet": "const jsonExpress = function (options?: BodyParserJSONOptions): any {\n    const middleware = new BodyParserJSONMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserJSONMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "raw",
    "snippet": "const raw = async function (\n    options?: BodyParserRawOptions,\n): Promise<any> {\n    const middleware = new BodyParserRawMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserRawMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "rawExpress",
    "snippet": "const rawExpress = function (options?: BodyParserRawOptions): any {\n    const middleware = new BodyParserRawMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserRawMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "text",
    "snippet": "const text = async function (\n    options?: BodyParserTextOptions,\n): Promise<any> {\n    const middleware = new BodyParserTextMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserTextMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "textExpress",
    "snippet": "const textExpress = function (options?: BodyParserTextOptions): any {\n    const middleware = new BodyParserTextMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserTextMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "urlencoded",
    "snippet": "const urlencoded = async function (\n    options?: BodyParserUrlEncodedOptions,\n): Promise<any> {\n    const middleware = new BodyParserUrlEncodedMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserUrlEncodedMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "urlencodedExpress",
    "snippet": "const urlencodedExpress = function (\n    options?: BodyParserUrlEncodedOptions,\n): any {\n    const middleware = new BodyParserUrlEncodedMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserUrlEncodedMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "onHeaders",
    "snippet": "const onHeaders = require('on-headers');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Class",
    "value": "CompressionMiddleware",
    "snippet": "class CompressionMiddleware {\n    public middlewareName: string = 'compression';\n\n    private options: CompressionOptions;\n    private cache: Map<string, { buffer: Buffer; timestamp: number }> =\n        new Map();\n\n    constructor(options?: CompressionOptions) {\n        this.options = options || {};\n\n        this.options.threshold =\n            (options && options.threshold) || options?.threshold === 0\n                ? bytes.parse(options.threshold)\n                : 1024;\n\n        if (this.options.threshold == null) this.options.threshold = 1024;\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addHook == 'function')\n            req.app.addHook('onSend', this.cmmvMiddleware.bind(this));\n        else this.expressCompatibility.call(this, req, res, res.body, next);\n    }\n\n    async cmmvMiddleware(req, res, payload, done) {\n        try {\n            const accept = accepts(req as http.IncomingMessage);\n\n            let method = accept.encoding(['br', 'gzip', 'deflate', 'identity']);\n\n            if (this.filter(res) && this.shouldTransform(res)) {\n                vary(res as http.ServerResponse, 'Accept-Encoding');\n\n                if (req.method === 'HEAD') return;\n\n                const encoding =\n                    res.getHeader('Content-Encoding') || 'identity';\n                let contentLenght = payload.length;\n\n                if (\n                    (Number(contentLenght) < this.options.threshold &&\n                        !Number.isNaN(contentLenght)) ||\n                    (res instanceof Response &&\n                        payload.length < this.options.threshold)\n                ) {\n                    return payload;\n                }\n\n                if (!method || method === 'identity' || encoding !== 'identity')\n                    return payload;\n\n                const stream = this.createCompressionStream(method);\n\n                if (!stream) return payload;\n\n                if (typeof payload == 'string' || Buffer.isBuffer(payload)) {\n                    res.set('Content-Encoding', method);\n                    res.remove('Content-Length');\n\n                    const compressedBuffer = await this.compressData(\n                        Buffer.from(payload),\n                        stream,\n                    );\n\n                    return compressedBuffer;\n                }\n\n                return payload;\n            }\n        } catch (err) {\n            console.error(err);\n            return new Error(err.message);\n        }\n    }\n\n    expressCompatibility(req, res, next, opts) {\n        const filter = opts.filter || shouldCompress;\n\n        let ended = false;\n        let length;\n        let listeners = [];\n        let stream;\n\n        const _end = res.end;\n        const _on = res.on;\n        const _write = res.write;\n\n        res.flush = function flush() {\n            if (stream) stream.flush();\n        };\n\n        res.write = function write(chunk, encoding) {\n            if (ended) return false;\n\n            if (!this._header) this._implicitHeader();\n\n            return stream\n                ? stream.write(toBuffer(chunk, encoding))\n                : _write.call(this, chunk, encoding);\n        };\n\n        res.end = function end(chunk, encoding) {\n            if (ended) return false;\n\n            if (!this._header) {\n                // estimate the length\n                if (!this.getHeader('Content-Length'))\n                    length = chunkLength(chunk, encoding);\n\n                this._implicitHeader();\n            }\n\n            if (!stream) return _end.call(this, chunk, encoding);\n\n            // mark ended\n            ended = true;\n\n            // write Buffer for Node.js 0.8\n            return chunk ? stream.end(toBuffer(chunk, encoding)) : stream.end();\n        };\n\n        res.on = function on(type, listener) {\n            if (!listeners || type !== 'drain')\n                return _on.call(this, type, listener);\n\n            if (stream) return stream.on(type, listener);\n\n            // buffer listeners for future stream\n            listeners.push([type, listener]);\n\n            return this;\n        };\n\n        function nocompress(msg) {\n            addListeners(res, _on, listeners);\n            listeners = null;\n        }\n\n        onHeaders(res, function onResponseHeaders() {\n            if (!filter(req, res)) {\n                nocompress('filtered');\n                return;\n            }\n\n            if (!shouldTransform(req, res)) {\n                nocompress('no transform');\n                return;\n            }\n\n            vary(res, 'Accept-Encoding');\n\n            if (\n                Number(res.getHeader('Content-Length')) < opts.threshold ||\n                length < opts.threshold\n            ) {\n                nocompress('size below threshold');\n                return;\n            }\n\n            const encoding = res.getHeader('Content-Encoding') || 'identity';\n\n            if (encoding !== 'identity') {\n                nocompress('already encoded');\n                return;\n            }\n\n            if (req.method === 'HEAD') {\n                nocompress('HEAD request');\n                return;\n            }\n\n            const accept = accepts(req);\n            let method = accept.encoding(['gzip', 'deflate', 'identity']);\n\n            if (method === 'deflate' && accept.encoding(['gzip']))\n                method = accept.encoding(['gzip', 'identity']);\n\n            if (!method || method === 'identity') {\n                nocompress('not acceptable');\n                return;\n            }\n\n            stream =\n                method === 'gzip'\n                    ? zlib.createGzip(opts)\n                    : zlib.createDeflate(opts);\n\n            addListeners(stream, stream.on, listeners);\n\n            res.setHeader('Content-Encoding', method);\n            res.removeHeader('Content-Length');\n\n            stream.on('data', function onStreamData(chunk) {\n                if (_write.call(res, chunk) === false) stream.pause();\n            });\n\n            stream.on('end', function onStreamEnd() {\n                _end.call(res);\n            });\n\n            _on.call(res, 'drain', function onResponseDrain() {\n                stream.resume();\n            });\n        });\n    }\n\n    createCompressionStream(method: string) {\n        switch (method) {\n            case 'br':\n                return zlib.createBrotliCompress(this.options);\n            case 'gzip':\n                return zlib.createGzip(this.options);\n            case 'deflate':\n                return zlib.createDeflate(this.options);\n            default:\n                return null;\n        }\n    }\n\n    compressData(\n        inputBuffer: Buffer,\n        compressionStream: zlib.Gzip | zlib.Deflate,\n    ): Promise<Buffer> {\n        return new Promise<Buffer>((resolve, reject) => {\n            const chunks: Buffer[] = [];\n\n            if (compressionStream) {\n                compressionStream.on('data', chunk => chunks.push(chunk));\n                compressionStream.on('end', () =>\n                    resolve(Buffer.concat(chunks)),\n                );\n                compressionStream.on('error', err => reject(err));\n                compressionStream.end(inputBuffer);\n            } else {\n                reject('Compress method invalid!');\n            }\n        });\n    }\n\n    filter(res: any) {\n        try {\n            const type =\n                res.getHeader('Content-Type') || res.headers['Content-Type'];\n            return !(type === undefined || !compressible(type));\n        } catch {\n            return false;\n        }\n    }\n\n    shouldTransform(res: any) {\n        try {\n            const cacheControl = res?.getHeader('Cache-Control');\n            return (\n                !cacheControl ||\n                !/(?:^|,)\\s*?no-transform\\s*?(?:,|$)/.test(\n                    cacheControl as string,\n                )\n            );\n        } catch (err) {\n            console.error(err);\n        }\n    }\n\n    generateHash(encoding: string, body: Buffer): string {\n        const hash = crypto.createHash('md5');\n        hash.update(encoding + body.toString('base64'));\n        return hash.digest('hex');\n    }\n\n    flush() {\n        const now = Date.now();\n\n        this.cache.forEach((value, key) => {\n            if (now - value.timestamp >= this.options.cacheTimeout)\n                this.cache.delete(key);\n        });\n    }\n\n    /**\n     * Provide a async iteratable for Readable.from\n     */\n    async *intoAsyncIterator(payload) {\n        if (typeof payload === 'object') {\n            if (Buffer.isBuffer(payload)) {\n                yield payload;\n                return;\n            }\n\n            if (payload instanceof ArrayBuffer) {\n                yield Buffer.from(new Uint8Array(payload));\n                return;\n            }\n\n            if (ArrayBuffer.isView(payload)) {\n                yield Buffer.from(\n                    payload.buffer,\n                    payload.byteOffset,\n                    payload.byteLength,\n                );\n                return;\n            }\n\n            if (Symbol.iterator in payload) {\n                for (const chunk of payload) yield chunk;\n\n                return;\n            }\n\n            if (Symbol.asyncIterator in payload) {\n                for await (const chunk of payload) yield chunk;\n\n                return;\n            }\n        }\n\n        yield payload;\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "accept",
    "snippet": "const accept = accepts(req as http.IncomingMessage);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding =\n                    res.getHeader('Content-Encoding') || 'identity';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "stream",
    "snippet": "const stream = this.createCompressionStream(method);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "compressedBuffer",
    "snippet": "const compressedBuffer = await this.compressData(\n                        Buffer.from(payload),\n                        stream,\n                    );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "filter",
    "snippet": "const filter = opts.filter || shouldCompress;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "_end",
    "snippet": "const _end = res.end;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "_on",
    "snippet": "const _on = res.on;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "_write",
    "snippet": "const _write = res.write;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "nocompress",
    "snippet": "function nocompress(msg) {\n            addListeners(res, _on, listeners);\n            listeners = null;\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding = res.getHeader('Content-Encoding') || 'identity';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "accept",
    "snippet": "const accept = accepts(req);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "chunks",
    "snippet": "const chunks: Buffer[] = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type =\n                res.getHeader('Content-Type') || res.headers['Content-Type'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "cacheControl",
    "snippet": "const cacheControl = res?.getHeader('Cache-Control');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "hash",
    "snippet": "const hash = crypto.createHash('md5');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "now",
    "snippet": "const now = Date.now();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "chunk",
    "snippet": "const chunk"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "chunk",
    "snippet": "const chunk"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new CompressionMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "addListeners",
    "snippet": "function addListeners(stream, on, listeners) {\n    for (let i = 0; i < listeners.length; i++) {\n        on.apply(stream, listeners[i]);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "chunkLength",
    "snippet": "function chunkLength(chunk, encoding) {\n    if (!chunk) return 0;\n\n    return !Buffer.isBuffer(chunk)\n        ? Buffer.byteLength(chunk, encoding)\n        : chunk.length;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "shouldCompress",
    "snippet": "function shouldCompress(req, res) {\n    const type = res.getHeader('Content-Type');\n\n    if (type === undefined || !compressible(type)) return false;\n\n    return true;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = res.getHeader('Content-Type');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "shouldTransform",
    "snippet": "function shouldTransform(req, res) {\n    const cacheControlNoTransformRegExp = /(?:^|,)\\s*?no-transform\\s*?(?:,|$)/;\n    const cacheControl = res.getHeader('Cache-Control');\n\n    // Don't compress for Cache-Control: no-transform\n    // https://tools.ietf.org/html/rfc7234#section-5.2.2.4\n    return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "cacheControlNoTransformRegExp",
    "snippet": "const cacheControlNoTransformRegExp = /(?:^|,)\\s*?no-transform\\s*?(?:,|$)/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Constant",
    "value": "cacheControl",
    "snippet": "const cacheControl = res.getHeader('Cache-Control');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/compression/index.ts",
    "type": "Function",
    "value": "toBuffer",
    "snippet": "function toBuffer(chunk, encoding) {\n    return !Buffer.isBuffer(chunk) ? Buffer.from(chunk, encoding) : chunk;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Interface",
    "value": "CorsOptions",
    "snippet": "interface CorsOptions {\n    origin?: any;\n    methods?: string | string[];\n    preflightContinue?: boolean;\n    optionsSuccessStatus?: number;\n    credentials?: boolean;\n    maxAge?: number;\n    headers?: string | string[];\n    allowedHeaders?: string | string[];\n    exposedHeaders?: string | string[];\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Class",
    "value": "CorsMiddleware",
    "snippet": "class CorsMiddleware {\n    public middlewareName: string = 'cors';\n\n    private options: CorsOptions;\n\n    constructor(options?: CorsOptions) {\n        this.options = {\n            origin: options?.origin || '*',\n            methods: options?.methods || 'GET,HEAD,PUT,PATCH,POST,DELETE',\n            preflightContinue: options?.preflightContinue || false,\n            optionsSuccessStatus: options?.optionsSuccessStatus || 204,\n            credentials: options?.credentials || false,\n            maxAge: options?.maxAge || 0,\n            headers: options?.headers,\n            exposedHeaders: options?.exposedHeaders,\n            allowedHeaders: options?.allowedHeaders,\n        };\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addHook == 'function')\n            req.app.addHook('onSend', this.onCall.bind(this));\n        else this.onCall.call(this, req, res, res.body, next);\n    }\n\n    onCall(request, res, payload, done) {\n        let headers = [];\n        const method =\n            request.method &&\n            request.method.toUpperCase &&\n            request.method.toUpperCase();\n\n        if (method === 'OPTIONS') {\n            headers.push(this.configureOrigin(this.options, request));\n            headers.push(this.configureCredentials(this.options));\n            headers.push(this.configureMethods(this.options));\n            headers.push(this.configureAllowedHeaders(this.options, request));\n            headers.push(this.configureMaxAge(this.options));\n            headers.push(this.configureExposedHeaders(this.options));\n            this.applyHeaders(headers, res);\n\n            if (this.options.preflightContinue) {\n                done();\n            } else {\n                // Safari (and potentially other browsers) need content-length 0,\n                //   for 204 or they just hang waiting for a body\n                res.statusCode = this.options.optionsSuccessStatus;\n                res.setHeader('Content-Length', '0');\n                (res as http.ServerResponse).end();\n            }\n        } else {\n            headers.push(this.configureOrigin(this.options, request));\n            headers.push(this.configureCredentials(this.options));\n            headers.push(this.configureExposedHeaders(this.options));\n            this.applyHeaders(headers, res);\n\n            done();\n        }\n    }\n\n    isString(s) {\n        return typeof s === 'string' || s instanceof String;\n    }\n\n    isOriginAllowed(origin, allowedOrigin) {\n        if (Array.isArray(allowedOrigin)) {\n            for (var i = 0; i < allowedOrigin.length; ++i)\n                if (this.isOriginAllowed(origin, allowedOrigin[i])) return true;\n\n            return false;\n        } else if (this.isString(allowedOrigin)) {\n            return origin === allowedOrigin;\n        } else if (allowedOrigin instanceof RegExp) {\n            return allowedOrigin.test(origin);\n        } else {\n            return !!allowedOrigin;\n        }\n    }\n\n    configureOrigin(options, req) {\n        let requestOrigin = req.headers.origin,\n            headers = [],\n            isAllowed;\n\n        if (!options.origin || options.origin === '*') {\n            // allow any origin\n            headers.push([\n                {\n                    key: 'Access-Control-Allow-Origin',\n                    value: '*',\n                },\n            ]);\n        } else if (this.isString(options.origin)) {\n            // fixed origin\n            headers.push([\n                {\n                    key: 'Access-Control-Allow-Origin',\n                    value: options.origin,\n                },\n            ]);\n\n            headers.push([\n                {\n                    key: 'Vary',\n                    value: 'Origin',\n                },\n            ]);\n        } else {\n            isAllowed = this.isOriginAllowed(requestOrigin, options.origin);\n\n            // reflect origin\n            headers.push([\n                {\n                    key: 'Access-Control-Allow-Origin',\n                    value: isAllowed ? requestOrigin : false,\n                },\n            ]);\n\n            headers.push([\n                {\n                    key: 'Vary',\n                    value: 'Origin',\n                },\n            ]);\n        }\n\n        return headers;\n    }\n\n    configureMethods(options) {\n        var methods = options.methods;\n\n        if (methods.join) methods = options.methods.join(','); // .methods is an array, so turn it into a string\n\n        return {\n            key: 'Access-Control-Allow-Methods',\n            value: methods,\n        };\n    }\n\n    configureCredentials(options) {\n        if (options.credentials === true) {\n            return {\n                key: 'Access-Control-Allow-Credentials',\n                value: 'true',\n            };\n        }\n\n        return null;\n    }\n\n    configureAllowedHeaders(options, req) {\n        let allowedHeaders = options.allowedHeaders || options.headers;\n        const headers = [];\n\n        if (!allowedHeaders) {\n            allowedHeaders = req.headers['access-control-request-headers'];\n\n            headers.push([\n                {\n                    key: 'Vary',\n                    value: 'Access-Control-Request-Headers',\n                },\n            ]);\n        } else if (allowedHeaders.join) {\n            allowedHeaders = allowedHeaders.join(',');\n        }\n\n        if (allowedHeaders && allowedHeaders.length) {\n            headers.push([\n                {\n                    key: 'Access-Control-Allow-Headers',\n                    value: allowedHeaders,\n                },\n            ]);\n        }\n\n        return headers;\n    }\n\n    configureExposedHeaders(options) {\n        let headers = options.exposedHeaders;\n\n        if (!headers) return null;\n        else if (headers.join) headers = headers.join(','); // .headers is an array, so turn it into a string\n\n        if (headers && headers.length) {\n            return {\n                key: 'Access-Control-Expose-Headers',\n                value: headers,\n            };\n        }\n\n        return null;\n    }\n\n    configureMaxAge(options) {\n        const maxAge =\n            (typeof options.maxAge === 'number' || options.maxAge) &&\n            options.maxAge.toString();\n\n        if (maxAge && maxAge.length) {\n            return {\n                key: 'Access-Control-Max-Age',\n                value: maxAge,\n            };\n        }\n\n        return null;\n    }\n\n    applyHeaders(headers, res) {\n        try {\n            for (let i = 0, n = headers.length; i < n; i++) {\n                let header = headers[i];\n\n                if (header) {\n                    if (Array.isArray(header)) this.applyHeaders(header, res);\n                    else if (header.key === 'Vary' && header.value)\n                        vary(res, header.value);\n                    else if (header.value && typeof res.set === 'function')\n                        res.set(header.key, header.value);\n                    else if (\n                        header.value &&\n                        typeof res.setHeader === 'function'\n                    )\n                        res.setHeader(header.key, header.value);\n                }\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method =\n            request.method &&\n            request.method.toUpperCase &&\n            request.method.toUpperCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "headers",
    "snippet": "const headers = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "maxAge",
    "snippet": "const maxAge =\n            (typeof options.maxAge === 'number' || options.maxAge) &&\n            options.maxAge.toString();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new CorsMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "cors",
    "snippet": "const cors = function (options?: CorsOptions | Function) {\n    let middleware =\n        typeof options !== 'function'\n            ? new CorsMiddleware(options)\n            : new CorsMiddleware();\n\n    if (typeof options === 'function') {\n        let optionsCallback = null;\n\n        const defaults = {\n            origin: '*',\n            methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n            preflightContinue: false,\n            optionsSuccessStatus: 204,\n        };\n\n        if (typeof options === 'function') {\n            optionsCallback = options;\n        } else {\n            optionsCallback = function (req, cb) {\n                cb(null, options);\n            };\n        }\n\n        return function corsMiddleware(req, res, next) {\n            optionsCallback(req, function (err, options) {\n                if (err) {\n                    next(err);\n                } else {\n                    var corsOptions = assign({}, defaults, options);\n                    var originCallback = null;\n\n                    if (\n                        corsOptions.origin &&\n                        typeof corsOptions.origin === 'function'\n                    ) {\n                        originCallback = corsOptions.origin;\n                    } else if (corsOptions.origin) {\n                        originCallback = function (origin, cb) {\n                            cb(null, corsOptions.origin);\n                        };\n                    }\n\n                    if (originCallback) {\n                        originCallback(\n                            req.headers.origin,\n                            function (err2, origin) {\n                                if (err2 || !origin) {\n                                    next(err2);\n                                } else {\n                                    corsOptions.origin = origin;\n                                    middleware = new CorsMiddleware(\n                                        corsOptions,\n                                    );\n                                    middleware.process(req, res, next);\n                                }\n                            },\n                        );\n                    } else {\n                        next();\n                    }\n                }\n            });\n        };\n    } else return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cors/index.ts",
    "type": "Constant",
    "value": "defaults",
    "snippet": "const defaults = {\n            origin: '*',\n            methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',\n            preflightContinue: false,\n            optionsSuccessStatus: 204,\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Class",
    "value": "CookieParserMiddleware",
    "snippet": "class CookieParserMiddleware {\n    public middlewareName: string = 'cookie-parser';\n\n    private options: CookieParserOptions;\n\n    constructor(options: CookieParserOptions) {\n        this.options = options || {};\n        this.options.secret =\n            !options?.secret || Array.isArray(options?.secret)\n                ? options?.secret || []\n                : [options?.secret];\n    }\n\n    async process(req, res, next) {\n        if (req.app && typeof req.app.addHook == 'function')\n            req.app.addHook('onRequest', this.onCall.bind(this));\n        else this.onCall.call(this, req, res, null, next);\n    }\n\n    async onCall(req, res, payload, done) {\n        if (req.cookies) {\n            if (done) done();\n            return;\n        }\n\n        const cookies = req.headers.cookie;\n\n        req.secret = this.options.secret[0];\n        req.cookies = Object.create(null);\n        req.signedCookies = Object.create(null);\n\n        if (!cookies) {\n            if (done) done();\n            return;\n        }\n\n        req.cookies = cookie.parse(cookies, this.options);\n\n        if (this.options.secret.length !== 0) {\n            req.signedCookies = signedCookies(req.cookies, this.options.secret);\n            req.signedCookies = JSONCookies(req.signedCookies);\n        }\n\n        req.cookies = JSONCookies(req.cookies);\n\n        if (done) done();\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "cookies",
    "snippet": "const cookies = req.headers.cookie;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new CookieParserMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "cookieParser",
    "snippet": "const cookieParser = function (options?: CookieParserOptions) {\n    const middleware = new CookieParserMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new CookieParserMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "JSONCookies",
    "snippet": "const JSONCookies = obj => {\n    const cookies = Object.keys(obj);\n    let key;\n    let val;\n\n    for (let i = 0; i < cookies.length; i++) {\n        key = cookies[i];\n        val = JSONCookie(obj[key]);\n\n        if (val) obj[key] = val;\n    }\n\n    return obj;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "cookies",
    "snippet": "const cookies = Object.keys(obj);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "JSONCookie",
    "snippet": "const JSONCookie = (str?: any) => {\n    if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') return undefined;\n\n    try {\n        return JSON.parse(str.slice(2));\n    } catch (err) {\n        return undefined;\n    }\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "signedCookie",
    "snippet": "const signedCookie = (\n    str: any,\n    secret: string | string[],\n): string | boolean => {\n    if (typeof str !== 'string') return undefined;\n\n    if (str.substr(0, 2) !== 's:') return str;\n\n    const secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];\n\n    for (let i = 0; i < secrets.length; i++) {\n        const val = unsign(str.slice(2), secrets[i]);\n\n        if (val !== false) return val;\n    }\n\n    return false;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "secrets",
    "snippet": "const secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "val",
    "snippet": "const val = unsign(str.slice(2), secrets[i]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "signedCookies",
    "snippet": "const signedCookies = (obj: Object, secret: string | string[]) => {\n    const cookies = Object.keys(obj);\n    const ret = {};\n    let dec;\n    let key;\n    let val;\n\n    for (let i = 0; i < cookies.length; i++) {\n        key = cookies[i];\n        val = obj[key];\n        dec = signedCookie(val, secret);\n\n        if (val !== dec) {\n            ret[key] = dec;\n            delete obj[key];\n        }\n    }\n\n    return ret;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "cookies",
    "snippet": "const cookies = Object.keys(obj);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "ret",
    "snippet": "const ret = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "sign",
    "snippet": "const sign = (val, secret) => {\n    if ('string' != typeof val)\n        throw new TypeError('Cookie value must be provided as a string.');\n    if (null == secret) throw new TypeError('Secret key must be provided.');\n    return (\n        val +\n        '.' +\n        crypto\n            .createHmac('sha256', secret)\n            .update(val)\n            .digest('base64')\n            .replace(/\\=+$/, '')\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "unsign",
    "snippet": "const unsign = (input, secret) => {\n    if ('string' != typeof input)\n        throw new TypeError('Signed cookie string must be provided.');\n    if (null == secret) throw new TypeError('Secret key must be provided.');\n    const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);\n\n    return expectedBuffer.length === inputBuffer.length &&\n        crypto.timingSafeEqual(\n            new Uint8Array(expectedBuffer),\n            new Uint8Array(inputBuffer),\n        )\n        ? tentativeValue\n        : false;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "tentativeValue",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "expectedInput",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "expectedBuffer",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/cookie-parser/index.ts",
    "type": "Constant",
    "value": "inputBuffer",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "Helmet",
    "snippet": "const Helmet = require('helmet');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Class",
    "value": "HelmetMiddleware",
    "snippet": "class HelmetMiddleware {\n    public middlewareName: string = 'helmet';\n\n    protected options: HelmetOptions;\n\n    constructor(options?: HelmetOptions) {\n        this.options = options || {};\n    }\n\n    async process(req, res, next) {\n        if (req) {\n            if (req && req.app && typeof req.app.addHook == 'function')\n                req.app.addHook('onSend', this.onCall.bind(this));\n            else this.onCall.call(this, req, res, null, next);\n        }\n    }\n\n    async onCall(request, response, payload, done) {\n        if (response.headersSent === true) return;\n\n        if (this.options.contentSecurityPolicy !== false) {\n            const cspDirectives =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.directives\n                    : Helmet.contentSecurityPolicy?.getDefaultDirectives();\n            const cspReportOnly =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.reportOnly\n                    : undefined;\n            const cspUseDefaults =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.useDefaults\n                    : undefined;\n\n            const directives: any = { ...cspDirectives };\n\n            if (response.cspNonce) {\n                const { script: scriptCSPNonce, style: styleCSPNonce } =\n                    response.cspNonce;\n\n                const scriptKey = Array.isArray(directives['script-src'])\n                    ? 'script-src'\n                    : 'scriptSrc';\n                directives[scriptKey] = Array.isArray(directives[scriptKey])\n                    ? [...directives[scriptKey]]\n                    : [];\n                directives[scriptKey].push(`'nonce-${scriptCSPNonce}'`);\n\n                const styleKey = Array.isArray(directives['style-src'])\n                    ? 'style-src'\n                    : 'styleSrc';\n                directives[styleKey] = Array.isArray(directives[styleKey])\n                    ? [...directives[styleKey]]\n                    : [];\n                directives[styleKey].push(`'nonce-${styleCSPNonce}'`);\n            }\n\n            const contentSecurityPolicy = {\n                directives,\n                reportOnly: cspReportOnly,\n                useDefaults: cspUseDefaults,\n            };\n\n            const mergedHelmetConfiguration = Object.assign(\n                Object.create(null),\n                this.options,\n                { contentSecurityPolicy },\n            );\n\n            Helmet(mergedHelmetConfiguration)(request.req, response.res, done);\n        } else {\n            Helmet(this.options)(request.req, response.res, done);\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "cspDirectives",
    "snippet": "const cspDirectives =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.directives\n                    : Helmet.contentSecurityPolicy?.getDefaultDirectives();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "cspReportOnly",
    "snippet": "const cspReportOnly =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.reportOnly\n                    : undefined;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "cspUseDefaults",
    "snippet": "const cspUseDefaults =\n                this.options.contentSecurityPolicy &&\n                typeof this.options.contentSecurityPolicy !== 'boolean'\n                    ? this.options.contentSecurityPolicy.useDefaults\n                    : undefined;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "directives",
    "snippet": "const directives: any = { ...cspDirectives };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "scriptKey",
    "snippet": "const scriptKey = Array.isArray(directives['script-src'])\n                    ? 'script-src'\n                    : 'scriptSrc';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "styleKey",
    "snippet": "const styleKey = Array.isArray(directives['style-src'])\n                    ? 'style-src'\n                    : 'styleSrc';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "contentSecurityPolicy",
    "snippet": "const contentSecurityPolicy = {\n                directives,\n                reportOnly: cspReportOnly,\n                useDefaults: cspUseDefaults,\n            };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "mergedHelmetConfiguration",
    "snippet": "const mergedHelmetConfiguration = Object.assign(\n                Object.create(null),\n                this.options,\n                { contentSecurityPolicy },\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new HelmetMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "helmet",
    "snippet": "const helmet = function (options?: HelmetOptions) {\n    const middleware = new HelmetMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/helmet/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new HelmetMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/fnv1a.ts",
    "type": "Constant",
    "value": "OFFSET_BASIS_32",
    "snippet": "const OFFSET_BASIS_32 = 2166136261;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/fnv1a.ts",
    "type": "Function",
    "value": "fnv1aString",
    "snippet": "function fnv1aString(string) {\n    let hash = OFFSET_BASIS_32;\n\n    for (let i = 0; i < string.length; i++) {\n        hash ^= string.charCodeAt(i);\n        hash +=\n            (hash << 1) +\n            (hash << 4) +\n            (hash << 7) +\n            (hash << 8) +\n            (hash << 24);\n    }\n\n    return hash >>> 0;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/fnv1a.ts",
    "type": "Function",
    "value": "fnv1aBuffer",
    "snippet": "function fnv1aBuffer(buf) {\n    let hash = OFFSET_BASIS_32;\n\n    for (let i = 0; i < buf.length; ) {\n        hash ^= buf[i++];\n        hash +=\n            (hash << 1) +\n            (hash << 4) +\n            (hash << 7) +\n            (hash << 8) +\n            (hash << 24);\n    }\n\n    return hash >>> 0;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/fnv1a.ts",
    "type": "Constant",
    "value": "fnv1a",
    "snippet": "const fnv1a = input => {\n    if (input instanceof Buffer) {\n        return fnv1aBuffer(input);\n    } else if (typeof input === 'string') {\n        return fnv1aString(input);\n    } else {\n        throw new Error('input must be a string or a Buffer');\n    }\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Interface",
    "value": "ETagOptions",
    "snippet": "interface ETagOptions {\n    algorithm?: string;\n    weak?: boolean;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Class",
    "value": "EtagMiddleware",
    "snippet": "class EtagMiddleware {\n    public middlewareName: string = 'etag';\n\n    protected options: ETagOptions;\n\n    constructor(options?: ETagOptions) {\n        this.options = {\n            algorithm: options?.algorithm || 'sha1',\n            weak: Boolean(options?.weak === true),\n        };\n    }\n\n    async process(req, res, next) {\n        if (req.app && typeof req.app.addHook == 'function')\n            req.app.addHook('onSend', this.onCall.bind(this));\n        else this.onCall.call(this, req, res, res.body, next);\n    }\n\n    onCall(req, res, payload, done) {\n        const hash = this.buildHashFn(\n            this.options.algorithm,\n            this.options.weak,\n        );\n        let etag = res.getHeader('etag');\n        let newPayload;\n\n        if (!etag) {\n            if (!(typeof payload === 'string' || payload instanceof Buffer)) {\n                done(null, newPayload);\n                return;\n            }\n\n            etag = hash(payload);\n            res.set('etag', etag);\n        }\n\n        if (\n            req.headers['if-none-match'] === etag ||\n            req.headers['if-none-match'] === 'W/' + etag ||\n            'W/' + req.headers['if-none-match'] === etag\n        ) {\n            res.code(304);\n            newPayload = '';\n        }\n\n        done(null, newPayload);\n    }\n\n    buildHashFn(algorithm = 'sha1', weak = false) {\n        this.validateAlgorithm(algorithm);\n\n        const prefix = weak ? 'W/\"' : '\"';\n\n        if (algorithm === 'fnv1a')\n            return payload => prefix + fnv1a(payload).toString(36) + '\"';\n\n        return payload =>\n            prefix +\n            createHash(algorithm).update(payload).digest('base64') +\n            '\"';\n    }\n\n    validateAlgorithm(algorithm) {\n        if (algorithm === 'fnv1a') return true;\n\n        try {\n            createHash(algorithm);\n        } catch (e) {\n            throw new TypeError(`Algorithm ${algorithm} not supported.`);\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Constant",
    "value": "hash",
    "snippet": "const hash = this.buildHashFn(\n            this.options.algorithm,\n            this.options.weak,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Constant",
    "value": "prefix",
    "snippet": "const prefix = weak ? 'W/\"' : '\"';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new EtagMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Constant",
    "value": "etag",
    "snippet": "const etag = function (options?: ETagOptions) {\n    const middleware = new EtagMiddleware(options);\n    return (req, res, next) => middleware.process(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/etag/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new EtagMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Function",
    "value": "CmmvServer",
    "snippet": "function CmmvServer(this: any, options?): any {\n    const { server, listen } = app(options);\n    const props = server.props?.slice();\n\n    let _Server: any = { server };\n    Object.setPrototypeOf(_Server, server);\n\n    _Server.props = props;\n    _Server.listen = (listenOptions: { host: string; port: number }) => {\n        return new Promise((resolve, reject) => {\n            try {\n                setTimeout(() => {\n                    server.on('error', reject);\n                    server.on('listening', () => {\n                        resolve(server);\n                        onListenHookRunner(server);\n                    });\n                    listen(listenOptions);\n                }, 100);\n            } catch (err) {\n                reject(err);\n            }\n        });\n    };\n\n    return _Server;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "props",
    "snippet": "const props = server.props?.slice();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "application",
    "snippet": "const application = app;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "json",
    "snippet": "const json = bodyParserJSON;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "urlencoded",
    "snippet": "const urlencoded = bodyParserURLEncoded;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "text",
    "snippet": "const text = bodyParserText;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "raw",
    "snippet": "const raw = bodyParserRaw;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "serverStatic",
    "snippet": "const serverStatic = ss;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "Router",
    "snippet": "const Router = router;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "Route",
    "snippet": "const Route = router;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "request",
    "snippet": "const request = require('./lib/request');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = require('./lib/response');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/index.ts",
    "type": "Constant",
    "value": "utils",
    "snippet": "const utils = Utils;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Interface",
    "value": "StaticOptions",
    "snippet": "interface StaticOptions {\n    root?: string;\n    prefix?: string;\n    maxAge?: number;\n    cacheControl?: boolean;\n    dotfiles?: 'allow' | 'deny' | 'ignore';\n    serverDotfiles?: boolean;\n    index?: string | boolean;\n    fallthrough?: boolean;\n    redirect?: boolean;\n    immutable?: boolean;\n    lastModified?: boolean;\n    etag?: boolean;\n    extensions?: any;\n    acceptRanges?: boolean;\n    preCompressed?: boolean;\n    allowedPath?: any;\n    setHeaders?: (res, path, stat) => void;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Function",
    "value": "createHtmlDocument",
    "snippet": "function createHtmlDocument(title, body) {\n    return (\n        '<!DOCTYPE html>\\n' +\n        '<html lang=\"en\">\\n' +\n        '<head>\\n' +\n        '<meta charset=\"utf-8\">\\n' +\n        '<title>' +\n        title +\n        '</title>\\n' +\n        '</head>\\n' +\n        '<body>\\n' +\n        '<pre>' +\n        body +\n        '</pre>\\n' +\n        '</body>\\n' +\n        '</html>\\n'\n    );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Function",
    "value": "collapseLeadingSlashes",
    "snippet": "function collapseLeadingSlashes(str) {\n    let i;\n\n    for (i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) !== 0x2f) break;\n    }\n\n    return i > 1 ? '/' + str.substr(i) : str;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Class",
    "value": "ServerStaticMiddleware",
    "snippet": "class ServerStaticMiddleware {\n    public middlewareName: string = 'server-static';\n\n    private app: any;\n    private root: string | string[];\n    private options: StaticOptions;\n\n    constructor(root: string | string[], options?: StaticOptions) {\n        this.root = root;\n\n        this.options = {\n            etag: options?.etag ?? true,\n            prefix: options?.prefix ?? '/',\n            maxAge: options?.maxAge ?? 0,\n            cacheControl: options?.cacheControl ?? true,\n            dotfiles: options?.dotfiles || 'allow',\n            index:\n                options?.index || options?.index === false\n                    ? options?.index\n                    : 'index.html',\n            fallthrough: options?.fallthrough !== false,\n            redirect: options?.redirect !== false,\n            immutable: options?.immutable ?? false,\n            lastModified: options?.lastModified ?? true,\n            extensions: options?.extensions || false,\n            acceptRanges: options?.acceptRanges ?? true,\n            preCompressed: options?.preCompressed ?? false,\n            serverDotfiles: options?.serverDotfiles ?? false,\n            setHeaders: options?.setHeaders ?? null,\n            allowedPath: options?.allowedPath ?? null,\n        };\n    }\n\n    async process(server, done) {\n        if (server && typeof server.app.addHook == 'function') {\n            this.app = server.app;\n            server.app.addHook('onListen', this.onCall.bind(this));\n        }\n        //else this.onCall.call(this, server, done);\n    }\n\n    async onCall() {\n        const indexes =\n            this.options.index === undefined\n                ? ['index.html']\n                : [].concat(this.options.index);\n        const indexDirs = new Map();\n        const routes = new Set();\n        const roots = Array.isArray(this.root) ? this.root : [this.root];\n\n        const routeOpts = {\n            errorHandler(error, request, reply) {\n                if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n                    reply.request.raw.destroy();\n                    return;\n                }\n            },\n        };\n\n        for (let rootPath of roots) {\n            rootPath = rootPath.split(path.win32.sep).join(path.posix.sep);\n            !rootPath.endsWith('/') && (rootPath += '/');\n\n            const files = await fg(['**/**'], {\n                cwd: rootPath,\n                absolute: false,\n                followSymbolicLinks: true,\n                onlyFiles: true,\n                dot: this.options.serverDotfiles,\n            });\n\n            for (let file of files) {\n                file = file.split(path.win32.sep).join(path.posix.sep);\n                const route = this.options.prefix + file;\n\n                if (routes.has(route)) continue;\n\n                routes.add(route);\n\n                this.setUpHeadAndGet(routeOpts, route, `/${file}`, rootPath);\n\n                const key = path.posix.basename(route);\n\n                if (indexes.includes(key) && !indexDirs.has(key))\n                    indexDirs.set(path.posix.dirname(route), rootPath);\n            }\n        }\n    }\n\n    setUpHeadAndGet(routeOpts, route, file, rootPath) {\n        const toSetUp = Object.assign({}, routeOpts, {\n            method: ['HEAD', 'GET'],\n            url: route,\n            handler: this.serveFileHandler.bind(this),\n        });\n        toSetUp.config = toSetUp.config || {};\n        toSetUp.config.file = file;\n        toSetUp.config.rootPath = rootPath;\n        this.app.addRoute(toSetUp);\n    }\n\n    async serveFileHandler(req, res) {\n        // TODO: remove the fallback branch when bump major\n        /* c8 ignore next */\n        const routeConfig = req.routeOptions?.config || req.routeConfig;\n        return this.pumpSendToReply(\n            req,\n            res,\n            routeConfig.file,\n            routeConfig.rootPath,\n        );\n    }\n\n    async pumpSendToReply(\n        req,\n        res,\n        pathname,\n        rootPath,\n        rootPathOffset = 0,\n        pumpOptions?,\n        checkedEncodings?,\n    ) {\n        const sendOptions = {\n            root: this.options.root,\n            acceptRanges: this.options.acceptRanges,\n            cacheControl: this.options.cacheControl,\n            dotfiles: this.options.dotfiles,\n            etag: this.options.etag,\n            extensions: this.options.extensions,\n            immutable: this.options.immutable,\n            index: this.options.index,\n            lastModified: this.options.lastModified,\n            maxAge: this.options.maxAge,\n        };\n        const setHeaders = this.options.setHeaders;\n\n        if (\n            setHeaders !== undefined &&\n            setHeaders !== null &&\n            typeof setHeaders !== 'function'\n        )\n            throw new TypeError('The `setHeaders` option must be a function');\n\n        const allowedPath = this.options.allowedPath;\n        const pathnameOrig = pathname;\n        const options = Object.assign({}, sendOptions, pumpOptions);\n\n        if (rootPath) {\n            if (Array.isArray(rootPath)) {\n                options.root = rootPath[rootPathOffset];\n            } else {\n                options.root = rootPath;\n            }\n        }\n\n        if (allowedPath && !allowedPath(pathname, options.root, req)) {\n            return res.callNotFound();\n        }\n\n        let encoding;\n        let pathnameForSend = pathname;\n\n        if (this.options.preCompressed) {\n            /**\n             * We conditionally create this structure to track our attempts\n             * at sending pre-compressed assets\n             */\n            if (!checkedEncodings) checkedEncodings = new Set();\n\n            encoding = this.getEncodingHeader(\n                req.req.headers,\n                checkedEncodings,\n            );\n\n            if (encoding) {\n                if (pathname.endsWith('/')) {\n                    pathname = this.findIndexFile(\n                        pathname,\n                        options.root,\n                        options.index,\n                    );\n\n                    if (!pathname) return req.callNotFound();\n\n                    pathnameForSend =\n                        pathnameForSend +\n                        pathname +\n                        '.' +\n                        this.getEncodingExtension(encoding);\n                } else {\n                    pathnameForSend =\n                        pathname + '.' + this.getEncodingExtension(encoding);\n                }\n            }\n        }\n\n        const { statusCode, headers, stream, type, metadata } = await send(\n            req.req,\n            encodeURI(pathnameForSend),\n            options,\n        );\n\n        switch (type) {\n            case 'file': {\n                if (\n                    setHeaders !== undefined &&\n                    typeof setHeaders === 'function'\n                )\n                    setHeaders(res.res, metadata.path, metadata.stat);\n\n                if (encoding) {\n                    res.set('content-type', this.getContentType(pathname));\n                    res.set('content-encoding', encoding);\n                } else {\n                    res.set('content-type', this.getContentType(pathname));\n                }\n\n                const buffer = await this.streamToBuffer(stream);\n                await res.send(buffer);\n\n                break;\n            }\n        }\n    }\n\n    async streamToBuffer(stream) {\n        return new Promise((resolve, reject) => {\n            const chunks = [];\n            stream.on('data', chunk => chunks.push(chunk));\n            stream.on('end', () => resolve(Buffer.concat(chunks)));\n            stream.on('error', err => reject(err));\n        });\n    }\n\n    async compressData(\n        inputBuffer: Buffer,\n        compressionStream: zlib.Gzip | zlib.Deflate,\n    ): Promise<Buffer> {\n        return new Promise<Buffer>((resolve, reject) => {\n            const chunks: Buffer[] = [];\n            compressionStream.on('data', chunk => chunks.push(chunk));\n            compressionStream.on('end', () => resolve(Buffer.concat(chunks)));\n            compressionStream.on('error', err => reject(err));\n            compressionStream.end(inputBuffer);\n        });\n    }\n\n    createNotFoundDirectoryListener() {\n        return function notFound(this: any) {\n            this.error(404);\n        };\n    }\n\n    createRedirectDirectoryListener() {\n        return function redirect(this: any, res: any) {\n            if (this.hasTrailingSlash()) {\n                this.error(404);\n                return;\n            }\n\n            const originalUrl = parseUrl.original(this.req);\n\n            originalUrl.path = null;\n            originalUrl.pathname = collapseLeadingSlashes(\n                originalUrl.pathname + '/',\n            );\n\n            const loc = encodeUrl(url.format(originalUrl));\n            const doc = createHtmlDocument(\n                'Redirecting',\n                'Redirecting to ' + escapeHtml(loc),\n            );\n\n            res.statusCode = 301;\n            res.setHeader('Content-Type', 'text/html; charset=UTF-8');\n            res.setHeader('Content-Length', Buffer.byteLength(doc));\n            res.setHeader('Content-Security-Policy', \"default-src 'none'\");\n            res.setHeader('X-Content-Type-Options', 'nosniff');\n            res.setHeader('Location', loc);\n            res.end(doc);\n        };\n    }\n\n    getContentType(path) {\n        if (path.endsWith('.vue') || path.endsWith('.cmmv')) {\n            return `text/javascript`;\n        } else {\n            const type = mime.getType(path) || 'application/octet-stream';\n\n            if (!send.isUtf8MimeType(type)) return type;\n\n            return `${type}; charset=UTF-8`;\n        }\n    }\n\n    getEncodingHeader(headers, checked) {\n        if (!('accept-encoding' in headers)) return;\n\n        const asteriskRegex = /\\*/gu;\n\n        // consider the no-preference token as gzip for downstream compat\n        const header = headers['accept-encoding']\n            .toLowerCase()\n            .replace(asteriskRegex, 'gzip');\n\n        return encodingNegotiator.negotiate(\n            header,\n            ['br', 'gzip', 'deflate'].filter(enc => !checked.has(enc)),\n        );\n    }\n\n    getEncodingExtension(encoding) {\n        switch (encoding) {\n            case 'br':\n                return 'br';\n            case 'gzip':\n                return 'gz';\n        }\n    }\n\n    findIndexFile(pathname, root, indexFiles = ['index.html']) {\n        if (Array.isArray(indexFiles)) {\n            return indexFiles.find(filename => {\n                const p = path.join(root, pathname, filename);\n                try {\n                    const stats = statSync(p);\n                    return !stats.isDirectory();\n                } catch {\n                    return false;\n                }\n            });\n        }\n        /* c8 ignore next */\n        return false;\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "indexes",
    "snippet": "const indexes =\n            this.options.index === undefined\n                ? ['index.html']\n                : [].concat(this.options.index);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "indexDirs",
    "snippet": "const indexDirs = new Map();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "routes",
    "snippet": "const routes = new Set();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "roots",
    "snippet": "const roots = Array.isArray(this.root) ? this.root : [this.root];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "routeOpts",
    "snippet": "const routeOpts = {\n            errorHandler(error, request, reply) {\n                if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n                    reply.request.raw.destroy();\n                    return;\n                }\n            },\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "files",
    "snippet": "const files = await fg(['**/**'], {\n                cwd: rootPath,\n                absolute: false,\n                followSymbolicLinks: true,\n                onlyFiles: true,\n                dot: this.options.serverDotfiles,\n            });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "route",
    "snippet": "const route = this.options.prefix + file;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key = path.posix.basename(route);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "toSetUp",
    "snippet": "const toSetUp = Object.assign({}, routeOpts, {\n            method: ['HEAD', 'GET'],\n            url: route,\n            handler: this.serveFileHandler.bind(this),\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "routeConfig",
    "snippet": "const routeConfig = req.routeOptions?.config || req.routeConfig;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "sendOptions",
    "snippet": "const sendOptions = {\n            root: this.options.root,\n            acceptRanges: this.options.acceptRanges,\n            cacheControl: this.options.cacheControl,\n            dotfiles: this.options.dotfiles,\n            etag: this.options.etag,\n            extensions: this.options.extensions,\n            immutable: this.options.immutable,\n            index: this.options.index,\n            lastModified: this.options.lastModified,\n            maxAge: this.options.maxAge,\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "setHeaders",
    "snippet": "const setHeaders = this.options.setHeaders;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "allowedPath",
    "snippet": "const allowedPath = this.options.allowedPath;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "pathnameOrig",
    "snippet": "const pathnameOrig = pathname;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "options",
    "snippet": "const options = Object.assign({}, sendOptions, pumpOptions);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "buffer",
    "snippet": "const buffer = await this.streamToBuffer(stream);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "chunks",
    "snippet": "const chunks = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "chunks",
    "snippet": "const chunks: Buffer[] = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "originalUrl",
    "snippet": "const originalUrl = parseUrl.original(this.req);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "loc",
    "snippet": "const loc = encodeUrl(url.format(originalUrl));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "doc",
    "snippet": "const doc = createHtmlDocument(\n                'Redirecting',\n                'Redirecting to ' + escapeHtml(loc),\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = mime.getType(path) || 'application/octet-stream';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "asteriskRegex",
    "snippet": "const asteriskRegex = /\\*/gu;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "header",
    "snippet": "const header = headers['accept-encoding']\n            .toLowerCase()\n            .replace(asteriskRegex, 'gzip');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "p",
    "snippet": "const p = path.join(root, pathname, filename);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "stats",
    "snippet": "const stats = statSync(p);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/index.ts",
    "type": "Constant",
    "value": "serveStatic",
    "snippet": "const serveStatic = (root: string, options?: StaticOptions) => {\n    if (!root) throw new TypeError('root path required');\n\n    if (typeof root !== 'string')\n        throw new TypeError('root path must be a string');\n\n    return (server, done) =>\n        new ServerStaticMiddleware(root, options).process(server, done);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Class",
    "value": "Mime",
    "snippet": "class Mime {\n    #extensionToType = new Map<string, string>();\n    #typeToExtension = new Map<string, string>();\n    #typeToExtensions = new Map<string, Set<string>>();\n\n    constructor(...args: TypeMap[]) {\n        if (args.length > 0) {\n            for (const arg of args) this.define(arg);\n        } else {\n            this.define(standardTypes);\n            this.define(otherTypes);\n        }\n    }\n\n    define(typeMap: TypeMap, force = false) {\n        for (let [type, extensions] of Object.entries(typeMap)) {\n            type = type.toLowerCase();\n            extensions = extensions.map(ext => ext.toLowerCase());\n\n            if (!this.#typeToExtensions.has(type))\n                this.#typeToExtensions.set(type, new Set<string>());\n\n            const allExtensions = this.#typeToExtensions.get(type);\n\n            let first = true;\n            for (let extension of extensions) {\n                const starred = extension.startsWith('*');\n\n                extension = starred ? extension.slice(1) : extension;\n                allExtensions?.add(extension);\n\n                if (first) this.#typeToExtension.set(type, extension);\n\n                first = false;\n\n                if (starred) continue;\n\n                const currentType = this.#extensionToType.get(extension);\n\n                if (currentType && currentType != type && !force) {\n                    throw new Error(\n                        `\"${type} -> ${extension}\" conflicts with \"${currentType} -> ${extension}\". Pass \\`force=true\\` to override this definition.`,\n                    );\n                }\n\n                this.#extensionToType.set(extension, type);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Get mime type associated with an extension\n     */\n    getType(path: string) {\n        if (typeof path !== 'string') return null;\n\n        const last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n        const ext = last.replace(/^.*\\./, '').toLowerCase();\n\n        const hasPath = last.length < path.length;\n        const hasDot = ext.length < last.length - 1;\n\n        if (!hasDot && hasPath) return null;\n\n        return this.#extensionToType.get(ext) ?? null;\n    }\n\n    /**\n     * Get default file extension associated with a mime type\n     */\n    getExtension(type: string) {\n        if (typeof type !== 'string') return null;\n\n        type = type?.split?.(';')[0];\n\n        return (\n            (type && this.#typeToExtension.get(type.trim().toLowerCase())) ??\n            null\n        );\n    }\n\n    /**\n     * Get all file extensions associated with a mime type\n     */\n    getAllExtensions(type: string) {\n        if (typeof type !== 'string') return null;\n        return this.#typeToExtensions.get(type.toLowerCase()) ?? null;\n    }\n\n    //\n    // Private API, for internal use only.  These APIs may change at any time\n    //\n    _freeze() {\n        this.define = () => {\n            throw new Error(\n                'define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances',\n            );\n        };\n\n        Object.freeze(this);\n\n        for (const extensions of this.#typeToExtensions.values())\n            Object.freeze(extensions);\n\n        return this;\n    }\n\n    _getTestState() {\n        return {\n            types: this.#extensionToType,\n            extensions: this.#typeToExtension,\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "arg",
    "snippet": "const arg"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "allExtensions",
    "snippet": "const allExtensions = this.#typeToExtensions.get(type);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "starred",
    "snippet": "const starred = extension.startsWith('*');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "currentType",
    "snippet": "const currentType = this.#extensionToType.get(extension);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "last",
    "snippet": "const last = path.replace(/^.*[/\\\\]/, '').toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "ext",
    "snippet": "const ext = last.replace(/^.*\\./, '').toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "hasPath",
    "snippet": "const hasPath = last.length < path.length;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "hasDot",
    "snippet": "const hasDot = ext.length < last.length - 1;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "extensions",
    "snippet": "const extensions"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/mime.ts",
    "type": "Constant",
    "value": "mime",
    "snippet": "const mime = new Mime()._freeze();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "uid",
    "snippet": "const uid = require('uid-safe').sync;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Interface",
    "value": "CookieOptions",
    "snippet": "interface CookieOptions {\r\n    domain?: string;\r\n    expires?: number;\r\n    httpOnly?: boolean;\r\n    maxAge?: number;\r\n    partitioned?: boolean;\r\n    path?: string;\r\n    priority?: \"low\" | \"medium\" | \"high\";\r\n    sameSite?: boolean | \"lax\" | \"none\" | \"strict\";\r\n    secure?: boolean;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Interface",
    "value": "SessionOptions",
    "snippet": "interface SessionOptions {\r\n    cookie?: CookieOptions;\r\n    genid?: undefined | Function;\r\n    name?: string;\r\n    key?: string;\r\n    proxy?: boolean | undefined;\r\n    resave?: boolean;\r\n    rolling?: boolean;\r\n    saveUninitialized?: boolean;\r\n    secret?: string[];\r\n    store?: MemoryStore | undefined;\r\n    unset?: \"destroy\" | \"keep\"\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Class",
    "value": "SessionMiddleware",
    "snippet": "class SessionMiddleware {\r\n    public middlewareName: string = 'session';\r\n\r\n    protected options: SessionOptions;\r\n\r\n    constructor(options?: SessionOptions) {\r\n        this.options = options || {};\r\n    }\r\n\r\n    async process(req, res, next) {\r\n        if (req.app && typeof req.app.addHook == 'function')\r\n            req.app.addHook('onRequest', this.onCall.bind(this));\r\n        else this.onCall.call(this, req, res, null, next);\r\n    }\r\n\r\n    async onCall(req, res, payload, done) {\r\n        const cookieOptions = this.options.cookie || {}\r\n        const generateId = this.options.genid || this.generateSessionId;\r\n        const name = this.options.name || this.options.key || \"connect.sid\";\r\n        const store = this.options.store || new MemoryStore({\r\n            cookieOptions\r\n        });\r\n        const trustProxy = this.options.proxy;\r\n        let resaveSession = this.options.resave;\r\n        const rollingSessions = Boolean(this.options.rolling);\r\n        let saveUninitializedSession = this.options.saveUninitialized;\r\n        let secret = this.options.secret;\r\n\r\n        if (typeof generateId !== 'function') \r\n            throw new TypeError('genid option must be a function');\r\n        \r\n        if (resaveSession === undefined) \r\n            resaveSession = true;\r\n                \r\n        if (saveUninitializedSession === undefined) \r\n            saveUninitializedSession = true;\r\n\r\n        if (this.options.unset && this.options.unset !== 'destroy' && this.options.unset !== 'keep') \r\n            throw new TypeError('unset option must be \"destroy\" or \"keep\"');\r\n\r\n        const unsetDestroy = this.options.unset === 'destroy';\r\n\r\n        if (Array.isArray(secret) && secret.length === 0) \r\n            throw new TypeError('secret option array must contain one or more strings');\r\n          \r\n        if (secret && !Array.isArray(secret)) \r\n            secret = [secret];\r\n        \r\n        const storeImplementsTouch = typeof store.touch === 'function';\r\n    }\r\n\r\n    public generateSessionId(sess){\r\n        return uid(24);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "cookieOptions",
    "snippet": "const cookieOptions = this.options.cookie || {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "generateId",
    "snippet": "const generateId = this.options.genid || this.generateSessionId;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "name",
    "snippet": "const name = this.options.name || this.options.key || \"connect.sid\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "store",
    "snippet": "const store = this.options.store || new MemoryStore({\r\n            cookieOptions\r\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "trustProxy",
    "snippet": "const trustProxy = this.options.proxy;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "rollingSessions",
    "snippet": "const rollingSessions = Boolean(this.options.rolling);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "unsetDestroy",
    "snippet": "const unsetDestroy = this.options.unset === 'destroy';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "storeImplementsTouch",
    "snippet": "const storeImplementsTouch = typeof store.touch === 'function';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new SessionMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "etag",
    "snippet": "const etag = function (options?: SessionOptions) {\r\n    const middleware = new SessionMiddleware(options);\r\n    return (req, res, next) => middleware.process(req, res, next);\r\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/index.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new SessionMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/config.ts",
    "type": "Constant",
    "value": "source",
    "snippet": "const source = 'packages';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/config.ts",
    "type": "Constant",
    "value": "packagePaths",
    "snippet": "const packagePaths = getDirs(source);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/auth.controller.ts",
    "type": "Class",
    "value": "AuthController",
    "snippet": "@Controller(\"auth\")\nexport class AuthController {\n    constructor(private readonly authService: AuthService) {}\n\n    @Get(\"user\")\n    @Auth()\n    async user(@Req() req) {\n        return req.user;\n    }\n\n    \n\n    \n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Class",
    "value": "SwaggerController",
    "snippet": "@Controller('docs')\r\nexport class SwaggerController {\r\n    @Get('/swagger.json')\r\n    async getSwaggerSpec(@Request() req, @Response() res): Promise<void> {\r\n        const swaggerPath = path.resolve(__dirname, '../../swagger.json');\r\n        const swaggerFile = fs.readFileSync(swaggerPath, 'utf-8');\r\n        res.type('application/json').send(swaggerFile);\r\n    }\r\n\r\n    @Get()\r\n    async getSwaggerUI(@Request() req, @Response() res): Promise<void> {\r\n        const config = Config.get(\"swagger.docs\", {});\r\n        const title = config.info?.title || \"API Documentation\";\r\n        \r\n        const swaggerUIHtml = `\r\n            <!DOCTYPE html>\r\n            <html lang=\"en\">\r\n            <head>\r\n                <meta charset=\"UTF-8\">\r\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n                <title>${title}</title>\r\n                <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui.css\" />\r\n            </head>\r\n            <body>\r\n                <div id=\"swagger-ui\"></div>\r\n                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui-bundle.js\"></script>\r\n                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui-standalone-preset.js\"></script>\r\n                <script>\r\n                    const ui = SwaggerUIBundle({\r\n                        url: '/docs/swagger.json', // URL where swagger.json is served\r\n                        dom_id: '#swagger-ui',\r\n                        presets: [\r\n                            SwaggerUIBundle.presets.apis,\r\n                            SwaggerUIBundle.SwaggerUIStandalonePreset\r\n                        ],\r\n                    });\r\n                </script>\r\n            </body>\r\n            </html>\r\n        `;\r\n\r\n        res.type('text/html').send(swaggerUIHtml);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Constant",
    "value": "swaggerPath",
    "snippet": "const swaggerPath = path.resolve(__dirname, '../../swagger.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Constant",
    "value": "swaggerFile",
    "snippet": "const swaggerFile = fs.readFileSync(swaggerPath, 'utf-8');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Constant",
    "value": "config",
    "snippet": "const config = Config.get(\"swagger.docs\", {});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Constant",
    "value": "title",
    "snippet": "const title = config.info?.title || \"API Documentation\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/controllers/swagger.controller.ts",
    "type": "Constant",
    "value": "swaggerUIHtml",
    "snippet": "const swaggerUIHtml = `\r\n            <!DOCTYPE html>\r\n            <html lang=\"en\">\r\n            <head>\r\n                <meta charset=\"UTF-8\">\r\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n                <title>${title}</title>\r\n                <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui.css\" />\r\n            </head>\r\n            <body>\r\n                <div id=\"swagger-ui\"></div>\r\n                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui-bundle.js\"></script>\r\n                <script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.3/swagger-ui-standalone-preset.js\"></script>\r\n                <script>\r\n                    const ui = SwaggerUIBundle({\r\n                        url: '/docs/swagger.json', // URL where swagger.json is served\r\n                        dom_id: '#swagger-ui',\r\n                        presets: [\r\n                            SwaggerUIBundle.presets.apis,\r\n                            SwaggerUIBundle.SwaggerUIStandalonePreset\r\n                        ],\r\n                    });\r\n                </script>\r\n            </body>\r\n            </html>\r\n        `;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/models/user.model.ts",
    "type": "Interface",
    "value": "IUser",
    "snippet": "interface IUser {\n    id?: any;\n    username: string;\n    password: string;\n    googleId: string;\n    groups: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/models/user.model.ts",
    "type": "Class",
    "value": "User",
    "snippet": "class User implements IUser {\n    id?: any;\n\n    @Transform(({ value }) => crypto.createHash('sha1').update(value).digest('hex'))\n    @IsString({ message: \"Invalid username\" })\n    @MinLength(4, { message: \"Invalid username\" })\n    @MaxLength(40, { message: \"Invalid username\" })\n    username: string\n\n    @Transform(({ value }) => crypto.createHash('sha256').update(value).digest('hex'))\n    @IsString({ message: \"Invalid password\" })\n    password: string\n\n    googleId: string\n\n    @Transform(({ value }) => JSON.stringify(value))\n    groups: string = \"[]\";\n\n    constructor(partial: Partial<User>) {\n        Object.assign(this, partial);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/modules/swagger.module.ts",
    "type": "Constant",
    "value": "SwaggerModule",
    "snippet": "const SwaggerModule = new Module('swagger', {\r\n    controllers: [SwaggerController],\r\n    transpilers: [SwaggerTranspiler]\r\n});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Class",
    "value": "AuthService",
    "snippet": "@Service(\"auth\")\nexport class AuthService extends AbstractService {\n    public async login(\n        payload: LoginRequest, \n        req?: any, res?: any, \n        session?: any\n    ): Promise<{ result: LoginResponse, user: any }> {\n        Telemetry.start('AuthService::login', req?.requestId);\n\n        const jwtToken = Config.get<string>(\"auth.jwtSecret\");\n        const expiresIn = Config.get<number>(\"auth.expiresIn\", 60 * 60);\n        const sessionEnabled = Config.get<boolean>(\"server.session.enabled\", true);\n        const cookieName = Config.get<string>(\n            \"server.session.options.sessionCookieName\", \n            \"token\"\n        );\n        const cookieTTL = Config.get<number>(\n            \"server.session.options.cookie.maxAge\", \n            24 * 60 * 60 * 100\n        );\n        const cookieSecure = Config.get<boolean>(\n            \"server.session.options.cookie.secure\", \n            process.env.NODE_ENV !== 'dev'\n        );\n\n        const userValidation = plainToClass(User, payload, { \n            exposeUnsetFields: true,\n            enableImplicitConversion: true\n        }); \n\n        const user = { id: 0, username: \"dummyUsername\", password: \"dummyPasswordHash\" };\n        if (userValidation.password !== \"dummyPasswordHash\") \n            return { result: { success: false, token: \"\", message: \"Invalid credentials\" }, user: null };\n\n        const token = jwt.sign({ \n            id: user.id,\n            username: payload.username \n        }, jwtToken, { expiresIn });\n\n        res.cookie(cookieName, `Bearer ${token}`, {\n            httpOnly: true,\n            secure: cookieSecure,\n            sameSite: 'strict',\n            maxAge: cookieTTL\n        });\n\n        if(sessionEnabled){\n            session.user = {\n                username: payload.username,\n                token: token,\n            };\n    \n            session.save();\n        }\n\n                \n        Telemetry.end('AuthService::login', req?.requestId);        \n        return { result: { success: true, token, message: \"Login successful\" }, user };\n    }\n\n\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "jwtToken",
    "snippet": "const jwtToken = Config.get<string>(\"auth.jwtSecret\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "expiresIn",
    "snippet": "const expiresIn = Config.get<number>(\"auth.expiresIn\", 60 * 60);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "sessionEnabled",
    "snippet": "const sessionEnabled = Config.get<boolean>(\"server.session.enabled\", true);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "cookieName",
    "snippet": "const cookieName = Config.get<string>(\n            \"server.session.options.sessionCookieName\", \n            \"token\"\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "cookieTTL",
    "snippet": "const cookieTTL = Config.get<number>(\n            \"server.session.options.cookie.maxAge\", \n            24 * 60 * 60 * 100\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "cookieSecure",
    "snippet": "const cookieSecure = Config.get<boolean>(\n            \"server.session.options.cookie.secure\", \n            process.env.NODE_ENV !== 'dev'\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "userValidation",
    "snippet": "const userValidation = plainToClass(User, payload, { \n            exposeUnsetFields: true,\n            enableImplicitConversion: true\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "user",
    "snippet": "const user = { id: 0, username: \"dummyUsername\", password: \"dummyPasswordHash\" };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/services/auth.service.ts",
    "type": "Constant",
    "value": "token",
    "snippet": "const token = jwt.sign({ \n            id: user.id,\n            username: payload.username \n        }, jwtToken, { expiresIn });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Class",
    "value": "SwaggerTranspiler",
    "snippet": "class SwaggerTranspiler implements ITranspile {\r\n    private logger: Logger = new Logger('SwaggerTranspiler');\r\n\r\n    run(): void {\r\n        const contracts = Scope.getArray<any>('__contracts');\r\n        const config = Config.get(\"swagger.docs\", {});\r\n        const hasAuth = Module.hasModule('auth');\r\n\r\n        let doc: any = {\r\n            openapi: \"3.0.0\",\r\n            info: {\r\n                title: config.info?.title || \"API Documentation\",\r\n                description: config.info?.description || \"Auto-generated Swagger Documentation\",\r\n                version: config.info?.version || \"1.0.0\"\r\n            },\r\n            servers: [{\r\n                url: config?.host || \"http://localhost:3000\"\r\n            }],\r\n            paths: {},\r\n            components: {\r\n                schemas: {},\r\n                securitySchemes: hasAuth\r\n                    ? {\r\n                        BearerAuth: {\r\n                            type: \"http\",\r\n                            scheme: \"bearer\",\r\n                            bearerFormat: \"JWT\"\r\n                        }\r\n                    }\r\n                    : {}\r\n            },\r\n            security: hasAuth\r\n                ? [{ BearerAuth: [] }]\r\n                : []\r\n        };\r\n\r\n        if(hasAuth)\r\n            doc = this.includeAuthRoutes(doc);\r\n        \r\n        contracts?.forEach((contract: any) => {\r\n            const controllerName = contract.controllerName.toLowerCase();\r\n\r\n            doc.paths[`/${controllerName}`] = {\r\n                get: {\r\n                    tags: [controllerName],\r\n                    summary: `Retrieve all ${controllerName}`,\r\n                    responses: {\r\n                        200: {\r\n                            description: `Successful retrieval of ${controllerName}`,\r\n                            content: {\r\n                                \"application/json\": {\r\n                                    schema: {\r\n                                        type: \"array\",\r\n                                        items: {\r\n                                            $ref: `#/components/schemas/${controllerName}`\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                post: {\r\n                    tags: [controllerName],\r\n                    summary: `Add a new ${controllerName}`,\r\n                    requestBody: {\r\n                        required: true,\r\n                        content: {\r\n                            \"application/json\": {\r\n                                schema: {\r\n                                    $ref: `#/components/schemas/${controllerName}`\r\n                                }\r\n                            },\r\n                            \"application/x-www-form-urlencoded\": {\r\n                                schema: {\r\n                                    $ref: `#/components/schemas/${controllerName}`\r\n                                }\r\n                            }\r\n                        }\r\n                    },\r\n                    responses: {\r\n                        201: {\r\n                            description: `${controllerName} created`,\r\n                            content: {\r\n                                \"application/json\": {\r\n                                    schema: {\r\n                                        $ref: `#/components/schemas/${controllerName}`\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            doc.paths[`/${controllerName}/{id}`] = {\r\n                get: {\r\n                    tags: [controllerName],\r\n                    summary: `Get ${controllerName} by ID`,\r\n                    parameters: [{\r\n                        name: \"id\",\r\n                        in: \"path\",\r\n                        required: true,\r\n                        schema: {\r\n                            type: \"string\"\r\n                        },\r\n                        description: `ID of the ${controllerName} to retrieve`\r\n                    }],\r\n                    responses: {\r\n                        200: {\r\n                            description: `Successfully retrieved ${controllerName}`,\r\n                            content: {\r\n                                \"application/json\": {\r\n                                    schema: {\r\n                                        $ref: `#/components/schemas/${controllerName}`\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                put: {\r\n                    tags: [controllerName],\r\n                    summary: `Update ${controllerName} by ID`,\r\n                    parameters: [{\r\n                        name: \"id\",\r\n                        in: \"path\",\r\n                        required: true,\r\n                        schema: {\r\n                            type: \"string\"\r\n                        },\r\n                        description: `ID of the ${controllerName} to update`\r\n                    }],\r\n                    requestBody: {\r\n                        required: true,\r\n                        content: {\r\n                            \"application/json\": {\r\n                                schema: {\r\n                                    $ref: `#/components/schemas/${controllerName}`\r\n                                }\r\n                            },\r\n                            \"application/x-www-form-urlencoded\": {\r\n                                schema: {\r\n                                    $ref: `#/components/schemas/${controllerName}`\r\n                                }\r\n                            }\r\n                        }\r\n                    },\r\n                    responses: {\r\n                        200: {\r\n                            description: `${controllerName} updated`,\r\n                            content: {\r\n                                \"application/json\": {\r\n                                    schema: {\r\n                                        $ref: `#/components/schemas/${controllerName}`\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                delete: {\r\n                    tags: [controllerName],\r\n                    summary: `Delete ${controllerName} by ID`,\r\n                    parameters: [{\r\n                        name: \"id\",\r\n                        in: \"path\",\r\n                        required: true,\r\n                        schema: {\r\n                            type: \"string\"\r\n                        },\r\n                        description: `ID of the ${controllerName} to delete`\r\n                    }],\r\n                    responses: {\r\n                        200: {\r\n                            description: `${controllerName} deleted`,\r\n                            content: {\r\n                                \"application/json\": {\r\n                                    schema: {\r\n                                        type: \"object\",\r\n                                        properties: {\r\n                                            success: { type: \"boolean\" },\r\n                                            affected: { type: \"integer\" }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            const properties: any = {};\r\n            contract.fields?.forEach((field: any) => {\r\n                properties[field.propertyKey] = {\r\n                    type: this.mapToSwaggerType(field.protoType)\r\n                };\r\n            });\r\n\r\n            doc.components.schemas[controllerName] = {\r\n                type: \"object\",\r\n                properties\r\n            };\r\n        });       \r\n\r\n        const outputFile = path.resolve('./swagger.json');\r\n        fs.writeFileSync(outputFile, JSON.stringify(doc, null, 4), 'utf8');\r\n    }\r\n\r\n    private includeAuthRoutes(doc){\r\n        doc.paths[\"/auth/login\"] = {\r\n            post: {\r\n                tags: [\"auth\"],\r\n                summary: \"Login to the application\",\r\n                requestBody: {\r\n                    required: true,\r\n                    content: {\r\n                        \"application/json\": {\r\n                            schema: {\r\n                                $ref: \"#/components/schemas/LoginRequest\"\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                responses: {\r\n                    200: {\r\n                        description: \"Successful login\",\r\n                        content: {\r\n                            \"application/json\": {\r\n                                schema: {\r\n                                    $ref: \"#/components/schemas/LoginResponse\"\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        doc.paths[\"/auth/register\"] = {\r\n            post: {\r\n                tags: [\"auth\"],\r\n                summary: \"Register a new user\",\r\n                requestBody: {\r\n                    required: true,\r\n                    content: {\r\n                        \"application/json\": {\r\n                            schema: {\r\n                                $ref: \"#/components/schemas/RegisterRequest\"\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                responses: {\r\n                    201: {\r\n                        description: \"Successful registration\",\r\n                        content: {\r\n                            \"application/json\": {\r\n                                schema: {\r\n                                    $ref: \"#/components/schemas/RegisterResponse\"\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        doc.paths[\"/auth/user\"] = {\r\n            get: {\r\n                tags: [\"auth\"],\r\n                summary: \"Get the current authenticated user\",\r\n                security: [{ BearerAuth: [] }],\r\n                responses: {\r\n                    200: {\r\n                        description: \"Successfully retrieved the user\",\r\n                        content: {\r\n                            \"application/json\": {\r\n                                schema: {\r\n                                    $ref: \"#/components/schemas/User\"\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // Add the LoginRequest, LoginResponse, RegisterRequest, RegisterResponse, and User schemas\r\n        doc.components.schemas[\"LoginRequest\"] = {\r\n            type: \"object\",\r\n            properties: {\r\n                username: { type: \"string\" },\r\n                password: { type: \"string\" }\r\n            }\r\n        };\r\n\r\n        doc.components.schemas[\"LoginResponse\"] = {\r\n            type: \"object\",\r\n            properties: {\r\n                success: { type: \"boolean\" },\r\n                token: { type: \"string\" },\r\n                message: { type: \"string\" }\r\n            }\r\n        };\r\n\r\n        doc.components.schemas[\"RegisterRequest\"] = {\r\n            type: \"object\",\r\n            properties: {\r\n                username: { type: \"string\" },\r\n                email: { type: \"string\" },\r\n                password: { type: \"string\" }\r\n            }\r\n        };\r\n\r\n        doc.components.schemas[\"RegisterResponse\"] = {\r\n            type: \"object\",\r\n            properties: {\r\n                success: { type: \"boolean\" },\r\n                message: { type: \"string\" }\r\n            }\r\n        };\r\n\r\n        doc.components.schemas[\"User\"] = {\r\n            type: \"object\",\r\n            properties: {\r\n                id: { type: \"string\" },\r\n                username: { type: \"string\" },\r\n                email: { type: \"string\" }\r\n            }\r\n        };\r\n\r\n        return doc;\r\n    }\r\n\r\n    private mapToSwaggerType(protoType: string): string {\r\n        const typeMapping: { [key: string]: string } = {\r\n            string: 'string',\r\n            boolean: 'boolean',\r\n            bool: 'boolean',\r\n            int: 'integer',\r\n            int32: 'integer',\r\n            int64: 'integer',\r\n            float: 'number',\r\n            double: 'number',\r\n            bytes: 'string',\r\n            date: 'string',\r\n            timestamp: 'string',\r\n            json: 'object',\r\n            jsonb: 'object',\r\n            uuid: 'string'\r\n        };\r\n\r\n        return typeMapping[protoType] || 'string';\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "contracts",
    "snippet": "const contracts = Scope.getArray<any>('__contracts');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "config",
    "snippet": "const config = Config.get(\"swagger.docs\", {});"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "hasAuth",
    "snippet": "const hasAuth = Module.hasModule('auth');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "controllerName",
    "snippet": "const controllerName = contract.controllerName.toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "properties",
    "snippet": "const properties: any = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "outputFile",
    "snippet": "const outputFile = path.resolve('./swagger.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-swagger/src/transpilers/swagger.transpiler.ts",
    "type": "Constant",
    "value": "typeMapping",
    "snippet": "const typeMapping: { [key: string]: string } = {\r\n            string: 'string',\r\n            boolean: 'boolean',\r\n            bool: 'boolean',\r\n            int: 'integer',\r\n            int32: 'integer',\r\n            int64: 'integer',\r\n            float: 'number',\r\n            double: 'number',\r\n            bytes: 'string',\r\n            date: 'string',\r\n            timestamp: 'string',\r\n            json: 'object',\r\n            jsonb: 'object',\r\n            uuid: 'string'\r\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/controllers/auth/groups.controller.ts",
    "type": "Class",
    "value": "GroupsController",
    "snippet": "@Controller('groups')\nexport class GroupsController extends GroupsControllerGenerated {\n    //Function GroupsController not implemented\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/controllers/auth/roles.controller.ts",
    "type": "Class",
    "value": "RolesController",
    "snippet": "@Controller('roles')\nexport class RolesController extends RolesControllerGenerated {\n    //Function RolesController not implemented\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/controllers/auth/user.controller.ts",
    "type": "Class",
    "value": "UserController",
    "snippet": "@Controller('user')\nexport class UserController extends UserControllerGenerated {\n    //Function UserController not implemented\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/entities/auth/groups.entity.ts",
    "type": "Class",
    "value": "GroupsEntity",
    "snippet": "@Entity(\"auth_groups\")\n@Index(\"idx_groups_name\", [\"name\"], { unique: true })\nexport class GroupsEntity implements IGroups {\n    @ObjectIdColumn()\n    _id: ObjectId;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    name: string;\n\n    @Column({ \n        type: \"simple-array\", \n        nullable: true \n    })\n    roles?: RolesEntity[] | string[] | ObjectId[] | null;\n\n    @CreateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\" \n    })\n    createdAt: Date;\n\n    @UpdateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\", \n        onUpdate: \"CURRENT_TIMESTAMP\" \n    })\n    updatedAt: Date;\n\n    @ManyToOne(() => UserEntity, { nullable: true })\n    @ObjectIdColumn({ nullable: true })\n    userCreator: ObjectId;\n\n    @ManyToOne(() => UserEntity, { nullable: true })\n    @ObjectIdColumn({ nullable: true })\n    userLastUpdate: ObjectId;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/entities/auth/roles.entity.ts",
    "type": "Class",
    "value": "RolesEntity",
    "snippet": "@Entity(\"auth_roles\")\n@Index(\"idx_roles_name\", [\"name\"], { unique: true })\nexport class RolesEntity implements IRoles {\n    @ObjectIdColumn()\n    _id: ObjectId;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    name: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/entities/auth/sessions.entity.ts",
    "type": "Class",
    "value": "SessionsEntity",
    "snippet": "@Entity(\"auth_sessions\")\n@Index(\"idx_sessions_uuid\", [\"uuid\"])\n@Index(\"idx_sessions_fingerprint\", [\"fingerprint\"], { unique: true })\n@Index(\"idx_sessions_user\", [\"user\"])\nexport class SessionsEntity implements ISessions {\n    @ObjectIdColumn()\n    _id: ObjectId;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    uuid: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    fingerprint: string;\n\n    @Column({ \n        type: \"string\", \n        nullable: true \n    })\n    user: UserEntity | string | ObjectId | null;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    ipAddress: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    device?: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    browser?: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    os?: string;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    revoked: boolean;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    userAgent?: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    refreshToken: string;\n\n    @CreateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\" \n    })\n    createdAt: Date;\n\n    @UpdateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\", \n        onUpdate: \"CURRENT_TIMESTAMP\" \n    })\n    updatedAt: Date;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/entities/auth/user.entity.ts",
    "type": "Class",
    "value": "UserEntity",
    "snippet": "@Entity(\"auth_users\")\n@Index(\"idx_user_username\", [\"username\"], { unique: true })\n@Index(\"idx_user_provider\", [\"provider\"])\n@Index(\"idx_user_blocked\", [\"blocked\"])\n@Index(\"idx_user_validated\", [\"validated\"])\n@Index(\"idx_user_login\", [\"username\",\"password\",\"blocked\"])\nexport class UserEntity implements IUser {\n    @ObjectIdColumn()\n    _id: ObjectId;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    username: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: false \n    })\n    password: string;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    provider?: string;\n\n    @Column({ \n        type: \"simple-array\", \n        nullable: true \n    })\n    groups?: GroupsEntity[] | string[] | ObjectId[] | null;\n\n    @Column({ \n        type: \"simple-array\", \n        nullable: true \n    })\n    roles?: RolesEntity[] | string[] | ObjectId[] | null;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    root: boolean;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    blocked: boolean;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    validated: boolean;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    verifyEmail: boolean;\n\n    @Column({ \n        type: \"int\", \n        nullable: true \n    })\n    verifyEmailCode?: number;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    verifySMS: boolean;\n\n    @Column({ \n        type: \"int\", \n        nullable: true \n    })\n    verifySMSCode?: number;\n\n    @Column({ \n        type: \"varchar\", \n        nullable: true \n    })\n    optSecret?: string;\n\n    @Column({ \n        type: \"boolean\", \n        default: false, \n        nullable: false \n    })\n    optSecretVerify: boolean;\n\n    @CreateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\" \n    })\n    createdAt: Date;\n\n    @UpdateDateColumn({ \n        type: \"timestamp\", \n        default: () => \"CURRENT_TIMESTAMP\", \n        onUpdate: \"CURRENT_TIMESTAMP\" \n    })\n    updatedAt: Date;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/groups.model.ts",
    "type": "Interface",
    "value": "IGroups",
    "snippet": "interface IGroups {\n    _id?: ObjectId;\n    name: string;\n    roles?: object | string | string[] | ObjectId;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/groups.model.ts",
    "type": "Class",
    "value": "Groups",
    "snippet": "class Groups implements IGroups {\n    @Expose()\n    @IsOptional()\n    _id?: ObjectId;\n\n    @Expose({ toClassOnly: true })\n    @IsOptional()\n    id: string;\n\n    @Expose()\n    @IsNotEmpty()\n    @IsString({ message: \"Invalid name\" })\n    @MinLength(3, { message: \"Invalid name\" })\n    @MaxLength(40, { message: \"Invalid name\" })\n    name: string;\n\n    @Expose()\n    roles?: Roles[] | string[] | ObjectId[] | null;\n\n    constructor(partial: Partial<Groups>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<Groups>): Groups{\n        return plainToInstance(Groups, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any) : Groups {\n        return plainToInstance(this, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public toString(){\n        return GroupsFastSchema(this);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/groups.model.ts",
    "type": "Constant",
    "value": "GroupsFastSchemaStructure",
    "snippet": "const GroupsFastSchemaStructure = {\n    title: \"Groups Schema\",\n    type: \"object\",\n    properties: {\n        id: { \n            type: \"string\",\n            nullable: false \n        },\n        name: { \n            type: \"string\",\n            nullable: false \n        },\n        roles: { \n            type: \"array\",\n            nullable: true,\n            items: RolesFastSchemaStructure \n        }\n    },\n    required: [\"id\", \"name\"]\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/groups.model.ts",
    "type": "Constant",
    "value": "GroupsFastSchema",
    "snippet": "const GroupsFastSchema = fastJson(GroupsFastSchemaStructure);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/roles.model.ts",
    "type": "Interface",
    "value": "IRoles",
    "snippet": "interface IRoles {\n    _id?: ObjectId;\n    name: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/roles.model.ts",
    "type": "Class",
    "value": "Roles",
    "snippet": "class Roles implements IRoles {\n    @Expose()\n    @IsOptional()\n    _id?: ObjectId;\n\n    @Expose({ toClassOnly: true })\n    @IsOptional()\n    id: string;\n\n    @Expose()\n    @IsNotEmpty()\n    @IsString({ message: \"Invalid name\" })\n    @MinLength(3, { message: \"Invalid name\" })\n    @MaxLength(40, { message: \"Invalid name\" })\n    name: string;\n\n    constructor(partial: Partial<Roles>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<Roles>): Roles{\n        return plainToInstance(Roles, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any) : Roles {\n        return plainToInstance(this, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public toString(){\n        return RolesFastSchema(this);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/roles.model.ts",
    "type": "Constant",
    "value": "RolesFastSchemaStructure",
    "snippet": "const RolesFastSchemaStructure = {\n    title: \"Roles Schema\",\n    type: \"object\",\n    properties: {\n        id: { \n            type: \"string\",\n            nullable: false \n        },\n        name: { \n            type: \"string\",\n            nullable: false \n        }\n    },\n    required: [\"id\", \"name\"]\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/roles.model.ts",
    "type": "Constant",
    "value": "RolesFastSchema",
    "snippet": "const RolesFastSchema = fastJson(RolesFastSchemaStructure);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/sessions.model.ts",
    "type": "Interface",
    "value": "ISessions",
    "snippet": "interface ISessions {\n    _id?: ObjectId;\n    uuid: string;\n    fingerprint: string;\n    user: object | string | string[] | ObjectId;\n    ipAddress: string;\n    device?: string;\n    browser?: string;\n    os?: string;\n    revoked: boolean;\n    userAgent?: string;\n    refreshToken: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/sessions.model.ts",
    "type": "Class",
    "value": "Sessions",
    "snippet": "class Sessions implements ISessions {\n    @Expose()\n    @IsOptional()\n    _id?: ObjectId;\n\n    @Expose({ toClassOnly: true })\n    @IsOptional()\n    id: string;\n\n    @Expose()\n    @IsNotEmpty()\n    uuid: string;\n\n    @Expose()\n    @IsNotEmpty()\n    fingerprint: string;\n\n    @Expose()\n    @IsNotEmpty()\n    user: User | string | ObjectId | null;\n\n    @Expose()\n    @IsNotEmpty()\n    ipAddress: string;\n\n    @Expose()\n    device?: string;\n\n    @Expose()\n    browser?: string;\n\n    @Expose()\n    os?: string;\n\n    @Expose()\n    @IsNotEmpty()\n    revoked: boolean = false;\n\n    @Expose()\n    userAgent?: string;\n\n    @Expose()\n    @IsNotEmpty()\n    refreshToken: string;\n\n    constructor(partial: Partial<Sessions>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<Sessions>): Sessions{\n        return plainToInstance(Sessions, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any) : Sessions {\n        return plainToInstance(this, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public toString(){\n        return SessionsFastSchema(this);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/sessions.model.ts",
    "type": "Constant",
    "value": "SessionsFastSchemaStructure",
    "snippet": "const SessionsFastSchemaStructure = {\n    title: \"Sessions Schema\",\n    type: \"object\",\n    properties: {\n        id: { \n            type: \"string\",\n            nullable: false \n        },\n        uuid: { \n            type: \"string\",\n            nullable: false \n        },\n        fingerprint: { \n            type: \"string\",\n            nullable: false \n        },\n        user: { \n            type: \"object\",\n            nullable: false \n        },\n        ipAddress: { \n            type: \"string\",\n            nullable: false \n        },\n        device: { \n            type: \"string\",\n            nullable: true \n        },\n        browser: { \n            type: \"string\",\n            nullable: true \n        },\n        os: { \n            type: \"string\",\n            nullable: true \n        },\n        revoked: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        userAgent: { \n            type: \"string\",\n            nullable: true \n        },\n        refreshToken: { \n            type: \"string\",\n            nullable: false \n        }\n    },\n    required: [\"id\", \"uuid\", \"fingerprint\", \"user\", \"ipAddress\", \"revoked\", \"refreshToken\"]\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/sessions.model.ts",
    "type": "Constant",
    "value": "SessionsFastSchema",
    "snippet": "const SessionsFastSchema = fastJson(SessionsFastSchemaStructure);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Interface",
    "value": "IUser",
    "snippet": "interface IUser {\n    _id?: ObjectId;\n    username: string;\n    password: string;\n    provider?: string;\n    groups?: object | string | string[] | ObjectId;\n    roles?: object | string | string[] | ObjectId;\n    root: boolean;\n    blocked: boolean;\n    validated: boolean;\n    verifyEmail: boolean;\n    verifyEmailCode?: number;\n    verifySMS: boolean;\n    verifySMSCode?: number;\n    optSecret?: string;\n    optSecretVerify: boolean;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Class",
    "value": "User",
    "snippet": "class User implements IUser {\n    @Expose()\n    @IsOptional()\n    _id?: ObjectId;\n\n    @Expose({ toClassOnly: true })\n    @IsOptional()\n    id: string;\n\n    @Expose()\n    @Transform(({ value }) => crypto.createHash('sha1').update(value).digest('hex'), { toClassOnly: true })\n    @IsString({ message: \"Invalid username\" })\n    @MinLength(4, { message: \"Invalid username\" })\n    @MaxLength(40, { message: \"Invalid username\" })\n    username: string;\n\n    @Expose()\n    @Transform(({ value }) => crypto.createHash('sha256').update(value).digest('hex'), { toClassOnly: true })\n    @IsString({ message: \"Invalid password\" })\n    password: string;\n\n    @Expose()\n    provider?: string;\n\n    @Expose()\n    groups?: Groups[] | string[] | ObjectId[] | null;\n\n    @Expose()\n    roles?: Roles[] | string[] | ObjectId[] | null;\n\n    @Expose()\n    root: boolean = false;\n\n    @Expose()\n    blocked: boolean = false;\n\n    @Expose()\n    validated: boolean = false;\n\n    @Expose()\n    verifyEmail: boolean = false;\n\n    @Expose()\n    verifyEmailCode?: number;\n\n    @Expose()\n    verifySMS: boolean = false;\n\n    @Expose()\n    verifySMSCode?: number;\n\n    @Expose()\n    optSecret?: string;\n\n    @Expose()\n    optSecretVerify: boolean = false;\n\n    constructor(partial: Partial<User>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<User>): User{\n        return plainToInstance(User, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any) : User {\n        return plainToInstance(this, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public toString(){\n        return UserFastSchema(this);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Constant",
    "value": "UserFastSchemaStructure",
    "snippet": "const UserFastSchemaStructure = {\n    title: \"User Schema\",\n    type: \"object\",\n    properties: {\n        id: { \n            type: \"string\",\n            nullable: false \n        },\n        username: { \n            type: \"string\",\n            nullable: false \n        },\n        password: { \n            type: \"string\",\n            nullable: false \n        },\n        provider: { \n            type: \"string\",\n            nullable: true \n        },\n        groups: { \n            type: \"array\",\n            nullable: true,\n            items: GroupsFastSchemaStructure \n        },\n        roles: { \n            type: \"array\",\n            nullable: true,\n            items: RolesFastSchemaStructure \n        },\n        root: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        blocked: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        validated: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        verifyEmail: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        verifyEmailCode: { \n            type: \"integer\",\n            nullable: true \n        },\n        verifySMS: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        },\n        verifySMSCode: { \n            type: \"integer\",\n            nullable: true \n        },\n        optSecret: { \n            type: \"string\",\n            nullable: true \n        },\n        optSecretVerify: { \n            type: \"boolean\",\n            nullable: false,\n            default: false \n        }\n    },\n    required: [\"id\", \"username\", \"password\", \"root\", \"blocked\", \"validated\", \"verifyEmail\", \"verifySMS\", \"optSecretVerify\"]\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Constant",
    "value": "UserFastSchema",
    "snippet": "const UserFastSchema = fastJson(UserFastSchemaStructure);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Interface",
    "value": "LoginRequest",
    "snippet": "interface LoginRequest {\n    username: string;\n    password: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Class",
    "value": "LoginRequestDTO",
    "snippet": "class LoginRequestDTO implements LoginRequest {\n    username: string;\n    password: string;\n\n    constructor(partial: Partial<LoginRequestDTO>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<LoginRequestDTO>): LoginRequestDTO{\n        return plainToInstance(LoginRequestDTO, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any): LoginRequestDTO {\n        return plainToInstance(LoginRequestDTO, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Interface",
    "value": "LoginResponse",
    "snippet": "interface LoginResponse {\n    success: boolean;\n    token?: string;\n    message?: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Class",
    "value": "LoginResponseDTO",
    "snippet": "class LoginResponseDTO implements LoginResponse {\n    success: boolean;\n    token?: string;\n    message?: string;\n\n    constructor(partial: Partial<LoginResponseDTO>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<LoginResponseDTO>): LoginResponseDTO{\n        return plainToInstance(LoginResponseDTO, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any): LoginResponseDTO {\n        return plainToInstance(LoginResponseDTO, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Interface",
    "value": "RegisterRequest",
    "snippet": "interface RegisterRequest {\n    username: string;\n    email: string;\n    password: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Class",
    "value": "RegisterRequestDTO",
    "snippet": "class RegisterRequestDTO implements RegisterRequest {\n    username: string;\n    email: string;\n    password: string;\n\n    constructor(partial: Partial<RegisterRequestDTO>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<RegisterRequestDTO>): RegisterRequestDTO{\n        return plainToInstance(RegisterRequestDTO, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any): RegisterRequestDTO {\n        return plainToInstance(RegisterRequestDTO, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Interface",
    "value": "RegisterResponse",
    "snippet": "interface RegisterResponse {\n    success: boolean;\n    message?: string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/models/auth/user.model.ts",
    "type": "Class",
    "value": "RegisterResponseDTO",
    "snippet": "class RegisterResponseDTO implements RegisterResponse {\n    success: boolean;\n    message?: string;\n\n    constructor(partial: Partial<RegisterResponseDTO>) {\n        Object.assign(this, partial);\n    }\n\n    public serialize(){\n        return instanceToPlain(this);\n    }\n\n    public static fromPartial(partial: Partial<RegisterResponseDTO>): RegisterResponseDTO{\n        return plainToInstance(RegisterResponseDTO, partial, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n\n    public static fromEntity(entity: any): RegisterResponseDTO {\n        return plainToInstance(RegisterResponseDTO, entity, {\n            exposeUnsetFields: false,\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        })\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/services/auth/groups.service.ts",
    "type": "Class",
    "value": "GroupsService",
    "snippet": "@Service(\"groups\")\nexport class GroupsService extends GroupsServiceGenerated {\n\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/services/auth/roles.service.ts",
    "type": "Class",
    "value": "RolesService",
    "snippet": "@Service(\"roles\")\nexport class RolesService extends RolesServiceGenerated {\n\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-admin/api/services/auth/user.service.ts",
    "type": "Class",
    "value": "UserService",
    "snippet": "@Service(\"user\")\nexport class UserService extends UserServiceGenerated {\n\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/functions/converts.ts",
    "type": "Class",
    "value": "Convert",
    "snippet": "@CClass(\"convert\")\r\nexport class Convert {\r\n    @CFunction({ pure: true })\r\n    public static IntToString(value: number) : string {\r\n        return value.toString();\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/class.decorator.ts",
    "type": "Function",
    "value": "CClass",
    "snippet": "function CClass(namespace: string): ClassDecorator {\r\n    return (target: any) => {\r\n        //NodeRegistry.registerHandler(target, namespace);\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/functions.decorator.ts",
    "type": "Interface",
    "value": "CFunctionOptions",
    "snippet": "interface CFunctionOptions {\r\n    category?: string;\r\n    pure?: boolean\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/functions.decorator.ts",
    "type": "Function",
    "value": "CFunction",
    "snippet": "function CFunction(options?: CFunctionOptions): MethodDecorator {\r\n    return (target: any, propertyKey: string | symbol, context?: any) => {\r\n        \r\n    };  \r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/node.decorator.ts",
    "type": "Function",
    "value": "Node",
    "snippet": "function Node(namespace: string, alias?: string): ClassDecorator {\r\n    return (target: any) => {\r\n        NodeRegistry.registerHandler(target, namespace, alias);\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Constant",
    "value": "inputsMap",
    "snippet": "const inputsMap = new WeakMap();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Constant",
    "value": "outputsMap",
    "snippet": "const outputsMap = new WeakMap();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Function",
    "value": "Exec",
    "snippet": "function Exec(): MethodDecorator {\r\n    return (target: any, propertyKey: string | symbol, context?: any) => {\r\n        if(target instanceof NodeGraph)\r\n            target.execute = context.value;\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Function",
    "value": "Input",
    "snippet": "function Input<T>(\r\n    type: string, \r\n    defaultValue?: T, \r\n    options?: any[], \r\n    optional: boolean = false\r\n): PropertyDecorator {\r\n    return (target: any, propertyKey: string | symbol) => {\r\n        if(target instanceof NodeGraph){\r\n            if (!inputsMap.has(target)) \r\n            inputsMap.set(target, []);\r\n        \r\n            inputsMap.get(target).push({\r\n                propertyKey,\r\n                type,\r\n                defaultValue,\r\n                options,\r\n                optional\r\n            });\r\n        }\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Function",
    "value": "Output",
    "snippet": "function Output(type: string, defaultValue?: any): PropertyDecorator {\r\n    return (target: any, propertyKey: string | symbol) => {\r\n        if(target instanceof NodeGraph){\r\n            if (!outputsMap.has(target)) \r\n                outputsMap.set(target, []);\r\n            \r\n            outputsMap.get(target).push({\r\n                propertyKey,\r\n                type,\r\n                defaultValue\r\n            });\r\n        }\r\n    };\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Function",
    "value": "applyProperties",
    "snippet": "function applyProperties<T = NodeGraph>(target: T): any {\r\n    const inputs = inputsMap.get(Object.getPrototypeOf(target)) || [];\r\n    const outputs = outputsMap.get(Object.getPrototypeOf(target)) || [];\r\n    let result = {};\r\n\r\n    inputs.forEach(({ propertyKey, type, defaultValue, options }) => {\r\n        switch (type) {\r\n            case \"int32\":\r\n            case \"int\":\r\n            case \"float\":\r\n                result[propertyKey] = new Property<number>(defaultValue as number || 0);\r\n                break;\r\n            case \"string\":\r\n            case \"str\":\r\n                result[propertyKey] = new Property<string>(defaultValue as string || \"\");\r\n                break;\r\n            case \"boolean\":\r\n            case \"bool\":\r\n                result[propertyKey] = new Property<boolean>(defaultValue as boolean || false);\r\n                break;\r\n            case \"option\":\r\n                result[propertyKey] = new Property<any>(defaultValue as boolean || false, options);\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported input type: ${type}`);\r\n        }\r\n    });\r\n\r\n    outputs.forEach(({ propertyKey, type, defaultValue }) => {\r\n        switch (type) {\r\n            case \"int32\":\r\n            case \"int\":\r\n            case \"float\":\r\n                result[propertyKey] = new Property<number>(defaultValue as number || 0);\r\n                break;\r\n            case \"string\":\r\n            case \"str\":\r\n                result[propertyKey] = new Property<string>(defaultValue as string || \"\");\r\n                break;\r\n            case \"boolean\":\r\n            case \"bool\":\r\n                result[propertyKey] = new Property<boolean>(defaultValue as boolean || false);\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported output type: ${type}`);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Constant",
    "value": "inputs",
    "snippet": "const inputs = inputsMap.get(Object.getPrototypeOf(target)) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/decorators/pins.decorator.ts",
    "type": "Constant",
    "value": "outputs",
    "snippet": "const outputs = outputsMap.get(Object.getPrototypeOf(target)) || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Class",
    "value": "$",
    "snippet": "class $ extends Singleton {\r\n    private static logger = new Logger(\"BlueprintManager\");\r\n\r\n    public static nodes: Map<string, new(namespace: string) => NodeGraph> = \r\n        new Map<string, new(namespace: string) => NodeGraph>();\r\n\r\n    public static nodesMetadata: Map<string, any> = \r\n        new Map<string, any>();\r\n\r\n    static async load(patternFiles: string[] = []) {\r\n        this.logger.log(\"Loading nodes...\");\r\n\r\n        let directoryPackages = path.resolve(\r\n            process.env.NODE_ENV === 'prod'\r\n                ? './node_modules/@cmmv/**/*.node.js'\r\n                : './packages/**/*.node.ts',\r\n        );\r\n\r\n        let directory = path.resolve(\r\n            process.env.NODE_ENV === 'prod'\r\n                ? './dist/**/*.node.js'\r\n                : './src/**/*.node.ts',\r\n        );\r\n\r\n        const files = await fg([directoryPackages, directory, ...patternFiles], {\r\n            ignore: ['node_modules/**'],\r\n        });\r\n\r\n        for await (let filename of files) {\r\n            if (!filename.includes('node_modules')) {\r\n                const node: new() => NodeGraph = (await import(filename))?.default;\r\n                const metadata: any = (fs.existsSync(filename.replace(\".ts\", \".json\").replace(\".js\", \".json\"))) ? \r\n                    JSON.parse(fs.readFileSync(filename.replace(\".ts\", \".json\").replace(\".js\", \".json\"), \"utf-8\")) : null;\r\n\r\n                if(node && typeof node === \"function\"){\r\n                    const nodeMetadata = Reflect.getMetadata(\"node_metadata\", node);\r\n                    const instance = new node();\r\n\r\n                    if(instance instanceof NodeGraph && nodeMetadata.name && nodeMetadata.name !== \"\"){\r\n                        if(this.nodes.has(nodeMetadata.name))\r\n                            throw new Error(`The system cannot have 2 nodes with the same namespace: ${nodeMetadata.name}`);\r\n\r\n                        this.nodes.set(nodeMetadata.name, node);\r\n                        this.nodesMetadata.set(nodeMetadata.name, metadata);\r\n\r\n                        if(nodeMetadata.alias){\r\n                            this.nodes.set(nodeMetadata.alias, node);\r\n                            this.nodesMetadata.set(nodeMetadata.alias, metadata);\r\n                        }\r\n                    }                        \r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    static getNode(namespace: string) : new(namespace: string) => NodeGraph | null {\r\n        return this.nodes.has(namespace) ? this.nodes.get(namespace) : null;\r\n    }\r\n\r\n    static createNodeInstance<T = NodeGraph>(namespace: string) : T | null {\r\n        if (this.nodes.has(namespace)) {\r\n            const metadata = this.nodesMetadata.has(namespace) ? \r\n                this.nodesMetadata.get(namespace) : null;\r\n\r\n            const base = this.nodes.get(namespace);\r\n            let instance = new base(namespace) as T;\r\n\r\n            const properties = applyProperties<T>(instance);\r\n\r\n            if(properties){\r\n                for(let propertyName in properties)\r\n                    instance[propertyName] = properties[propertyName];\r\n            }  \r\n\r\n            if(metadata)\r\n                instance = Object.assign(instance, metadata);\r\n\r\n            return instance;\r\n        } \r\n        else null;\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "files",
    "snippet": "const files = await fg([directoryPackages, directory, ...patternFiles], {\r\n            ignore: ['node_modules/**'],\r\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "node",
    "snippet": "const node: new() => NodeGraph = (await import(filename))?.default;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "metadata",
    "snippet": "const metadata: any = (fs.existsSync(filename.replace(\".ts\", \".json\").replace(\".js\", \".json\"))) ? \r\n                    JSON.parse(fs.readFileSync(filename.replace(\".ts\", \".json\").replace(\".js\", \".json\"), \"utf-8\")) : null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "nodeMetadata",
    "snippet": "const nodeMetadata = Reflect.getMetadata(\"node_metadata\", node);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "instance",
    "snippet": "const instance = new node();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "metadata",
    "snippet": "const metadata = this.nodesMetadata.has(namespace) ? \r\n                this.nodesMetadata.get(namespace) : null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "base",
    "snippet": "const base = this.nodes.get(namespace);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/managers/blueprint.manager.ts",
    "type": "Constant",
    "value": "properties",
    "snippet": "const properties = applyProperties<T>(instance);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/blueprint.ts",
    "type": "Class",
    "value": "Blueprint",
    "snippet": "class Blueprint {\r\n    public logger: Logger;\r\n\r\n    public name: string;\r\n\r\n    public id: string;\r\n\r\n    public functions: Map<string, AbstractFunction> = new Map<string, AbstractFunction>();\r\n    public variables: Map<string, Property> = new Map<string, Property>();\r\n\r\n    private _onConstructor: Graph;\r\n\r\n    get onConstructor(): Graph {\r\n        return this._onConstructor;\r\n    }\r\n\r\n    set onConstructor(newOnConstructor: Graph) {\r\n        if (newOnConstructor !== this._onConstructor) {\r\n            newOnConstructor.setCtx(this);\r\n            this._onConstructor = newOnConstructor;\r\n        }\r\n    }\r\n\r\n    private _beginPlay: Graph;\r\n\r\n    get beginPlay(): Graph {\r\n        return this._beginPlay;\r\n    }\r\n\r\n    set beginPlay(newBeginPlay: Graph) {\r\n        if (newBeginPlay !== this._beginPlay) {\r\n            newBeginPlay.setCtx(this);\r\n            this._beginPlay = newBeginPlay;\r\n        }            \r\n    }\r\n\r\n    private _tick: Graph;\r\n\r\n    get tick(): Graph {\r\n        return this._tick;\r\n    }\r\n\r\n    set tick(newTick: Graph) {\r\n        if (newTick !== this._tick){\r\n            newTick.setCtx(this);\r\n            this._tick = newTick;\r\n        }\r\n    }\r\n\r\n    constructor(name?: string){\r\n        this.name = name;\r\n        const uuid = uid();\r\n        this.id = `blueprint-${uuid}`;\r\n        this.logger = new Logger(`Blueprint::${uuid}`);\r\n        this._onConstructor?.exec()\r\n    }\r\n\r\n    start(){\r\n        this._beginPlay?.exec();\r\n\r\n        if(this._tick)\r\n            setTimeout(() => this._tick?.exec(), 1);\r\n    }\r\n\r\n    catch(e: any){\r\n        \r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/blueprint.ts",
    "type": "Constant",
    "value": "uuid",
    "snippet": "const uuid = uid();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/blueprint.ts",
    "type": "Class",
    "value": "Instance",
    "snippet": "class Instance extends Graph {\r\n\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/compile.ts",
    "type": "Class",
    "value": "BlueprintCompile",
    "snippet": "class BlueprintCompile {\r\n    public static async start(){\r\n        const files = await fg([            \r\n            './src/blueprints/**/*.blueprint.json', \r\n            './dist/blueprints/**/*.blueprint.json', \r\n            './src/blueprints/*.blueprint.json',\r\n            './dist/blueprints/*.blueprint.json'\r\n        ], {\r\n            ignore: ['node_modules/**'],\r\n            cwd: process.cwd()\r\n        });\r\n    \r\n        for await (let filename of files) {\r\n            const blueprintMetadata: BlueprintMetadata = require(path.resolve(filename));\r\n            const transpiledCode = await BlueprintTranspile.transpileBlueprint(blueprintMetadata);\r\n            const outputFilename = filename.replace('.blueprint.json', '.blueprint.ts');\r\n            fs.writeFileSync(outputFilename, transpiledCode);\r\n            console.log(`Generated ${outputFilename}`);\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/compile.ts",
    "type": "Constant",
    "value": "files",
    "snippet": "const files = await fg([            \r\n            './src/blueprints/**/*.blueprint.json', \r\n            './dist/blueprints/**/*.blueprint.json', \r\n            './src/blueprints/*.blueprint.json',\r\n            './dist/blueprints/*.blueprint.json'\r\n        ], {\r\n            ignore: ['node_modules/**'],\r\n            cwd: process.cwd()\r\n        });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/compile.ts",
    "type": "Constant",
    "value": "blueprintMetadata",
    "snippet": "const blueprintMetadata: BlueprintMetadata = require(path.resolve(filename));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/compile.ts",
    "type": "Constant",
    "value": "transpiledCode",
    "snippet": "const transpiledCode = await BlueprintTranspile.transpileBlueprint(blueprintMetadata);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/compile.ts",
    "type": "Constant",
    "value": "outputFilename",
    "snippet": "const outputFilename = filename.replace('.blueprint.json', '.blueprint.ts');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/event.ts",
    "type": "Class",
    "value": "NodeEvent",
    "snippet": "class NodeEvent {\r\n    private context: Blueprint;\r\n    public exec: NodeGraph;\r\n    public inputs: Array<Property> = new Array<Property>();\r\n\r\n    constructor(cxt: Blueprint, args?: Array<Property>){\r\n        this.context = cxt;\r\n        this.inputs = args;\r\n    }\r\n\r\n    public start(){\r\n        this.exec.execute(this.context);\r\n    }\r\n\r\n    public addInput(property: Property){\r\n        this.inputs.push(property);\r\n    }\r\n\r\n    public moveInput(oldIndex: number, newIndex: number): void {\r\n        if (oldIndex < 0 || oldIndex >= this.inputs.length || newIndex < 0 || newIndex >= this.inputs.length)\r\n            return;\r\n\r\n        const [movedElement] = this.inputs.splice(oldIndex, 1); \r\n        this.inputs.splice(newIndex, 0, movedElement); \r\n    }\r\n\r\n    public updateInput(index: number, newProperty: Property): void {\r\n        if (index < 0 || index >= this.inputs.length) \r\n            return;\r\n        \r\n        this.inputs[index] = newProperty;\r\n    }\r\n\r\n    public removeInput(index: number): void {\r\n        if (index < 0 || index >= this.inputs.length) \r\n            return;\r\n        \r\n        this.inputs.splice(index, 1);  \r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/functions.ts",
    "type": "Class",
    "value": "AbstractFunction",
    "snippet": "class AbstractFunction extends Graph {\r\n    private localVariables: Map<string, Property> = new Map<string, Property>();\r\n    protected result: Subject<AbstractFunction> = new Subject<AbstractFunction>();\r\n    \r\n    set(name: string, value: Property){\r\n        this.localVariables.set(name, value);\r\n    }\r\n\r\n    get(name){\r\n        return this.localVariables.has(name) ? this.localVariables.get(name) : null;\r\n    }\r\n\r\n    public end($args?: any[]): void {\r\n        this.result.next(this);\r\n    }\r\n\r\n    public endNode($args?: any[]): NodeGraph {\r\n        const self = this;\r\n        const nodeGraph = new NodeGraph(this.id, this.ctx);\r\n\r\n        nodeGraph.execute = () => {\r\n            self.result.next(self);\r\n        };\r\n        \r\n        return nodeGraph;\r\n    }\r\n\r\n    public await($args?: any[]): Promise<any> {\r\n        return new Promise((result) => {  \r\n            this.result.subscribe((context) => result(context));\r\n        });\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/functions.ts",
    "type": "Constant",
    "value": "self",
    "snippet": "const self = this;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/functions.ts",
    "type": "Constant",
    "value": "nodeGraph",
    "snippet": "const nodeGraph = new NodeGraph(this.id, this.ctx);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/graph.ts",
    "type": "Class",
    "value": "Graph",
    "snippet": "class Graph {\r\n    public logger: Logger;\r\n\r\n    public ctx: Blueprint;\r\n\r\n    public id: string;\r\n\r\n    public _next: NodeGraph;\r\n\r\n    get next(): NodeGraph {\r\n        return this._next;\r\n    }\r\n\r\n    set next(newValue: NodeGraph) {\r\n        if(newValue && newValue instanceof NodeGraph) {\r\n            newValue.setCtx(this.ctx); \r\n            newValue.setRoot(this);\r\n            newValue.onChange.subscribe((node) => this._next = node); \r\n            this._next = newValue;    \r\n        }            \r\n        else {\r\n            throw new Error(`Error when trying to configure next node ${this.id}`);\r\n        }     \r\n    }\r\n\r\n    constructor(ctx?: Blueprint){\r\n        const uuid = uid();\r\n        this.id = `graph-${uuid}`;\r\n        this.ctx = (ctx) ? ctx : new Blueprint();\r\n        this.logger = new Logger(`Graph::${uuid}`);\r\n    }\r\n\r\n    public exec($args?: any[]){\r\n        if(process.env.NODE_ENV === \"dev\")\r\n            this.logger.log(`Execute graph`);\r\n        \r\n        this.next.execute(this.ctx, $args);\r\n    }\r\n\r\n    public setCtx(ctx: Blueprint){\r\n        this.ctx = ctx;\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/graph.ts",
    "type": "Constant",
    "value": "uuid",
    "snippet": "const uuid = uid();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/graph.ts",
    "type": "Class",
    "value": "BeginPlay",
    "snippet": "class BeginPlay extends Graph {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/graph.ts",
    "type": "Class",
    "value": "TickGraph",
    "snippet": "class TickGraph extends Graph {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/node.ts",
    "type": "Interface",
    "value": "INodeGraph",
    "snippet": "interface INodeGraph {\r\n    execute(ctx: Blueprint, $args: any[]): void;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/node.ts",
    "type": "Class",
    "value": "NodeGraph",
    "snippet": "class NodeGraph implements INodeGraph {\r\n    public logger: Logger;\r\n    \r\n    public namespace: string;\r\n\r\n    public id: string;\r\n\r\n    public ctx: Blueprint;\r\n\r\n    public root: NodeGraph | Graph;\r\n    \r\n    public _next: NodeGraph;\r\n\r\n    get next(): NodeGraph {\r\n        return this._next;\r\n    }\r\n\r\n    set next(newValue: NodeGraph) {\r\n        if(newValue && newValue instanceof NodeGraph) {\r\n            newValue.setCtx(this.ctx);  \r\n            newValue.setRoot(this);\r\n            newValue.onChange.subscribe((node) => this._next = node); \r\n            this._next = newValue;\r\n            this.onChange.next(this);\r\n        }      \r\n        else {\r\n            throw new Error(`Error when trying to configure next node ${this.namespace}::${this.id}`);\r\n        }  \r\n    }\r\n\r\n    public onChange = new Subject<NodeGraph>();\r\n\r\n    constructor(namespace: string, ctx?: Blueprint){\r\n        if(namespace){\r\n            const uuid = uid();\r\n            this.id = `node-${uuid}`;\r\n            this.namespace = namespace;\r\n            this.ctx = ctx;        \r\n            this.logger = new Logger(`Node::${uuid}`);                  \r\n        }\r\n    }\r\n\r\n    setCtx(ctx: Blueprint): void {\r\n        this.ctx = ctx;\r\n    }\r\n\r\n    setRoot(node: NodeGraph | Graph): void {\r\n        this.root = node;\r\n    }\r\n\r\n    set(name: string, value: Property): void {\r\n        this[name] = value;\r\n    }\r\n\r\n    get(name): Property | null {\r\n        return this[name] && this[name] instanceof Property ? this[name] : null;\r\n    }\r\n\r\n    getNodeParameter<T = any>(name: string): T | undefined {\r\n        if(this[name] && this[name] instanceof Property)\r\n            return (this[name] as Property).value as T;\r\n        else\r\n            return undefined;\r\n    }\r\n    \r\n    execute(ctx: Blueprint, $args?: any[]): void {\r\n        throw new Error(\"Method not implemented.\");\r\n    }    \r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/node.ts",
    "type": "Constant",
    "value": "uuid",
    "snippet": "const uuid = uid();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/property.ts",
    "type": "Class",
    "value": "Property",
    "snippet": "class Property<T = any> {\r\n    private _options: any[];\r\n    private _subject: Subject<T>;\r\n    private _value: T;\r\n\r\n    constructor(initialValue?: T, options?: any[]) {\r\n        this._subject = new Subject<T>();\r\n        this._value = initialValue;\r\n        this._options = options;\r\n    }\r\n\r\n    get value(): T {\r\n        return this._value;\r\n    }\r\n\r\n    set value(newValue: T) {\r\n        if (newValue !== this._value) {\r\n            if(this._options){\r\n                const hasOption = this._options.filter((value) => value.name === newValue);\r\n\r\n                if(hasOption.length > 0){\r\n                    this._value = hasOption[0].value;\r\n                    this._subject.next(hasOption[0].value);\r\n                }\r\n            }\r\n            else {\r\n                this._value = newValue;\r\n                this._subject.next(newValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    get(): T {\r\n        return this._value;\r\n    }\r\n\r\n    set(newValue: T): void {\r\n        if (newValue !== this._value) {\r\n            this._value = newValue;\r\n            this._subject.next(newValue);\r\n        }\r\n    }\r\n\r\n    get observable(): Subject<T> {\r\n        return this._subject;\r\n    }\r\n\r\n    subscribe(cb: any){\r\n        return this._subject.subscribe(cb);\r\n    }\r\n\r\n    link(prop: Property, fn?: Function){\r\n        let currentValue = prop._value;\r\n\r\n        if(fn && typeof fn === \"function\")\r\n            currentValue = fn(currentValue);\r\n\r\n        this.value = currentValue;\r\n\r\n        prop.subscribe((value) => {\r\n            if(fn && typeof fn === \"function\")\r\n                value = fn(value);\r\n\r\n            this.value = value;\r\n        });\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/property.ts",
    "type": "Constant",
    "value": "hasOption",
    "snippet": "const hasOption = this._options.filter((value) => value.name === newValue);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/property.ts",
    "type": "Class",
    "value": "ArrayProperty",
    "snippet": "class ArrayProperty<T> extends Property<Array<T>> {\r\n    constructor(initialValue: Array<T> = []) {\r\n        super(initialValue);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/property.ts",
    "type": "Class",
    "value": "MapProperty",
    "snippet": "class MapProperty<K, V> extends Property<Map<K, V>> {\r\n    constructor(initialValue: Map<K, V> = new Map()) {\r\n        super(initialValue);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/lib/property.ts",
    "type": "Class",
    "value": "SetProperty",
    "snippet": "class SetProperty<T> extends Property<Set<T>> {\r\n    constructor(initialValue: Set<T> = new Set()) {\r\n        super(initialValue);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/registries/node.registry.ts",
    "type": "Class",
    "value": "NodeRegistry",
    "snippet": "class NodeRegistry {\r\n    private static nodes = new Map<string, new() => NodeGraph>();\r\n\r\n    public static registerHandler(\r\n        target: new() => NodeGraph,\r\n        name: string,\r\n        alias?: string\r\n    ) {\r\n        Reflect.defineMetadata(\r\n            'node_metadata',\r\n            { name, alias },\r\n            target,\r\n        );\r\n\r\n        this.nodes.set(name, target);\r\n\r\n        if(alias)\r\n            this.nodes.set(alias, target);\r\n    }\r\n\r\n    public static getNodes() : Map<string, new() => NodeGraph>{\r\n        return this.nodes;\r\n    }\r\n\r\n    public static getNode(name?: string) : new() => NodeGraph | null {\r\n        return this.nodes.has(name) ? this.nodes.get(name) : null;\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "ImportMetadata",
    "snippet": "interface ImportMetadata {\r\n    module?: string;\r\n    deconstructor?: boolean;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "BlueprintMetadata",
    "snippet": "interface BlueprintMetadata {\r\n    name: string;\r\n    extends?: string;\r\n    imports?: { [key: string]: string | ImportMetadata };\r\n    beginplay?: { next: string };\r\n    functions?: Array<FunctionMetadata>;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "FunctionMetadata",
    "snippet": "interface FunctionMetadata {\r\n    name: string;\r\n    next: string;\r\n    localVariables: Array<LocalVariable>;\r\n    graph: Array<GraphNode>;\r\n    outputs: Array<FunctionOutput> | FunctionOutput;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "FunctionOutput",
    "snippet": "interface FunctionOutput {\r\n    name: string;\r\n    type: string;\r\n    node?: string;\r\n    property: string;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "LocalVariable",
    "snippet": "interface LocalVariable {\r\n    name: string;\r\n    type: string;\r\n    defaultValue?: any;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "GraphNode",
    "snippet": "interface GraphNode {\r\n    name: string;\r\n    node: string;\r\n    next?: string;\r\n    link?: Array<LinkMetadata>;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Interface",
    "value": "LinkMetadata",
    "snippet": "interface LinkMetadata {\r\n    node: string;\r\n    property: string;\r\n    nodeTo: string;\r\n    to: string;\r\n    fn?: string;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Class",
    "value": "BlueprintTranspile",
    "snippet": "class BlueprintTranspile implements ITranspile {\r\n    private logger: Logger = new Logger('BlueprintTranspile');\r\n\r\n    run(): void {}\r\n\r\n    static async transpileBlueprint(json: BlueprintMetadata) {\r\n        const { name, imports, beginplay, functions } = json;\r\n    \r\n        if(!json.extends)\r\n            json.extends = \"Blueprint\";\r\n    \r\n        let result = '// Generated automatically by CMMV\\n\\n';\r\n    \r\n        result += 'import { \\n';\r\n        result += `    $, Blueprint, \r\n    BeginPlay, AbstractFunction,\r\n    Property, CFunction, CClass\r\n} from \"@cmmv/blueprint\";\\n\\n`;\r\n        \r\n        const allNodes = new Set<string>();\r\n        let nodesImports = \"\";\r\n    \r\n        functions?.forEach(func => {\r\n            func.graph.forEach(graph => {\r\n                allNodes.add(graph.node);\r\n            });\r\n        });\r\n\r\n        allNodes.forEach(node => {\r\n            nodesImports += `    Node${BlueprintTranspile.capitalizeFirstLetter(node)},\\n`;\r\n        });\r\n    \r\n        result += `import {\\n${nodesImports.slice(0, nodesImports.length -2)}\\n} from \"@cmmv/nodes\";\\n\\n`;\r\n    \r\n        Object.keys(imports).forEach(key => {\r\n            if(typeof imports[key] === \"string\")\r\n                result += `import * as ${key} from \"${imports[key]}\";\\n`;\r\n            else if(typeof imports[key] === \"object\") {\r\n                const module = (imports[key] as ImportMetadata).module || \"@cmmv/blueprint\";\r\n                const deconstructor = (imports[key] as ImportMetadata).deconstructor || false;\r\n            \r\n                if(deconstructor)\r\n                    result += `import { ${key} } from \"${module}\";\\n\\n`;\r\n                else\r\n                    result += `import * as ${key} from \"${module}\";\\n\\n`;\r\n            }\r\n        });\r\n    \r\n        functions?.forEach(func => {\r\n            if (func.outputs && Array.isArray(func.outputs)) {\r\n                result += `interface ${BlueprintTranspile.capitalizeFirstLetter(func.name)}Return {\\n`;\r\n    \r\n                func.outputs.forEach(output => {\r\n                    result += `    ${output.name}: Property<${output.type}>,\\n`;\r\n                });\r\n    \r\n                result += `}\\n`;\r\n            }\r\n        });\r\n    \r\n        result += '\\n';\r\n        result += `@CClass(\"${name}\")\\n`;\r\n        result += `export class ${name} extends ${json.extends} {\r\n    \r\n    ${json.extends === \"Blueprint\" ? `constructor(name?: string){\r\n        super(name);\r\n        this.beginPlay = new BeginPlay(this);\r\n    }\\n\\n`: ''}`;\r\n    \r\n        let lastNode;\r\n    \r\n        functions?.forEach(func => {\r\n            result += `    @CFunction({})\\n`;\r\n            result += `    public async ${func.name} (): Promise<${func.outputs && Array.isArray(func.outputs) ? BlueprintTranspile.capitalizeFirstLetter(func.name) + 'Return' : 'void'}> {\\n`;        \r\n            result += `        const ${func.name} = new AbstractFunction(this);\\n\\n`;\r\n    \r\n            func.localVariables.forEach((variable) => {\r\n                result += `        ${func.name}.set(\"${variable.name}\", new Property<${variable.type}>(${(variable.type !== \"string\") ? variable.defaultValue : `\"${variable.defaultValue}\"`}));\\n`;\r\n            })\r\n    \r\n            func.graph.forEach(graphNode => {\r\n                const nodeVar = `${graphNode.name}`;\r\n                result += `        const ${nodeVar} = $.createNodeInstance<Node${BlueprintTranspile.capitalizeFirstLetter(graphNode.node)}>(\"${graphNode.node}\");\\n`;\r\n                lastNode = nodeVar;\r\n    \r\n                if (graphNode.next) {\r\n                    result += `        ${func.name}.next = ${nodeVar};\\n`;\r\n                }\r\n    \r\n                if (graphNode.link) {\r\n                    graphNode.link.forEach(link => {\r\n                        result += `        ${link.node}.get(\"${link.property}\")?.link(${link.nodeTo}.${link.to}`;\r\n                        if (link.fn) {\r\n                            result += `, ${link.fn}`;\r\n                        }\r\n                        result += `);\\n`;\r\n                    });\r\n                }\r\n    \r\n                result += ` \\n`;\r\n            });\r\n    \r\n            result += `        ${lastNode}.next = ${func.name}.endNode();\\n`;\r\n            result += `        await ${func.name}.await();\\n`;\r\n    \r\n            if(func.outputs && Array.isArray(func.outputs)) {\r\n                let outputs = [];\r\n    \r\n                func.outputs.forEach(output => {\r\n                    outputs.push(`${output.name}: ${output.node}.get(\"${output.property}\")`);\r\n                });\r\n    \r\n                result += `        return { ${outputs.join(\", \")} };\\n`;\r\n            }\r\n            else{\r\n                result += `        return;`;\r\n            }\r\n            \r\n            result += `    }\\n\\n`;\r\n        });\r\n    \r\n        result += '}\\n';\r\n    \r\n        return result;\r\n    }\r\n\r\n    static capitalizeFirstLetter(str: string): string {\r\n        return str.charAt(0).toUpperCase() + str.slice(1);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Constant",
    "value": "allNodes",
    "snippet": "const allNodes = new Set<string>();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Constant",
    "value": "module",
    "snippet": "const module = (imports[key] as ImportMetadata).module || \"@cmmv/blueprint\";"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Constant",
    "value": "deconstructor",
    "snippet": "const deconstructor = (imports[key] as ImportMetadata).deconstructor || false;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/blueprint/transpilers/blueprints.transpile.ts",
    "type": "Constant",
    "value": "nodeVar",
    "snippet": "const nodeVar = `${graphNode.name}`;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/clean.ts",
    "type": "Function",
    "value": "cleanOutput",
    "snippet": "function cleanOutput() {\n    return src(\n        [\n            `${source}/**/*.js`,\n            `${source}/**/*.d.ts`,\n            `${source}/**/*.js.map`,\n            `${source}/**/*.d.ts.map`,\n            `${source}/**/*.ts.map`,\n            `!${source}/**/globals.d.ts`,\n            `!${source}/**/*.config.js`,\n        ],\n        {\n            read: false,\n        },\n    ).pipe(clean({ force: true }));\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/clean.ts",
    "type": "Function",
    "value": "cleanDirs",
    "snippet": "function cleanDirs(done: () => void) {\n    deleteEmpty.sync(`${source}/`);\n    done();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/copy-misc.ts",
    "type": "Function",
    "value": "copyMisc",
    "snippet": "function copyMisc(): NodeJS.ReadWriteStream {\r\n  const miscFiles = src(['Readme.md', 'LICENSE', '.npmignore', '**/*.node.json' ]);\r\n\r\n  return packagePaths.reduce(\r\n    (stream, packagePath) => stream.pipe(dest(packagePath)),\r\n    miscFiles,\r\n  );\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/copy-misc.ts",
    "type": "Constant",
    "value": "miscFiles",
    "snippet": "const miscFiles = src(['Readme.md', 'LICENSE', '.npmignore', '**/*.node.json' ]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/move.ts",
    "type": "Constant",
    "value": "distFiles",
    "snippet": "const distFiles = src([\r\n    'packages/**/*',\r\n    '!packages/**/*.ts',\r\n    'packages/**/*.d.ts',\r\n]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/tasks/move.ts",
    "type": "Function",
    "value": "move",
    "snippet": "function move() {\r\n    return distFiles.pipe(dest('node_modules/@cmmv'));\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "isDirectory",
    "snippet": "function isDirectory(path: string) {\r\n    return statSync(path).isDirectory();\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "getFolders",
    "snippet": "function getFolders(dir: string) {\r\n    return readdirSync(dir).filter(file => isDirectory(join(dir, file)));\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "getDirs",
    "snippet": "function getDirs(base: string) {\r\n    return getFolders(base).map(path => `${base}/${path}`);\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "containsPackageJson",
    "snippet": "function containsPackageJson(dir: string) {\r\n    return readdirSync(dir).some(file => file === 'package.json');\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Interface",
    "value": "BodyParserJSONOptions",
    "snippet": "interface BodyParserJSONOptions {\n    limit?: number | string;\n    inflate?: boolean;\n    reviver?: any;\n    strict?: boolean;\n    type?: string;\n    verify?: boolean | Function;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "FIRST_CHAR_REGEXP",
    "snippet": "const FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "JSON_SYNTAX_CHAR",
    "snippet": "const JSON_SYNTAX_CHAR = '#';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "JSON_SYNTAX_REGEXP",
    "snippet": "const JSON_SYNTAX_REGEXP = /#+/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "bodywith",
    "snippet": "const bodywith = new Set(['DELETE', 'OPTIONS', 'PATCH', 'PUT', 'POST']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Class",
    "value": "BodyParserJSONMiddleware",
    "snippet": "class BodyParserJSONMiddleware {\n    public middlewareName: string = 'body-parse-json';\n\n    private options: BodyParserJSONOptions;\n\n    constructor(options?: BodyParserJSONOptions) {\n        this.options = {\n            limit:\n                typeof options?.limit !== 'number'\n                    ? bytes.parse(options?.limit || '100kb')\n                    : options?.limit,\n            inflate: options?.inflate !== false,\n            reviver: options?.reviver,\n            strict: options?.strict !== false,\n            type: options?.type || 'application/json',\n            verify: options?.verify || false,\n        };\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addContentTypeParser == 'function') {\n            req.app.addContentTypeParser(\n                ['application/json', 'text/json', 'application/vnd.api+json'],\n                this.cmmvMiddleware.bind(this),\n            );\n        } else this.expressMiddleware.call(this, req, res, next);\n    }\n\n    expressMiddleware(req, res, done) {\n        if (!bodywith.has(req.method.toUpperCase())) {\n            done(null);\n            return;\n        }\n\n        if (isFinished(req as http.IncomingMessage)) {\n            done(null);\n            return;\n        }\n\n        if (!('body' in req)) req['body'] = undefined;\n\n        if (!typeis.hasBody(req as http.IncomingMessage)) {\n            done(null);\n            return;\n        }\n\n        const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;\n\n        if (!shouldParse(req)) {\n            done(null);\n            return;\n        }\n\n        const charset = this.getCharset(req) || 'utf-8';\n\n        if (charset.slice(0, 4) !== 'utf-') {\n            done(\n                createError(\n                    415,\n                    'unsupported charset \"' + charset.toUpperCase() + '\"',\n                    {\n                        charset: charset,\n                        type: 'charset.unsupported',\n                    },\n                ),\n            );\n            return;\n        }\n\n        read(req, res, done, this.parse.bind(this), {\n            encoding: charset,\n            inflate: this.options.inflate,\n            limit: this.options.limit,\n            verify: this.options.verify,\n        });\n    }\n\n    cmmvMiddleware(req, res, payload, done) {\n        return new Promise((resolve, reject) => {\n            if (!bodywith.has(req.method.toUpperCase())) {\n                resolve(null);\n                return;\n            }\n\n            if (isFinished(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!('body' in req)) req['body'] = undefined;\n\n            if (!typeis.hasBody(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;\n\n            if (!shouldParse(req)) {\n                resolve(null);\n                return;\n            }\n\n            const charset = this.getCharset(req) || 'utf-8';\n\n            if (charset.slice(0, 4) !== 'utf-') {\n                resolve(\n                    createError(\n                        415,\n                        'unsupported charset \"' + charset.toUpperCase() + '\"',\n                        {\n                            charset: charset,\n                            type: 'charset.unsupported',\n                        },\n                    ),\n                );\n                return;\n            }\n\n            read(req, res, resolve, this.parse.bind(this), {\n                encoding: charset,\n                inflate: this.options.inflate,\n                limit: this.options.limit,\n                verify: this.options.verify,\n            });\n        });\n    }\n\n    private parse(body) {\n        if (body.length === 0) {\n            // special-case empty json body, as it's a common client-side mistake\n            // TODO: maybe make this configurable or part of \"strict\" option\n            return {};\n        }\n\n        if (this.options.strict) {\n            const first = this.firstchar(body);\n\n            if (first !== '{' && first !== '[')\n                throw this.createStrictSyntaxError(body, first);\n        }\n\n        try {\n            return JSON.parse(body, this.options.reviver);\n        } catch (e) {\n            throw this.normalizeJsonSyntaxError(e, {\n                message: e.message,\n                stack: e.stack,\n            });\n        }\n    }\n\n    /**\n     * Create strict violation syntax error matching native error.\n     *\n     * @param {string} str\n     * @param {string} char\n     * @return {Error}\n     * @private\n     */\n    private createStrictSyntaxError(str: string, char: string) {\n        const index = str.indexOf(char);\n        let partial = '';\n\n        if (index !== -1) {\n            partial = str.substring(0, index) + JSON_SYNTAX_CHAR;\n\n            for (let i = index + 1; i < str.length; i++)\n                partial += JSON_SYNTAX_CHAR;\n        }\n\n        try {\n            JSON.parse(partial);\n            /* istanbul ignore next */\n            throw new SyntaxError('strict violation');\n        } catch (e) {\n            return this.normalizeJsonSyntaxError(e, {\n                message: e.message.replace(\n                    JSON_SYNTAX_REGEXP,\n                    function (placeholder) {\n                        return str.substring(index, index + placeholder.length);\n                    },\n                ),\n                stack: e.stack,\n            });\n        }\n    }\n\n    /**\n     * Get the first non-whitespace character in a string.\n     *\n     * @param {string} str\n     * @return {function}\n     * @private\n     */\n    private firstchar(str): string | undefined {\n        const match = FIRST_CHAR_REGEXP.exec(str);\n        return match ? match[1] : undefined;\n    }\n\n    /**\n     * Get the charset of a request.\n     *\n     * @param {object} req\n     * @api private\n     */\n    private getCharset(req) {\n        try {\n            return (\n                contentType.parse(req).parameters.charset || ''\n            ).toLowerCase();\n        } catch (e) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Normalize a SyntaxError for JSON.parse.\n     *\n     * @param {SyntaxError} error\n     * @param {object} obj\n     * @return {SyntaxError}\n     */\n    private normalizeJsonSyntaxError(error, obj) {\n        const keys = Object.getOwnPropertyNames(error);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n\n            if (key !== 'stack' && key !== 'message') delete error[key];\n        }\n\n        // replace stack before message for Node.js 0.10 and below\n        error.stack = obj.stack.replace(error.message, obj.message);\n        error.message = obj.message;\n\n        return error;\n    }\n\n    /**\n     * Get the simple type checker.\n     *\n     * @param {string} type\n     * @return {function}\n     */\n    private typeChecker(type: any) {\n        return function checkType(req) {\n            const isIRequest = req && req.httpRequest;\n            return Boolean(typeis(isIRequest ? req.httpRequest : req, type));\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || 'utf-8';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || 'utf-8';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "first",
    "snippet": "const first = this.firstchar(body);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "index",
    "snippet": "const index = str.indexOf(char);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "match",
    "snippet": "const match = FIRST_CHAR_REGEXP.exec(str);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "keys",
    "snippet": "const keys = Object.getOwnPropertyNames(error);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key = keys[i];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "isIRequest",
    "snippet": "const isIRequest = req && req.httpRequest;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/json.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserJSONMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Interface",
    "value": "BodyParserRawOptions",
    "snippet": "interface BodyParserRawOptions {\n    limit?: number | string;\n    inflate?: boolean;\n    type?: string;\n    verify?: boolean | Function;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Class",
    "value": "BodyParserRawMiddleware",
    "snippet": "class BodyParserRawMiddleware {\n    public middlewareName: string = 'body-parse-raw';\n\n    private options: BodyParserRawOptions;\n\n    constructor(options?: BodyParserRawOptions) {\n        this.options = {\n            limit:\n                typeof options?.limit !== 'number'\n                    ? bytes.parse(options?.limit || '100kb')\n                    : options?.limit,\n            inflate: options?.inflate !== false,\n            type: options?.type || 'application/octet-stream',\n            verify: options?.verify || false,\n        };\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addContentTypeParser == 'function') {\n            req.app.addContentTypeParser(\n                ['*', 'application/vnd+octets', 'application/octet-stream'],\n                this.cmmvMiddleware.bind(this),\n            );\n        } else this.expressMiddleware.call(this, req, res, next);\n    }\n\n    expressMiddleware(req, res, done) {\n        const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;\n\n        function parse(buf) {\n            return buf;\n        }\n\n        if (isFinished(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!('body' in req)) req['body'] = undefined;\n\n        if (!typeis.hasBody(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!shouldParse(req)) {\n            done();\n            return;\n        }\n\n        read(req, res, done, parse.bind(this), {\n            encoding: null,\n            inflate: this.options.inflate,\n            limit: this.options.limit,\n            verify: this.options.verify,\n        });\n    }\n\n    cmmvMiddleware(req, res, payload, done) {\n        return new Promise((resolve, reject) => {\n            const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;\n\n            function parse(buf) {\n                return buf;\n            }\n\n            if (isFinished(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!('body' in req)) req['body'] = undefined;\n\n            if (!typeis.hasBody(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!shouldParse(req)) {\n                resolve(null);\n                return;\n            }\n\n            read(req, res, resolve, parse.bind(this), {\n                encoding: null,\n                inflate: this.options.inflate,\n                limit: this.options.limit,\n                verify: this.options.verify,\n            });\n        });\n    }\n\n    /**\n     * Get the simple type checker.\n     *\n     * @param {string} type\n     * @return {function}\n     */\n    private typeChecker(type: any) {\n        return function checkType(req) {\n            const isIRequest = req && req.httpRequest;\n            return Boolean(typeis(isIRequest ? req.httpRequest : req, type));\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(buf) {\n            return buf;\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(buf) {\n                return buf;\n            }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Constant",
    "value": "isIRequest",
    "snippet": "const isIRequest = req && req.httpRequest;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/raw.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserRawMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "destroy",
    "snippet": "const destroy = require('destroy');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "hasBrotliSupport",
    "snippet": "const hasBrotliSupport = 'createBrotliDecompress' in zlib;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Function",
    "value": "read",
    "snippet": "function read(req, res, next, parse, options) {\n    let length;\n    const opts = options;\n    let stream;\n\n    const encoding = opts.encoding !== null ? opts.encoding : null;\n    const verify = opts.verify;\n\n    try {\n        stream = contentstream(req, opts.inflate);\n        length = stream.length;\n        stream.length = undefined;\n    } catch (err) {\n        //console.error(err);\n        return next(err);\n    }\n\n    opts.length = length;\n    opts.encoding = verify ? null : encoding;\n\n    if (\n        opts.encoding === null &&\n        encoding !== null &&\n        !iconv.encodingExists(encoding)\n    ) {\n        return next(\n            createError(\n                415,\n                'unsupported charset \"' + encoding.toUpperCase() + '\"',\n                {\n                    charset: encoding.toLowerCase(),\n                    type: 'charset.unsupported',\n                },\n            ),\n        );\n    }\n\n    getBody(stream, opts, function (error, body) {\n        if (error) {\n            let _error;\n\n            if (error.type === 'encoding.unsupported') {\n                _error = createError(\n                    415,\n                    'unsupported charset \"' + encoding.toUpperCase() + '\"',\n                    {\n                        charset: encoding.toLowerCase(),\n                        type: 'charset.unsupported',\n                    },\n                );\n            } else {\n                _error = createError(400, error);\n            }\n\n            if (stream !== req) {\n                unpipe(req);\n                destroy(stream, true);\n            }\n\n            dump(req, function onfinished() {\n                next(createError(400, _error));\n            });\n\n            return;\n        }\n\n        if (verify) {\n            try {\n                verify(req, res, body, encoding);\n            } catch (err) {\n                next(\n                    createError(403, err, {\n                        body: body,\n                        type: err.type || 'entity.verify.failed',\n                    }),\n                );\n                return;\n            }\n        }\n\n        let str = body;\n\n        try {\n            str =\n                typeof body !== 'string' && encoding !== null\n                    ? iconv.decode(body, encoding)\n                    : body;\n\n            req.body = parse(str, encoding);\n        } catch (err) {\n            next(\n                createError(400, err, {\n                    body: str,\n                    type: err.type || 'entity.parse.failed',\n                }),\n            );\n            return;\n        }\n\n        next();\n    });\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts = options;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding = opts.encoding !== null ? opts.encoding : null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "verify",
    "snippet": "const verify = opts.verify;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Function",
    "value": "contentstream",
    "snippet": "function contentstream(request, inflate) {\n    const encoding = (\n        request.headers['content-encoding'] || 'identity'\n    ).toLowerCase();\n    const length = request.headers['content-length'];\n    const req = request.req || request;\n    let stream;\n\n    if (inflate === false && encoding !== 'identity') {\n        throw createError(415, 'content encoding unsupported', {\n            encoding: encoding,\n            type: 'encoding.unsupported',\n        });\n    }\n\n    switch (encoding) {\n        case 'deflate':\n            stream = zlib.createInflate();\n            req.pipe(stream);\n            break;\n        case 'gzip':\n            stream = zlib.createGunzip();\n            req.pipe(stream);\n            break;\n        case 'br':\n            if (hasBrotliSupport) {\n                stream = zlib.createBrotliDecompress();\n                req.pipe(stream);\n            }\n            break;\n        case 'identity':\n            stream = req;\n            stream.length = length;\n            break;\n    }\n\n    if (stream === undefined) {\n        throw createError(\n            415,\n            'unsupported content encoding \"' + encoding + '\"',\n            {\n                encoding: encoding,\n                type: 'encoding.unsupported',\n            },\n        );\n    }\n\n    return stream;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding = (\n        request.headers['content-encoding'] || 'identity'\n    ).toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "length",
    "snippet": "const length = request.headers['content-length'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Constant",
    "value": "req",
    "snippet": "const req = request.req || request;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/read.ts",
    "type": "Function",
    "value": "dump",
    "snippet": "function dump(req, callback) {\n    if (onFinished.isFinished(req)) {\n        callback(null);\n    } else {\n        onFinished(req, callback);\n        req.resume();\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Interface",
    "value": "BodyParserTextOptions",
    "snippet": "interface BodyParserTextOptions {\n    defaultCharset?: string;\n    limit?: number | string;\n    inflate?: boolean;\n    type?: string;\n    verify?: boolean | Function;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Class",
    "value": "BodyParserTextMiddleware",
    "snippet": "class BodyParserTextMiddleware {\n    public middlewareName: string = 'body-parse-text';\n\n    private options: BodyParserTextOptions;\n\n    constructor(options?: BodyParserTextOptions) {\n        this.options = {\n            limit:\n                typeof options?.limit !== 'number'\n                    ? bytes.parse(options?.limit || '100kb')\n                    : options?.limit,\n            inflate: options?.inflate !== false,\n            type: options?.type || 'text/plain',\n            verify: options?.verify || false,\n            defaultCharset: options?.defaultCharset || 'utf-8',\n        };\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addContentTypeParser == 'function') {\n            req.app.addContentTypeParser(\n                'text/plain',\n                this.cmmvMiddleware.bind(this),\n            );\n        } else this.expressMiddleware.call(this, req, res, next);\n    }\n\n    expressMiddleware(req, res, done) {\n        const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;\n\n        function parse(buf) {\n            return buf;\n        }\n\n        if (isFinished(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!('body' in req)) req['body'] = undefined;\n\n        if (!typeis.hasBody(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!shouldParse(req)) {\n            done();\n            return;\n        }\n\n        const charset = this.getCharset(req) || this.options.defaultCharset;\n\n        read(req, res, done, parse.bind(this), {\n            encoding: charset,\n            inflate: this.options.inflate,\n            limit: this.options.limit,\n            verify: this.options.verify,\n        });\n    }\n\n    cmmvMiddleware(req, res, payload, done) {\n        return new Promise((resolve, reject) => {\n            const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;\n\n            function parse(buf) {\n                return buf;\n            }\n\n            if (isFinished(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!('body' in req)) req['body'] = undefined;\n\n            if (!typeis.hasBody(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!shouldParse(req)) {\n                resolve(null);\n                return;\n            }\n\n            const charset = this.getCharset(req) || this.options.defaultCharset;\n\n            read(req, res, resolve, parse.bind(this), {\n                encoding: charset,\n                inflate: this.options.inflate,\n                limit: this.options.limit,\n                verify: this.options.verify,\n            });\n        });\n    }\n\n    /**\n     * Get the charset of a request.\n     *\n     * @param {object} req\n     * @api private\n     */\n    private getCharset(req) {\n        try {\n            return (\n                contentType.parse(req).parameters.charset || ''\n            ).toLowerCase();\n        } catch (e) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Get the simple type checker.\n     *\n     * @param {string} type\n     * @return {function}\n     */\n    private typeChecker(type: any) {\n        return function checkType(req) {\n            const isIRequest = req && req.httpRequest;\n            return Boolean(typeis(isIRequest ? req.httpRequest : req, type));\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(buf) {\n            return buf;\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || this.options.defaultCharset;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(buf) {\n                return buf;\n            }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || this.options.defaultCharset;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "isIRequest",
    "snippet": "const isIRequest = req && req.httpRequest;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/text.ts",
    "type": "Constant",
    "value": "middleware",
    "snippet": "const middleware = new BodyParserTextMiddleware(options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Interface",
    "value": "BodyParserUrlEncodedOptions",
    "snippet": "interface BodyParserUrlEncodedOptions {\n    extended?: boolean;\n    limit?: number | string;\n    inflate?: boolean;\n    type?: string;\n    verify?: boolean | Function;\n    defaultCharset?: string;\n    interpretNumericEntities?: boolean;\n    charsetSentinel?: boolean;\n    depth?: number;\n    parameterLimit?: number;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Class",
    "value": "BodyParserUrlEncodedMiddleware",
    "snippet": "class BodyParserUrlEncodedMiddleware {\n    public middlewareName: string = 'body-parse-urlencoded';\n\n    private options: BodyParserUrlEncodedOptions;\n\n    constructor(options?: BodyParserUrlEncodedOptions) {\n        this.options = {\n            limit:\n                typeof options?.limit !== 'number'\n                    ? bytes.parse(options?.limit || '100kb')\n                    : options?.limit,\n            inflate: options?.inflate !== false,\n            type: options?.type || 'application/x-www-form-urlencoded',\n            verify: options?.verify || false,\n            extended: Boolean(options?.extended),\n            defaultCharset: options?.defaultCharset || 'utf-8',\n            interpretNumericEntities: options?.interpretNumericEntities,\n            charsetSentinel: options?.charsetSentinel,\n            depth: Boolean(options?.extended)\n                ? options.depth !== undefined\n                    ? options.depth\n                    : 32\n                : 0,\n            parameterLimit:\n                options?.parameterLimit !== undefined\n                    ? options.parameterLimit\n                    : 1000,\n        };\n    }\n\n    async process(req, res, next?) {\n        if (req.app && typeof req.app.addContentTypeParser == 'function') {\n            req.app.addContentTypeParser(\n                'application/x-www-form-urlencoded',\n                this.cmmvMiddleware.bind(this),\n            );\n        } else this.expressMiddleware.call(this, req, res, next);\n    }\n\n    expressMiddleware(req, res, done) {\n        if (\n            this.options?.defaultCharset !== 'utf-8' &&\n            this.options?.defaultCharset !== 'iso-8859-1'\n        ) {\n            throw new TypeError(\n                'option defaultCharset must be either utf-8 or iso-8859-1',\n            );\n        }\n\n        const queryparse = this.createQueryParser(\n            this.options,\n            this.options.extended,\n        );\n\n        const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;\n\n        function parse(body, encoding) {\n            return body.length ? queryparse(body, encoding) : {};\n        }\n\n        if (isFinished(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!('body' in req)) req['body'] = undefined;\n\n        if (!typeis.hasBody(req as http.IncomingMessage)) {\n            done();\n            return;\n        }\n\n        if (!shouldParse(req)) {\n            done();\n            return;\n        }\n\n        const charset = this.getCharset(req) || this.options.defaultCharset;\n        if (charset !== 'utf-8' && charset !== 'iso-8859-1') {\n            done(\n                createError(\n                    415,\n                    'unsupported charset \"' + charset.toUpperCase() + '\"',\n                    {\n                        charset: charset,\n                        type: 'charset.unsupported',\n                    },\n                ),\n            );\n\n            return;\n        }\n\n        read(req, res, done, parse.bind(this), {\n            encoding: charset,\n            inflate: this.options.inflate,\n            limit: this.options.limit,\n            verify: this.options.verify,\n            charsetSentinel: this.options.charsetSentinel,\n            interpretNumericEntities: this.options.interpretNumericEntities,\n        });\n    }\n\n    cmmvMiddleware(req, res, payload, done) {\n        return new Promise((resolve, reject) => {\n            if (\n                this.options?.defaultCharset !== 'utf-8' &&\n                this.options?.defaultCharset !== 'iso-8859-1'\n            ) {\n                throw new TypeError(\n                    'option defaultCharset must be either utf-8 or iso-8859-1',\n                );\n            }\n\n            const queryparse = this.createQueryParser(\n                this.options,\n                this.options.extended,\n            );\n\n            const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;\n\n            function parse(body, encoding) {\n                return body.length ? queryparse(body, encoding) : {};\n            }\n\n            if (isFinished(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!('body' in req)) req['body'] = undefined;\n\n            if (!typeis.hasBody(req as http.IncomingMessage)) {\n                resolve(null);\n                return;\n            }\n\n            if (!shouldParse(req)) {\n                resolve(null);\n                return;\n            }\n\n            const charset = this.getCharset(req) || this.options.defaultCharset;\n\n            if (charset !== 'utf-8' && charset !== 'iso-8859-1') {\n                resolve(\n                    createError(\n                        415,\n                        'unsupported charset \"' + charset.toUpperCase() + '\"',\n                        {\n                            charset: charset,\n                            type: 'charset.unsupported',\n                        },\n                    ),\n                );\n\n                return;\n            }\n\n            read(req, res, resolve, parse.bind(this), {\n                encoding: charset,\n                inflate: this.options.inflate,\n                limit: this.options.limit,\n                verify: this.options.verify,\n                charsetSentinel: this.options.charsetSentinel,\n                interpretNumericEntities: this.options.interpretNumericEntities,\n            });\n        });\n    }\n\n    /**\n     * Get the extended query parser.\n     *\n     * @param {object} options\n     */\n    createQueryParser(options, extended) {\n        let parameterLimit =\n            options.parameterLimit !== undefined\n                ? options.parameterLimit\n                : 1000;\n        const charsetSentinel = options.charsetSentinel;\n        const interpretNumericEntities = options.interpretNumericEntities;\n        const depth = extended\n            ? options.depth !== undefined\n                ? options.depth\n                : 32\n            : 0;\n\n        if (isNaN(parameterLimit) || parameterLimit < 1)\n            throw new TypeError(\n                'option parameterLimit must be a positive number',\n            );\n\n        if (isNaN(depth) || depth < 0)\n            throw new TypeError(\n                'option depth must be a zero or a positive number',\n            );\n\n        if (isFinite(parameterLimit)) parameterLimit = parameterLimit | 0;\n\n        return function (body, encoding) {\n            /**\n             * Count the number of parameters, stopping once limit reached\n             *\n             * @param {string} body\n             * @param {number} limit\n             * @api private\n             */\n            function parameterCount(body, limit) {\n                let count = 0;\n                let index = 0;\n\n                while ((index = body.indexOf('&', index)) !== -1) {\n                    count++;\n                    index++;\n\n                    if (count === limit) return undefined;\n                }\n\n                return count;\n            }\n\n            const paramCount = parameterCount(body, parameterLimit);\n\n            if (paramCount === undefined) {\n                throw createError(413, 'too many parameters', {\n                    type: 'parameters.too.many',\n                });\n            }\n\n            const arrayLimit = extended ? Math.max(100, paramCount) : 0;\n\n            try {\n                return qs.parse(body, {\n                    allowPrototypes: true,\n                    arrayLimit: arrayLimit,\n                    depth: depth,\n                    charsetSentinel: charsetSentinel,\n                    interpretNumericEntities: interpretNumericEntities,\n                    charset: encoding,\n                    parameterLimit: parameterLimit,\n                    strictDepth: true,\n                });\n            } catch (err) {\n                if (err instanceof RangeError) {\n                    throw createError(400, 'The input exceeded the depth', {\n                        type: 'querystring.parse.rangeError',\n                    });\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n\n    /**\n     * Get the charset of a request.\n     *\n     * @param {object} req\n     * @api private\n     */\n    getCharset(req) {\n        try {\n            return (\n                contentType.parse(req).parameters.charset || ''\n            ).toLowerCase();\n        } catch (e) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Get the simple type checker.\n     *\n     * @param {string} type\n     * @return {function}\n     */\n    private typeChecker(type: any) {\n        return function checkType(req) {\n            const isIRequest = req && req.httpRequest;\n            return Boolean(typeis(isIRequest ? req.httpRequest : req, type));\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "queryparse",
    "snippet": "const queryparse = this.createQueryParser(\n            this.options,\n            this.options.extended,\n        );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n            typeof this.options?.type !== 'function'\n                ? this.typeChecker(this.options.type)\n                : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(body, encoding) {\n            return body.length ? queryparse(body, encoding) : {};\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || this.options.defaultCharset;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "queryparse",
    "snippet": "const queryparse = this.createQueryParser(\n                this.options,\n                this.options.extended,\n            );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "shouldParse",
    "snippet": "const shouldParse =\n                typeof this.options?.type !== 'function'\n                    ? this.typeChecker(this.options.type)\n                    : this.options.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(body, encoding) {\n                return body.length ? queryparse(body, encoding) : {};\n            }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = this.getCharset(req) || this.options.defaultCharset;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "charsetSentinel",
    "snippet": "const charsetSentinel = options.charsetSentinel;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "interpretNumericEntities",
    "snippet": "const interpretNumericEntities = options.interpretNumericEntities;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "depth",
    "snippet": "const depth = extended\n            ? options.depth !== undefined\n                ? options.depth\n                : 32\n            : 0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Function",
    "value": "parameterCount",
    "snippet": "function parameterCount(body, limit) {\n                let count = 0;\n                let index = 0;\n\n                while ((index = body.indexOf('&', index)) !== -1) {\n                    count++;\n                    index++;\n\n                    if (count === limit) return undefined;\n                }\n\n                return count;\n            }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "paramCount",
    "snippet": "const paramCount = parameterCount(body, parameterLimit);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "arrayLimit",
    "snippet": "const arrayLimit = extended ? Math.max(100, paramCount) : 0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "isIRequest",
    "snippet": "const isIRequest = req && req.httpRequest;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/body-parser/lib/urlencoded.ts",
    "type": "Constant",
    "value": "parameterLimit",
    "snippet": "const parameterLimit =\n        options.parameterLimit !== undefined ? options.parameterLimit : 1000;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/constants/http.ts",
    "type": "Constant",
    "value": "HTTPMethod",
    "snippet": "const HTTPMethod = [\n    'get',\n    'post',\n    'put',\n    'head',\n    'delete',\n    'options',\n    'trace',\n    'copy',\n    'lock',\n    'mkcol',\n    'move',\n    'purge',\n    'propfind',\n    'proppatch',\n    'unlock',\n    'report',\n    'mkactivity',\n    'checkout',\n    'merge',\n    'm-search',\n    'notify',\n    'subscribe',\n    'unsubscribe',\n    'patch',\n    'search',\n    'connect',\n];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Constant",
    "value": "hookRunnerApplication",
    "snippet": "const hookRunnerApplication = (hookName, boot, server, cb) => {\n    const hooks = server[kHooks][hookName];\n    let i = 0;\n    let c = 0;\n\n    next();\n\n    function exit(err?) {\n        if (err) {\n            /*if (err.code === 'AVV_ERR_READY_TIMEOUT') {\n                err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName))\n            } else {\n                err = AVVIO_ERRORS_MAP[err.code] != null\n                    ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))\n                    : err\n            }*/\n\n            cb(err);\n            return;\n        }\n\n        cb();\n    }\n\n    function next(err?) {\n        if (err) {\n            exit(err);\n            return;\n        }\n\n        if (i === hooks.length && c === server[kChildren].length) {\n            if (i === 0 && c === 0) {\n                // speed up start\n                exit();\n            } else {\n                boot(function manageTimeout(err, done) {\n                    exit(err);\n                    done(err);\n                });\n            }\n            return;\n        }\n\n        if (i === hooks.length && c < server[kChildren].length) {\n            const child = server[kChildren][c++];\n            hookRunnerApplication(hookName, boot, child, next);\n            return;\n        }\n\n        boot(wrap(hooks[i++], server));\n        next();\n    }\n\n    function wrap(fn, server) {\n        return function (err, done) {\n            if (err) {\n                done(err);\n                return;\n            }\n\n            if (fn.length === 1) {\n                try {\n                    fn.call(server, done);\n                } catch (error) {\n                    done(error);\n                }\n                return;\n            }\n\n            try {\n                const ret = fn.call(server);\n                if (ret && typeof ret.then === 'function') {\n                    ret.then(done, done);\n                    return;\n                }\n            } catch (error) {\n                err = error;\n            }\n\n            done(err);\n        };\n    }\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Constant",
    "value": "hooks",
    "snippet": "const hooks = server[kHooks][hookName];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Function",
    "value": "exit",
    "snippet": "function exit(err?) {\n        if (err) {\n            /*if (err.code === 'AVV_ERR_READY_TIMEOUT') {\n                err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName))\n            } else {\n                err = AVVIO_ERRORS_MAP[err.code] != null\n                    ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message))\n                    : err\n            }*/\n\n            cb(err);\n            return;\n        }\n\n        cb();\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?) {\n        if (err) {\n            exit(err);\n            return;\n        }\n\n        if (i === hooks.length && c === server[kChildren].length) {\n            if (i === 0 && c === 0) {\n                // speed up start\n                exit();\n            } else {\n                boot(function manageTimeout(err, done) {\n                    exit(err);\n                    done(err);\n                });\n            }\n            return;\n        }\n\n        if (i === hooks.length && c < server[kChildren].length) {\n            const child = server[kChildren][c++];\n            hookRunnerApplication(hookName, boot, child, next);\n            return;\n        }\n\n        boot(wrap(hooks[i++], server));\n        next();\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Constant",
    "value": "child",
    "snippet": "const child = server[kChildren][c++];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Function",
    "value": "wrap",
    "snippet": "function wrap(fn, server) {\n        return function (err, done) {\n            if (err) {\n                done(err);\n                return;\n            }\n\n            if (fn.length === 1) {\n                try {\n                    fn.call(server, done);\n                } catch (error) {\n                    done(error);\n                }\n                return;\n            }\n\n            try {\n                const ret = fn.call(server);\n                if (ret && typeof ret.then === 'function') {\n                    ret.then(done, done);\n                    return;\n                }\n            } catch (error) {\n                err = error;\n            }\n\n            done(err);\n        };\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/application.ts",
    "type": "Constant",
    "value": "ret",
    "snippet": "const ret = fn.call(server);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/index.ts",
    "type": "Constant",
    "value": "applicationHooks",
    "snippet": "const applicationHooks = [\n    'onRoute',\n    'onRegister',\n    'onReady',\n    'onListen',\n    'preClose',\n    'onClose',\n];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/index.ts",
    "type": "Constant",
    "value": "lifecycleHooks",
    "snippet": "const lifecycleHooks = [\n    'onTimeout',\n    'onRequest',\n    'preParsing',\n    'preValidation',\n    'preSerialization',\n    'preHandler',\n    'onSend',\n    'onResponse',\n    'onError',\n    'onRequestAbort',\n];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/index.ts",
    "type": "Constant",
    "value": "supportedHooks",
    "snippet": "const supportedHooks = lifecycleHooks.concat(applicationHooks);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/request.ts",
    "type": "Constant",
    "value": "onRequestHookRunner",
    "snippet": "const onRequestHookRunner = hookRunnerGenerator(hookIterator);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/request.ts",
    "type": "Constant",
    "value": "onRequestAbortHookRunner",
    "snippet": "const onRequestAbortHookRunner = (functions, request, cb) => {\n    let i = 0;\n\n    function next(err?) {\n        if (err || i === functions.length) {\n            cb(err, request);\n            return;\n        }\n\n        let result;\n\n        try {\n            result = functions[i++](request, next);\n        } catch (error) {\n            cb(error, request);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve, handleReject);\n    }\n\n    function handleResolve() {\n        next();\n    }\n\n    function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n\n        cb(err, request);\n    }\n\n    next();\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/request.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?) {\n        if (err || i === functions.length) {\n            cb(err, request);\n            return;\n        }\n\n        let result;\n\n        try {\n            result = functions[i++](request, next);\n        } catch (error) {\n            cb(error, request);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve, handleReject);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/request.ts",
    "type": "Function",
    "value": "handleResolve",
    "snippet": "function handleResolve() {\n        next();\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/request.ts",
    "type": "Function",
    "value": "handleReject",
    "snippet": "function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n\n        cb(err, request);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "onResponseHookIterator",
    "snippet": "const onResponseHookIterator = (fn, req, res, next) => {\n    return fn(req, res, next);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "onSendHookRunner",
    "snippet": "const onSendHookRunner = (functions, request, res, payload, cb) => {\n    let i = 0;\n\n    function next(err?, newPayload?) {\n        if (err) {\n            cb(err, request, res, payload);\n            return;\n        }\n\n        if (newPayload !== undefined) payload = newPayload;\n\n        if (i === functions.length) {\n            cb(null, request, res, payload);\n            return;\n        }\n\n        let result;\n        try {\n            result = functions[i++](request, res, payload, next);\n        } catch (error) {\n            cb(error, request, res);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve).catch(handleReject);\n    }\n\n    function handleResolve(newPayload) {\n        next(null, newPayload);\n    }\n\n    function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n        cb(err, request, res, payload);\n    }\n\n    next();\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?, newPayload?) {\n        if (err) {\n            cb(err, request, res, payload);\n            return;\n        }\n\n        if (newPayload !== undefined) payload = newPayload;\n\n        if (i === functions.length) {\n            cb(null, request, res, payload);\n            return;\n        }\n\n        let result;\n        try {\n            result = functions[i++](request, res, payload, next);\n        } catch (error) {\n            cb(error, request, res);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve).catch(handleReject);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Function",
    "value": "handleResolve",
    "snippet": "function handleResolve(newPayload) {\n        next(null, newPayload);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Function",
    "value": "handleReject",
    "snippet": "function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n        cb(err, request, res, payload);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "onResponseHookRunner",
    "snippet": "const onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "preValidationHookRunner",
    "snippet": "const preValidationHookRunner = hookRunnerGenerator(hookIterator);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "preHandlerHookRunner",
    "snippet": "const preHandlerHookRunner = hookRunnerGenerator(hookIterator);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "onTimeoutHookRunner",
    "snippet": "const onTimeoutHookRunner = hookRunnerGenerator(hookIterator);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/response.ts",
    "type": "Constant",
    "value": "preSerializationHookRunner",
    "snippet": "const preSerializationHookRunner = onSendHookRunner;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "hookIterator",
    "snippet": "function hookIterator(fn, req, res, next) {\n    if (res.sent === true) return undefined;\n    return fn(req, res, next);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "hookRunnerGenerator",
    "snippet": "const hookRunnerGenerator = iterator => {\n    return function hookRunner(functions, req, res, cb) {\n        let i = 0;\n\n        function next(err?) {\n            if (res.sent) return;\n\n            if (err || i === functions.length) {\n                cb(err, req, res);\n                return;\n            }\n\n            let result;\n\n            try {\n                result = iterator(functions[i++], req, res, next);\n            } catch (error) {\n                cb(error, req, res);\n                return;\n            }\n\n            if (result && typeof result.then === 'function')\n                result.then(handleResolve).catch(handleReject);\n        }\n\n        function handleResolve() {\n            next();\n        }\n\n        function handleReject(err) {\n            if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n            cb(err, req, res);\n        }\n\n        next();\n    };\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?) {\n            if (res.sent) return;\n\n            if (err || i === functions.length) {\n                cb(err, req, res);\n                return;\n            }\n\n            let result;\n\n            try {\n                result = iterator(functions[i++], req, res, next);\n            } catch (error) {\n                cb(error, req, res);\n                return;\n            }\n\n            if (result && typeof result.then === 'function')\n                result.then(handleResolve).catch(handleReject);\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "handleResolve",
    "snippet": "function handleResolve() {\n            next();\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "handleReject",
    "snippet": "function handleReject(err) {\n            if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n            cb(err, req, res);\n        }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "onListenHookRunner",
    "snippet": "const onListenHookRunner = server => {\n    const hooks = server[kHooks].onListen;\n    const hooksLen = hooks.length;\n\n    let i = 0;\n    let c = 0;\n\n    next();\n\n    function next(err?) {\n        err && console.error(err);\n\n        if (i === hooksLen) {\n            while (c < server[kChildren].length) {\n                const child = server[kChildren][c++];\n                onListenHookRunner(child);\n            }\n\n            return;\n        }\n\n        wrap(hooks[i++], server, next);\n    }\n\n    async function wrap(fn, server, done) {\n        if (fn.length === 1) {\n            try {\n                fn.call(server, done);\n            } catch (e) {\n                done(e);\n            }\n\n            return;\n        }\n\n        try {\n            const ret = fn.call(server);\n\n            if (ret && typeof ret.then === 'function') {\n                ret.then(done, done);\n                return;\n            }\n\n            done();\n        } catch (error) {\n            done(error);\n        }\n    }\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "hooks",
    "snippet": "const hooks = server[kHooks].onListen;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "hooksLen",
    "snippet": "const hooksLen = hooks.length;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?) {\n        err && console.error(err);\n\n        if (i === hooksLen) {\n            while (c < server[kChildren].length) {\n                const child = server[kChildren][c++];\n                onListenHookRunner(child);\n            }\n\n            return;\n        }\n\n        wrap(hooks[i++], server, next);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "child",
    "snippet": "const child = server[kChildren][c++];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "wrap",
    "snippet": "async function wrap(fn, server, done) {\n        if (fn.length === 1) {\n            try {\n                fn.call(server, done);\n            } catch (e) {\n                done(e);\n            }\n\n            return;\n        }\n\n        try {\n            const ret = fn.call(server);\n\n            if (ret && typeof ret.then === 'function') {\n                ret.then(done, done);\n                return;\n            }\n\n            done();\n        } catch (error) {\n            done(error);\n        }\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "ret",
    "snippet": "const ret = fn.call(server);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "preParsingHookRunner",
    "snippet": "const preParsingHookRunner = (functions, req, res, cb) => {\n    let i = 0;\n\n    function next(err?, newPayload?) {\n        if (res.sent) return;\n\n        if (newPayload !== undefined) req[kRequestPayloadStream] = newPayload;\n\n        if (err || i === functions.length) {\n            cb(err, req, res);\n            return;\n        }\n\n        let result;\n        try {\n            result = functions[i++](req, res, req[kRequestPayloadStream], next);\n        } catch (error) {\n            cb(error, req, res);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve, handleReject);\n    }\n\n    function handleResolve(newPayload) {\n        next(null, newPayload);\n    }\n\n    function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n\n        cb(err, req, res);\n    }\n\n    next();\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "next",
    "snippet": "function next(err?, newPayload?) {\n        if (res.sent) return;\n\n        if (newPayload !== undefined) req[kRequestPayloadStream] = newPayload;\n\n        if (err || i === functions.length) {\n            cb(err, req, res);\n            return;\n        }\n\n        let result;\n        try {\n            result = functions[i++](req, res, req[kRequestPayloadStream], next);\n        } catch (error) {\n            cb(error, req, res);\n            return;\n        }\n\n        if (result && typeof result.then === 'function')\n            result.then(handleResolve, handleReject);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "handleResolve",
    "snippet": "function handleResolve(newPayload) {\n        next(null, newPayload);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Function",
    "value": "handleReject",
    "snippet": "function handleReject(err) {\n        if (!err) err = new CM_ERR_SEND_UNDEFINED_ERR();\n\n        cb(err, req, res);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "buildHooks",
    "snippet": "const buildHooks = h => {\n    const hooks = new Hooks();\n    hooks.onRequest = h.onRequest.slice();\n    hooks.preParsing = h.preParsing.slice();\n    hooks.preValidation = h.preValidation.slice();\n    hooks.preSerialization = h.preSerialization.slice();\n    hooks.preHandler = h.preHandler.slice();\n    hooks.onSend = h.onSend.slice();\n    hooks.onResponse = h.onResponse.slice();\n    hooks.onError = h.onError.slice();\n    hooks.onRoute = h.onRoute.slice();\n    hooks.onRegister = h.onRegister.slice();\n    hooks.onTimeout = h.onTimeout.slice();\n    hooks.onRequestAbort = h.onRequestAbort.slice();\n    hooks.onReady = [];\n    hooks.onListen = [];\n    hooks.preClose = [];\n    return hooks;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/hooks/utils.ts",
    "type": "Constant",
    "value": "hooks",
    "snippet": "const hooks = new Hooks();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "trustProxyDefaultSymbol",
    "snippet": "const trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "mixin",
    "snippet": "const mixin = require('merge-descriptors');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Class",
    "value": "Application",
    "snippet": "class Application extends EventEmitter {\n    request: any;\n\n    response: any;\n\n    constructor() {\n        super();\n        this.request = request;\n        this.response = response;\n    }\n\n    private processOptions(options?) {\n        if (typeof options !== 'object') throw new CM_ERR_OPTIONS_NOT_OBJ();\n\n        if (\n            options.querystringParser &&\n            typeof options.querystringParser !== 'function'\n        )\n            throw new CM_ERR_QSP_NOT_FN(typeof options.querystringParser);\n\n        options.http2 = Boolean(options.http2 === true);\n        options.connectionTimeout = options.connectionTimeout || 0;\n        options.keepAliveTimeout = options.keepAliveTimeout || 72000;\n        options.maxRequestsPerSocket = options.maxRequestsPerSocket || 0;\n        options.requestTimeout = options.requestTimeout || 0;\n        options.bodyLimit = options.bodyLimit || 1048576;\n        options.maxHeaderSize = options.maxHeaderSize || 16384;\n        options.insecureHTTPParser = Boolean(\n            options.insecureHTTPParser === true,\n        );\n        options.joinDuplicateHeaders = Boolean(\n            options.joinDuplicateHeaders === true,\n        );\n\n        return options;\n    }\n\n    private injectApplication(server, options?) {\n        const slice = Array.prototype.slice;\n        const flatten = Array.prototype.flat;\n        const self = this;\n\n        const app: any = {\n            router: new Router(),\n            cache: Object.create(null),\n            engines: Object.create(null),\n            settings: Object.create(null),\n            locals: Object.create(null),\n            mountpath: '/',\n        };\n\n        mixin(app, EventEmitter.prototype, false);\n\n        HTTPMethod.forEach(method => {\n            app[method] = ((path?: string, ...callbacks) => {\n                if (method === 'get' && callbacks.length === 0)\n                    return app.set(path);\n\n                const route = app.router;\n                route[method].call(route, path, callbacks);\n                return this;\n            }).bind(app);\n        });\n\n        app.addRoute = function addRoute(options: any) {\n            app.router.route(options);\n            return this;\n        };\n\n        /**\n         * Proxy `Router#use()` to add middleware to the app router.\n         * See Router#use() documentation for details.\n         *\n         * If the _fn_ parameter is an express app, then it will be\n         * mounted at the _route_ specified.\n         *\n         * @public\n         */\n        app.use = function use(fn: any) {\n            let offset = 0;\n            let path = '/';\n\n            if (fn.constructor.name === 'Promise') {\n                return fn\n                    .then(init => init.call(this, { app: this }, null, null))\n                    .catch(err => {\n                        throw new Error(err);\n                    });\n            }\n\n            if (typeof fn !== 'function') {\n                let arg = fn;\n\n                while (Array.isArray(arg) && arg.length !== 0) arg = arg[0];\n\n                if (typeof arg !== 'function') {\n                    offset = 1;\n                    path = fn;\n                }\n            } else {\n                path = '';\n            }\n\n            const fns = flatten.call(slice.call(arguments, offset), Infinity);\n\n            if (fns.length === 0)\n                throw new TypeError('app.use() requires a middleware function');\n\n            const router = this.router;\n\n            fns.forEach((fn: any) => {\n                if ((!fn || !fn.handle || !fn.set) && path !== '')\n                    return router.use(path, fn);\n\n                fn.mountpath = path;\n                this[kMiddlewares].push(fn.handle ? fn.handle : fn);\n            }, this);\n\n            this.emit('mount');\n\n            return this;\n        };\n\n        /**\n         * Render the given view `name` name with `options`\n         * and a callback accepting an error and the\n         * rendered template string.\n         *\n         * Example:\n         *\n         *    app.render('email', { name: 'Tobi' }, function(err, html){\n         *      // ...\n         *    })\n         *\n         * @param {String} name\n         * @param {Object|Function} options or fn\n         * @param {Function} callback\n         * @public\n         */\n        app.render = function render(name, options, callback) {\n            const cache = this.cache;\n            let done = callback;\n            const engines = this.engines;\n            let opts = options;\n            const renderOptions: any = {};\n            let view;\n\n            if (typeof options === 'function') {\n                done = options;\n                opts = {};\n            }\n\n            utilsMerge(renderOptions, this.locals);\n\n            if (opts._locals) utilsMerge(renderOptions, opts._locals);\n\n            utilsMerge(renderOptions, opts);\n\n            if (renderOptions.cache == null)\n                renderOptions.cache = this.enabled('view cache');\n\n            if (renderOptions.cache) view = cache[name];\n\n            if (!view) {\n                let View = this.get('view');\n\n                view = new View(name, {\n                    defaultEngine: this.get('view engine'),\n                    root: this.get('views'),\n                    engines: engines,\n                });\n\n                if (!view.path) {\n                    const dirs =\n                        Array.isArray(view.root) && view.root.length > 1\n                            ? 'directories \"' +\n                              view.root.slice(0, -1).join('\", \"') +\n                              '\" or \"' +\n                              view.root[view.root.length - 1] +\n                              '\"'\n                            : 'directory \"' + view.root + '\"';\n                    let err: any = new Error(\n                        'Failed to lookup view \"' + name + '\" in views ' + dirs,\n                    );\n                    err.view = view;\n                    return done(err);\n                }\n\n                if (renderOptions.cache) cache[name] = view;\n            }\n\n            try {\n                view.render(renderOptions, done);\n            } catch (err) {\n                callback(err);\n            }\n        };\n\n        /**\n         * Proxy to the app `Router#route()`\n         * Returns a new `Route` instance for the _path_.\n         *\n         * Routes are isolated middleware stacks for specific paths.\n         * See the Route api docs for details.\n         *\n         * @public\n         */\n        app.route = function route(method: string, path: string) {\n            return this.router.find(method, path);\n        };\n\n        /**\n         * Register the given template engine callback `fn`\n         * as `ext`.\n         *\n         * By default will `require()` the engine based on the\n         * file extension. For example if you try to render\n         * a \"foo.ejs\" file Express will invoke the following internally:\n         *\n         *     app.engine('ejs', require('ejs').__express);\n         *\n         * For engines that do not provide `.__express` out of the box,\n         * or if you wish to \"map\" a different extension to the template engine\n         * you may use this method. For example mapping the EJS template engine to\n         * \".html\" files:\n         *\n         *     app.engine('html', require('ejs').renderFile);\n         *\n         * In this case EJS provides a `.renderFile()` method with\n         * the same signature that Express expects: `(path, options, callback)`,\n         * though note that it aliases this method as `ejs.__express` internally\n         * so if you're using \".ejs\" extensions you don't need to do anything.\n         *\n         * Some template engines do not follow this convention, the\n         * [Consolidate.js](https://github.com/tj/consolidate.js)\n         * library was created to map all of node's popular template\n         * engines to follow this convention, thus allowing them to\n         * work seamlessly within Express.\n         *\n         * @param {String} ext\n         * @param {Function} fn\n         * @return {app} for chaining\n         * @public\n         */\n        app.engine = function engine(ext, fn) {\n            if (typeof fn !== 'function')\n                throw new Error('callback function required');\n\n            const extension = ext[0] !== '.' ? '.' + ext : ext;\n\n            this.engines[extension] = fn;\n\n            return this;\n        };\n\n        /**\n         * Assign `setting` to `val`, or return `setting`'s value.\n         *\n         *    app.set('foo', 'bar');\n         *    app.set('foo');\n         *    // => \"bar\"\n         *\n         * Mounted servers inherit their parent server's settings.\n         *\n         * @param {String} setting\n         * @param {*} [val]\n         * @return {Server} for chaining\n         * @public\n         */\n        app.set = function set(setting: string, val: any) {\n            if (arguments.length === 1) return this.settings[setting];\n\n            this.settings[setting] = val;\n\n            switch (setting) {\n                case 'etag':\n                    const { compileETag } = require('../utils');\n                    this.set('etag fn', compileETag(val));\n                    break;\n                case 'query parser':\n                    const { compileQueryParser } = require('../utils');\n                    this.set('query parser fn', compileQueryParser(val));\n                    break;\n                case 'trust proxy':\n                    const { compileTrust } = require('../utils');\n                    this.set('trust proxy fn', compileTrust(val));\n                    break;\n            }\n\n            return this;\n        };\n\n        /**\n         * Proxy to `Router#param()` with one added api feature. The _name_ parameter\n         * can be an array of names.\n         *\n         * See the Router#param() docs for more details.\n         *\n         * @param {String|Array} name\n         * @param {Function} fn\n         * @return {app} for chaining\n         * @public\n         */\n        app.param = function param(name, fn) {\n            if (Array.isArray(name)) {\n                for (var i = 0; i < name.length; i++) this.param(name[i], fn);\n\n                return this;\n            }\n\n            this.router.param(name, fn);\n\n            return this;\n        };\n\n        /**\n         * Return the app's absolute pathname\n         * based on the parent(s) that have\n         * mounted it.\n         *\n         * For example if the application was\n         * mounted as \"/admin\", which itself\n         * was mounted as \"/blog\" then the\n         * return value would be \"/blog/admin\".\n         *\n         * @return {String}\n         * @private\n         */\n        app.path = function path() {\n            return this.parent ? this.parent.path() + this.mountpath : '';\n        };\n\n        /**\n         * Check if `setting` is enabled (truthy).\n         *\n         *    app.enabled('foo')\n         *    // => false\n         *\n         *    app.enable('foo')\n         *    app.enabled('foo')\n         *    // => true\n         *\n         * @param {String} setting\n         * @return {Boolean}\n         * @public\n         */\n        app.enabled = function enabled(setting) {\n            return Boolean(this.set(setting));\n        };\n\n        /**\n         * Check if `setting` is disabled.\n         *\n         *    app.disabled('foo')\n         *    // => true\n         *\n         *    app.enable('foo')\n         *    app.disabled('foo')\n         *    // => false\n         *\n         * @param {String} setting\n         * @return {Boolean}\n         * @public\n         */\n        app.disabled = function disabled(setting) {\n            return !this.set(setting);\n        };\n\n        /**\n         * Enable `setting`.\n         *\n         * @param {String} setting\n         * @return {app} for chaining\n         * @public\n         */\n        app.enable = function enable(setting) {\n            return this.set(setting, true);\n        };\n\n        /**\n         * Disable `setting`.\n         *\n         * @param {String} setting\n         * @return {app} for chaining\n         * @public\n         */\n        app.disable = function disable(setting) {\n            return this.set(setting, false);\n        };\n\n        app.setErrorHandler = function setErrorHandler(func) {\n            self.throwIfAlreadyStarted('Cannot call \"setErrorHandler\"!');\n\n            if (typeof func !== 'function')\n                throw new CM_ERR_ERROR_HANDLER_NOT_FN();\n\n            this[kErrorHandler] = buildErrorHandler(\n                this[kErrorHandler],\n                func.bind(this),\n            );\n            return this;\n        };\n\n        app.addHook = function addHook(name, fn) {\n            self.throwIfAlreadyStarted('Cannot call \"addHook\"!');\n\n            if (fn == null) throw new CM_ERR_HOOK_INVALID_HANDLER(name, fn);\n\n            if (\n                name === 'onSend' ||\n                name === 'preSerialization' ||\n                name === 'onError' ||\n                name === 'preParsing'\n            ) {\n                if (fn.constructor.name === 'AsyncFunction' && fn.length !== 4)\n                    throw new CM_ERR_HOOK_INVALID_ASYNC_HANDLER();\n            } else if (name === 'onReady' || name === 'onListen') {\n                if (fn.constructor.name === 'AsyncFunction' && fn.length !== 0)\n                    throw new CM_ERR_HOOK_INVALID_ASYNC_HANDLER();\n            } else if (name === 'onRequestAbort') {\n                if (fn.constructor.name === 'AsyncFunction' && fn.length !== 1)\n                    throw new CM_ERR_HOOK_INVALID_ASYNC_HANDLER();\n            } else {\n                if (fn.constructor.name === 'AsyncFunction' && fn.length === 3)\n                    throw new CM_ERR_HOOK_INVALID_ASYNC_HANDLER();\n            }\n\n            if (name === 'onClose') this.onClose(fn.bind(this));\n            else this[kHooks].add(name, fn);\n\n            return this;\n        };\n\n        app.addContentTypeParser = function addContentTypeParser(\n            contentType,\n            fn,\n        ) {\n            if (fn == null)\n                throw new CM_ERR_HOOK_INVALID_HANDLER(contentType, fn);\n\n            if (Array.isArray(contentType)) {\n                for (let key in contentType)\n                    this[kContentTypeParsers][contentType[key]] = fn;\n            } else if (typeof contentType === 'string')\n                this[kContentTypeParsers][contentType] = fn;\n\n            return this;\n        };\n\n        app.contentTypeParser = function contentTypeParser(\n            contentType,\n            handler,\n            req,\n            res,\n        ) {\n            if (\n                this[kContentTypeParsers][contentType] &&\n                typeof this[kContentTypeParsers][contentType] === 'function'\n            ) {\n                let result;\n                try {\n                    result = this[kContentTypeParsers][contentType].call(\n                        this,\n                        req,\n                        res,\n                        null,\n                        handler,\n                    );\n                } catch (error) {\n                    console.log(error);\n                    handler(req, res);\n                    return;\n                }\n\n                if (result && typeof result.then === 'function')\n                    result\n                        .then(() => {\n                            handler(req, res);\n                        })\n                        .catch(err => {\n                            console.error(err);\n                        });\n            } else {\n                handler(req, res);\n            }\n        };\n\n        for (const method in app)\n            if (!server[method]) server[method] = app[method];\n\n        app.set('etag', 'weak');\n        app.set('env', process.env.NODE_ENV || 'dev');\n        app.set('query parser', 'simple');\n        app.set('subdomain offset', 2);\n        app.set('trust proxy', false);\n        app.set('jsonp callback name', 'callback');\n        app.set('view', View);\n        app.set('views', path.resolve('views'));\n\n        if (process.env.NODE_ENV === 'production') app.enable('view cache');\n\n        app.on('mount', function onmount(parent) {\n            // inherit trust proxy\n            if (\n                app.settings[trustProxyDefaultSymbol] === true &&\n                typeof parent.settings['trust proxy fn'] === 'function'\n            ) {\n                delete app.settings['trust proxy'];\n                delete app.settings['trust proxy fn'];\n            }\n\n            // inherit protos\n            setPrototypeOf(app.request, parent.request);\n            setPrototypeOf(app.response, parent.response);\n            setPrototypeOf(app.engines, parent.engines);\n            setPrototypeOf(app.settings, parent.settings);\n        });\n\n        app.locals.settings = app.settings;\n\n        server.app = app;\n        server[kHooks] = new Hooks();\n        server[kContentTypeParsers] = {};\n        server[kMiddlewares] = [];\n        server[kChildren] = [];\n        server[kState] = {};\n        server[kErrorHandler] = buildErrorHandler(\n            rootErrorHandler,\n            function (error, request, res) {\n                console.error(error);\n                res.status(409).send({ ok: false });\n            },\n        );\n        server.runPreParsing = this.runPreParsing;\n        server.request = this.request;\n        server.response = this.response;\n    }\n\n    public createServerInstance(options?, httpHandler?) {\n        let server = null;\n\n        options = this.processOptions(options || {});\n\n        if (options.serverFactory) {\n            server = options.serverFactory(this._handler, options);\n        } else if (options.http2) {\n            if (options.https) {\n                server = this.http2().createSecureServer(\n                    options.https,\n                    (req, res) => this._handler.call(server, req, res),\n                );\n            } else {\n                server = this.http2().createServer(options, (req, res) =>\n                    this._handler.call(server, req, res),\n                );\n            }\n        } else {\n            if (options.https) {\n                server = https.createServer(options.https, (req, res) =>\n                    this._handler.call(server, req, res),\n                );\n            } else {\n                server = http.createServer(options, (req, res) =>\n                    this._handler.call(server, req, res),\n                );\n            }\n\n            server.keepAliveTimeout = options.keepAliveTimeout;\n            server.requestTimeout = options.requestTimeout;\n\n            if (options.maxRequestsPerSocket > 0)\n                server.maxRequestsPerSocket = options.maxRequestsPerSocket;\n        }\n\n        if (!options.serverFactory)\n            server.setTimeout(options.connectionTimeout);\n\n        this.injectApplication.call(this, server, options);\n\n        const listen = (listenOptions: { host: string; port: number }) => {\n            server[kState].started = true;\n            return server.listen.call(server, listenOptions);\n        };\n\n        return { server, listen };\n    }\n\n    private async _handler(this: any, req, res) {\n        this.route(req.method, req.url)\n            .then(async route => {\n                const request = Object.create(this.request);\n                request.routeOptions = route.store;\n                request.params = route.params;\n                //request.query = route.searchParams;\n                const response = Object.create(this.response);\n                const hooks = this[kHooks];\n                response[kResponseHeaders] = {};\n\n                request.app = response.app = this;\n                request.req = response.req = req;\n                request.res = response.res = res;\n                request.originalUrl = req.url;\n\n                request.preParsing = hooks.preParsing;\n                request.preHandler = hooks.preHandler;\n                request.response = response;\n                response.request = request;\n\n                response.onSend = hooks.onSend;\n                response.onError = hooks.onError;\n                response.errorHandler = this[kErrorHandler];\n\n                const middlewares = this[kMiddlewares] || [];\n                let stack = [...middlewares, ...route.store.stack].flat();\n                request.handler = stack[stack.length - 1];\n                stack.pop();\n\n                if (hooks.onRequest && hooks.onRequest.length > 0) {\n                    onRequestHookRunner(\n                        hooks.onRequest,\n                        request,\n                        response,\n                        this.runPreParsing,\n                    );\n                } else {\n                    this.runPreParsing(null, request, response);\n                }\n\n                if (\n                    hooks.onRequestAbort !== null &&\n                    hooks.onRequestAbort.length > 0\n                ) {\n                    req.on('close', () => {\n                        /* istanbul ignore else */\n                        if (req.aborted) {\n                            onRequestAbortHookRunner(\n                                hooks.onRequestAbort,\n                                request,\n                                this.handleOnRequestAbortHooksErrors.bind(\n                                    null,\n                                    response,\n                                ),\n                            );\n                        }\n                    });\n                }\n            })\n            .catch(err => {\n                //console.error(err);\n                res.writeHead(404);\n                res.end('Not Found');\n            });\n    }\n\n    private http2() {\n        try {\n            return require('node:http2');\n        } catch (err) {\n            throw new CM_ERR_HTTP2_INVALID_VERSION();\n        }\n    }\n\n    public throwIfAlreadyStarted(msg) {\n        if (this[kState]?.started)\n            throw new CM_ERR_INSTANCE_ALREADY_LISTENING(msg);\n    }\n\n    runPreParsing(err, request, response) {\n        if (response.sent === true) return;\n\n        if (err != null) {\n            response[kResponseIsError] = true;\n            response.send(err);\n            return;\n        }\n\n        //request[kRequestPayloadStream] = request.raw;\n\n        if (\n            (request.preParsing !== null,\n            request.preParsing !== undefined,\n            request.preParsing?.length > 0)\n        ) {\n            preParsingHookRunner(\n                request.preParsing,\n                request,\n                response,\n                handleRequest.bind(request.server),\n            );\n        } else {\n            handleRequest.call(request.server, null, request, response);\n        }\n    }\n\n    handleOnRequestAbortHooksErrors(reply, err) {\n        if (err) console.error({ err }, 'onRequestAborted hook failed');\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "slice",
    "snippet": "const slice = Array.prototype.slice;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "flatten",
    "snippet": "const flatten = Array.prototype.flat;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "self",
    "snippet": "const self = this;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app: any = {\n            router: new Router(),\n            cache: Object.create(null),\n            engines: Object.create(null),\n            settings: Object.create(null),\n            locals: Object.create(null),\n            mountpath: '/',\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "route",
    "snippet": "const route = app.router;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "fns",
    "snippet": "const fns = flatten.call(slice.call(arguments, offset), Infinity);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "router",
    "snippet": "const router = this.router;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "cache",
    "snippet": "const cache = this.cache;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "engines",
    "snippet": "const engines = this.engines;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "renderOptions",
    "snippet": "const renderOptions: any = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "dirs",
    "snippet": "const dirs =\n                        Array.isArray(view.root) && view.root.length > 1\n                            ? 'directories \"' +\n                              view.root.slice(0, -1).join('\", \"') +\n                              '\" or \"' +\n                              view.root[view.root.length - 1] +\n                              '\"'\n                            : 'directory \"' + view.root + '\"';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "extension",
    "snippet": "const extension = ext[0] !== '.' ? '.' + ext : ext;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "listen",
    "snippet": "const listen = (listenOptions: { host: string; port: number }) => {\n            server[kState].started = true;\n            return server.listen.call(server, listenOptions);\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "request",
    "snippet": "const request = Object.create(this.request);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "response",
    "snippet": "const response = Object.create(this.response);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "hooks",
    "snippet": "const hooks = this[kHooks];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/application.ts",
    "type": "Constant",
    "value": "middlewares",
    "snippet": "const middlewares = this[kMiddlewares] || [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "serializeError",
    "snippet": "const serializeError = require('./error-serializer');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "rootErrorHandler",
    "snippet": "const rootErrorHandler = {\n    func: defaultErrorHandler,\n    toJSON() {\n        return this.func.name.toString() + '()';\n    },\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "handleError",
    "snippet": "const handleError = (response, error, cb?) => {\n    response[kResponseIsRunningOnErrorHook] = false;\n\n    if (response[kResponseNextErrorHandler] === false) {\n        fallbackErrorHandler(error, response, function (res, payload) {\n            try {\n                response.res.writeHead(\n                    res.raw.statusCode,\n                    res[kResponseHeaders],\n                );\n            } catch (error) {\n                response.res.writeHead(res.statusCode);\n            }\n            response.res.end(payload);\n        });\n        return;\n    }\n\n    const errorHandler =\n        response[kResponseNextErrorHandler] || response.errorHandler;\n    response[kResponseNextErrorHandler] = Object.getPrototypeOf(errorHandler);\n\n    delete response[kResponseHeaders]['content-type'];\n    delete response[kResponseHeaders]['content-length'];\n\n    const func = errorHandler?.func || null;\n\n    if (!func) {\n        response[kResponseNextErrorHandler] = false;\n        fallbackErrorHandler(error, response, cb);\n        return;\n    }\n\n    try {\n        const result = func(error, response.request, response);\n\n        if (result !== undefined) {\n            if (result !== null && typeof result.then === 'function')\n                wrapThenable(result, response);\n            else response.send(result);\n        }\n    } catch (err) {\n        response.send(err);\n    }\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "errorHandler",
    "snippet": "const errorHandler =\n        response[kResponseNextErrorHandler] || response.errorHandler;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "func",
    "snippet": "const func = errorHandler?.func || null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "result",
    "snippet": "const result = func(error, response.request, response);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "buildErrorHandler",
    "snippet": "const buildErrorHandler = (parent = rootErrorHandler, func) => {\n    if (!func) return parent;\n    const errorHandler = Object.create(parent);\n    errorHandler.func = func;\n    return errorHandler;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "errorHandler",
    "snippet": "const errorHandler = Object.create(parent);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Function",
    "value": "fallbackErrorHandler",
    "snippet": "function fallbackErrorHandler(error, res, cb) {\n    if (res.headersSent === true) return;\n\n    const statusCode = res.statusCode;\n    res[kResponseHeaders]['content-type'] =\n        res[kResponseHeaders]['content-type'] ??\n        'application/json; charset=utf-8';\n    let payload;\n\n    try {\n        payload = serializeError({\n            error: statusCodes[statusCode + ''],\n            code: error.code,\n            message: error.message,\n            statusCode,\n        });\n    } catch (err) {\n        res.code(500);\n        payload = serializeError(\n            new CM_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message),\n        );\n    }\n\n    if (typeof payload !== 'string' && !Buffer.isBuffer(payload))\n        payload = serializeError(\n            new CM_ERR_RES_INVALID_PAYLOAD_TYPE(typeof payload),\n        );\n\n    res[kResponseHeaders]['content-length'] = '' + Buffer.byteLength(payload);\n    cb(res, payload);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "statusCode",
    "snippet": "const statusCode = res.statusCode;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Function",
    "value": "defaultErrorHandler",
    "snippet": "function defaultErrorHandler(error, request, res) {\n    setErrorHeaders(error, res);\n\n    if (!res[kResponseHasStatusCode] || res.statusCode === 200) {\n        const statusCode = error.statusCode || error.status;\n        res.code(statusCode >= 400 ? statusCode : 500);\n    }\n\n    res.send(error);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Constant",
    "value": "statusCode",
    "snippet": "const statusCode = error.statusCode || error.status;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-handler.ts",
    "type": "Function",
    "value": "setErrorHeaders",
    "snippet": "function setErrorHeaders(error, res) {\n    let statusCode = res.statusCode;\n    statusCode = statusCode >= 400 ? statusCode : 500;\n\n    if (error != null) {\n        if (error.headers !== undefined) res.headers(error.headers);\n        if (error.status >= 400) statusCode = error.status;\n        else if (error.statusCode >= 400) statusCode = error.statusCode;\n    }\n\n    res.statusCode = statusCode;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "Serializer",
    "snippet": "const Serializer = require('fast-json-stringify/lib/serializer');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "serializerState",
    "snippet": "const serializerState = { mode: 'standalone' };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "serializer",
    "snippet": "const serializer = Serializer.restoreFromState(serializerState);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "validator",
    "snippet": "const validator = null;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_BEGIN_OBJECT",
    "snippet": "const JSON_STR_BEGIN_OBJECT = '{';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_END_OBJECT",
    "snippet": "const JSON_STR_END_OBJECT = '}';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_BEGIN_ARRAY",
    "snippet": "const JSON_STR_BEGIN_ARRAY = '[';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_END_ARRAY",
    "snippet": "const JSON_STR_END_ARRAY = ']';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_COMMA",
    "snippet": "const JSON_STR_COMMA = ',';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_COLONS",
    "snippet": "const JSON_STR_COLONS = ':';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_QUOTE",
    "snippet": "const JSON_STR_QUOTE = '\"';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_EMPTY_OBJECT",
    "snippet": "const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_EMPTY_ARRAY",
    "snippet": "const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_EMPTY_STRING",
    "snippet": "const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "JSON_STR_NULL",
    "snippet": "const JSON_STR_NULL = 'null';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Function",
    "value": "anonymous0",
    "snippet": "function anonymous0(input) {\n        const obj =\n            input && typeof input.toJSON === 'function'\n                ? input.toJSON()\n                : input;\n\n        if (obj === null) return JSON_STR_EMPTY_OBJECT;\n\n        let value;\n        let json = JSON_STR_BEGIN_OBJECT;\n        let addComma = false;\n\n        value = obj['statusCode'];\n        if (value !== undefined) {\n            (!addComma && (addComma = true)) || (json += JSON_STR_COMMA);\n            json += '\"statusCode\":';\n            json += serializer.asNumber(value);\n        }\n\n        value = obj['code'];\n        if (value !== undefined) {\n            (!addComma && (addComma = true)) || (json += JSON_STR_COMMA);\n            json += '\"code\":';\n\n            if (typeof value !== 'string') {\n                if (value === null) {\n                    json += JSON_STR_EMPTY_STRING;\n                } else if (value instanceof Date) {\n                    json +=\n                        JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;\n                } else if (value instanceof RegExp) {\n                    json += serializer.asString(value.source);\n                } else {\n                    json += serializer.asString(value.toString());\n                }\n            } else {\n                json += serializer.asString(value);\n            }\n        }\n\n        value = obj['error'];\n        if (value !== undefined) {\n            (!addComma && (addComma = true)) || (json += JSON_STR_COMMA);\n            json += '\"error\":';\n\n            if (typeof value !== 'string') {\n                if (value === null) {\n                    json += JSON_STR_EMPTY_STRING;\n                } else if (value instanceof Date) {\n                    json +=\n                        JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;\n                } else if (value instanceof RegExp) {\n                    json += serializer.asString(value.source);\n                } else {\n                    json += serializer.asString(value.toString());\n                }\n            } else {\n                json += serializer.asString(value);\n            }\n        }\n\n        value = obj['message'];\n        if (value !== undefined) {\n            (!addComma && (addComma = true)) || (json += JSON_STR_COMMA);\n            json += '\"message\":';\n\n            if (typeof value !== 'string') {\n                if (value === null) {\n                    json += JSON_STR_EMPTY_STRING;\n                } else if (value instanceof Date) {\n                    json +=\n                        JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;\n                } else if (value instanceof RegExp) {\n                    json += serializer.asString(value.source);\n                } else {\n                    json += serializer.asString(value.toString());\n                }\n            } else {\n                json += serializer.asString(value);\n            }\n        }\n\n        return json + JSON_STR_END_OBJECT;\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "obj",
    "snippet": "const obj =\n            input && typeof input.toJSON === 'function'\n                ? input.toJSON()\n                : input;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/error-serializer.ts",
    "type": "Constant",
    "value": "main",
    "snippet": "const main = anonymous0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "createError",
    "snippet": "const createError = (\n    code: string,\n    message: string,\n    statusCode = 500,\n    Base = Error,\n) => {\n    if (typeof code !== 'string') throw new Error('Erro code must be empty');\n    if (typeof message !== 'string')\n        throw new Error('Erro message must be empty');\n\n    code = code.toUpperCase();\n    !statusCode && (statusCode = undefined);\n\n    function CmmvError(this: any, ...args) {\n        this.code = code;\n        this.message = format(message, ...args);\n        this.statusCode = statusCode;\n    }\n\n    CmmvError.prototype = Object.create(Base.prototype, {\n        constructor: {\n            value: CmmvError,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        },\n    });\n\n    CmmvError.prototype[Symbol.toStringTag] = 'Error';\n\n    CmmvError.prototype.toString = function () {\n        return `${this.name} [${this.code}]: ${this.message}`;\n    };\n\n    return CmmvError;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Function",
    "value": "CmmvError",
    "snippet": "function CmmvError(this: any, ...args) {\n        this.code = code;\n        this.message = format(message, ...args);\n        this.statusCode = statusCode;\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_HTTP2_INVALID_VERSION",
    "snippet": "const CM_ERR_HTTP2_INVALID_VERSION = createError(\n    'CM_ERR_HTTP2_INVALID_VERSION',\n    'HTTP2 is available only from node >= 8.8.1',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_OPTIONS_NOT_OBJ",
    "snippet": "const CM_ERR_OPTIONS_NOT_OBJ = createError(\n    'CM_ERR_OPTIONS_NOT_OBJ',\n    'Options must be an object',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_QSP_NOT_FN",
    "snippet": "const CM_ERR_QSP_NOT_FN = createError(\n    'CM_ERR_QSP_NOT_FN',\n    \"querystringParser option should be a function, instead got '%s'\",\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_INSTANCE_ALREADY_LISTENING",
    "snippet": "const CM_ERR_INSTANCE_ALREADY_LISTENING = createError(\n    'CM_ERR_INSTANCE_ALREADY_LISTENING',\n    'CMMV instance is already listening. %s',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_ERROR_HANDLER_NOT_FN",
    "snippet": "const CM_ERR_ERROR_HANDLER_NOT_FN = createError(\n    'CM_ERR_ERROR_HANDLER_NOT_FN',\n    'Error Handler must be a function',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_HOOK_INVALID_TYPE",
    "snippet": "const CM_ERR_HOOK_INVALID_TYPE = createError(\n    'CM_ERR_HOOK_INVALID_TYPE',\n    'The hook name must be a string',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_HOOK_NOT_SUPPORTED",
    "snippet": "const CM_ERR_HOOK_NOT_SUPPORTED = createError(\n    'CM_ERR_HOOK_NOT_SUPPORTED',\n    '%s hook not supported!',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_HOOK_INVALID_HANDLER",
    "snippet": "const CM_ERR_HOOK_INVALID_HANDLER = createError(\n    'CM_ERR_HOOK_INVALID_HANDLER',\n    '%s hook should be a function, instead got %s',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_HOOK_INVALID_ASYNC_HANDLER",
    "snippet": "const CM_ERR_HOOK_INVALID_ASYNC_HANDLER = createError(\n    'CM_ERR_HOOK_INVALID_ASYNC_HANDLER',\n    \"Async function has too many arguments. Async hooks should not use the 'done' argument.\",\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_RES_ALREADY_SENT",
    "snippet": "const CM_ERR_RES_ALREADY_SENT = createError(\n    'CM_ERR_RES_ALREADY_SENT',\n    'Response was already sent, did you forget to \"return reply\" in \"%s\" (%s)?',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_BAD_TRAILER_NAME",
    "snippet": "const CM_ERR_BAD_TRAILER_NAME = createError(\n    'CM_ERR_BAD_TRAILER_NAME',\n    'Called res.trailer with an invalid header name: %s',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_BAD_TRAILER_VALUE",
    "snippet": "const CM_ERR_BAD_TRAILER_VALUE = createError(\n    'CM_ERR_BAD_TRAILER_VALUE',\n    \"Called res.trailer('%s', fn) with an invalid type: %s. Expected a function.\",\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_SEND_INSIDE_ONERR",
    "snippet": "const CM_ERR_SEND_INSIDE_ONERR = createError(\n    'CM_ERR_SEND_INSIDE_ONERR',\n    'You cannot use `send` inside the `onError` hook',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_SEND_CONTENTTYPE_ARR",
    "snippet": "const CM_ERR_SEND_CONTENTTYPE_ARR = createError(\n    'CM_ERR_SEND_CONTENTTYPE_ARR',\n    'Content-Type cannot be set to an Array',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_INVALID_CODE_TYPE",
    "snippet": "const CM_ERR_INVALID_CODE_TYPE = createError(\n    'CM_ERR_INVALID_CODE_TYPE',\n    'Invalid status code: %s Status code must be an integer.',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_INVALID_CODE_RANGE",
    "snippet": "const CM_ERR_INVALID_CODE_RANGE = createError(\n    'CM_ERR_INVALID_CODE_RANGE',\n    'Invalid status code: %s. Status code must be greater than 99 and less than 1000.',\n    500,\n    RangeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_RES_BODY_CONSUMED",
    "snippet": "const CM_ERR_RES_BODY_CONSUMED = createError(\n    'CM_ERR_RES_BODY_CONSUMED',\n    'Response.body is already consumed.',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_RES_INVALID_PAYLOAD_TYPE",
    "snippet": "const CM_ERR_RES_INVALID_PAYLOAD_TYPE = createError(\n    'CM_ERR_RES_INVALID_PAYLOAD_TYPE',\n    \"Attempted to send payload of invalid type '%s'. Expected a string or Buffer.\",\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_SEND_UNDEFINED_ERR",
    "snippet": "const CM_ERR_SEND_UNDEFINED_ERR = createError(\n    'CM_ERR_SEND_UNDEFINED_ERR',\n    'Undefined error has occurred',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_FAILED_ERROR_SERIALIZATION",
    "snippet": "const CM_ERR_FAILED_ERROR_SERIALIZATION = createError(\n    'CM_ERR_FAILED_ERROR_SERIALIZATION',\n    'Failed to serialize an error. Error: %s. Original error: %s.',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_ROUTE_MISSING_HANDLER",
    "snippet": "const CM_ERR_ROUTE_MISSING_HANDLER = createError(\n    'CM_ERR_ROUTE_MISSING_HANDLER',\n    'Missing handler function for \"%s:%s\" route.',\n    500,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/errors.ts",
    "type": "Constant",
    "value": "CM_ERR_ROUTE_HANDLER_NOT_FN",
    "snippet": "const CM_ERR_ROUTE_HANDLER_NOT_FN = createError(\n    'CM_ERR_ROUTE_HANDLER_NOT_FN',\n    'Error Handler for %s:%s route, if defined, must be a function',\n    500,\n    TypeError,\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "bodyless",
    "snippet": "const bodyless = new Set(['GET', 'HEAD', 'TRACE']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "bodywith",
    "snippet": "const bodywith = new Set(['DELETE', 'OPTIONS', 'PATCH', 'PUT', 'POST']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "handleRequest",
    "snippet": "const handleRequest = (err, request, res) => {\n    if (res.sent === true) return;\n\n    if (err != null) {\n        res[kResponseIsError] = true;\n        res.send(err);\n        return;\n    }\n\n    const method = request.req.method;\n    const headers = request.headers;\n\n    if (bodyless.has(method)) {\n        handler(request, res);\n        return;\n    }\n\n    if (bodywith.has(method)) {\n        const contentType = headers['content-type'];\n        const contentLength = headers['content-length'];\n        const transferEncoding = headers['transfer-encoding'];\n\n        if (contentType === undefined) {\n            if (\n                (contentLength === undefined || contentLength === '0') &&\n                transferEncoding === undefined\n            ) {\n            } else {\n                request.app.contentTypeParser('', handler, request, res);\n            }\n        } else {\n            if (\n                contentLength === undefined &&\n                transferEncoding === undefined &&\n                method === 'OPTIONS'\n            ) {\n                handler(request, res);\n                return;\n            }\n\n            request.app.contentTypeParser(contentType, handler, request, res);\n        }\n        return;\n    }\n\n    // Return 404 instead of 405 see https://github.com/fastify/fastify/pull/862 for discussion\n    handler(request, res);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method = request.req.method;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "headers",
    "snippet": "const headers = request.headers;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "contentType",
    "snippet": "const contentType = headers['content-type'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "contentLength",
    "snippet": "const contentLength = headers['content-length'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Constant",
    "value": "transferEncoding",
    "snippet": "const transferEncoding = headers['transfer-encoding'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Function",
    "value": "handler",
    "snippet": "function handler(req, res) {\n    if (\n        req?.preHandler !== null &&\n        req.preHandler !== undefined &&\n        req.preHandler.length > 0\n    ) {\n        preHandlerHookRunner(req.preHandler, req, res, preHandlerCallback);\n    } else {\n        preHandlerCallback(null, req, res);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/handle-request.ts",
    "type": "Function",
    "value": "preHandlerCallback",
    "snippet": "function preHandlerCallback(err, req, res) {\n    if (res.sent) return;\n\n    try {\n        if (err != null) {\n            res[kResponseIsError] = true;\n            res.send(err);\n            return;\n        }\n\n        let result;\n\n        try {\n            result = req.handler(req, res);\n        } catch (err) {\n            res[kResponseIsError] = true;\n            res.send(err);\n            return;\n        }\n\n        if (result !== undefined) {\n            if (result !== null && typeof result.then === 'function')\n                wrapThenable(result, res);\n            else res.send(result);\n        }\n    } finally {\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/hooks.ts",
    "type": "Class",
    "value": "Hooks",
    "snippet": "class Hooks {\n    public onRequest = [];\n    public onResponse = [];\n    public onSend = [];\n    public onError = [];\n    public onRoute = [];\n    public onRegister = [];\n    public onReady = [];\n    public onListen = [];\n    public onTimeout = [];\n    public onRequestAbort = [];\n    public preHandler = [];\n    public preParsing = [];\n    public preValidation = [];\n    public preSerialization = [];\n    public preClose = [];\n\n    public validate(hook: string, fn) {\n        if (typeof hook !== 'string') throw new CM_ERR_HOOK_INVALID_TYPE();\n        if (Array.isArray(this[hook]) === false)\n            throw new CM_ERR_HOOK_NOT_SUPPORTED(hook);\n        if (typeof fn !== 'function')\n            throw new CM_ERR_HOOK_INVALID_HANDLER(\n                hook,\n                Object.prototype.toString.call(fn),\n            );\n    }\n\n    public add(hook, fn) {\n        this.validate(hook, fn);\n        this[hook].push(fn);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "proto",
    "snippet": "const proto = this.get('X-Forwarded-Proto');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "trust",
    "snippet": "const trust = this.app.get('trust proxy fn');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "host",
    "snippet": "const host = this.host;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "originalUrl",
    "snippet": "const originalUrl = this.originalUrl || '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "method",
    "snippet": "const method = this.method;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "res",
    "snippet": "const res = this.res;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "status",
    "snippet": "const status = res.statusCode;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "methods",
    "snippet": "const methods = ['GET', 'HEAD', 'PUT', 'DELETE', 'OPTIONS', 'TRACE'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "trust",
    "snippet": "const trust = this.app.get('trust proxy fn');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "trust",
    "snippet": "const trust = this.app.get('trust proxy fn');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "addrs",
    "snippet": "const addrs = proxyaddr.all(this.req, trust);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "len",
    "snippet": "const len = this._length || this.get('Content-Length');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "hostname",
    "snippet": "const hostname = this.hostname;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "val",
    "snippet": "const val = this.get('X-Requested-With') || '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = this.get('Content-Type');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "range",
    "snippet": "const range = this.get('Range');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/request.ts",
    "type": "Constant",
    "value": "typeis",
    "snippet": "const typeis = require('typeis');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "send",
    "snippet": "const send = require('@fastify/send');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "onFinish",
    "snippet": "const onFinish = require('on-finished');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "vary",
    "snippet": "const vary = require('vary');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "createError",
    "snippet": "const createError = require('http-errors');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "fastJson",
    "snippet": "const fastJson = require('fast-json-stringify');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "INVALID_TRAILERS",
    "snippet": "const INVALID_TRAILERS = new Set([\n    'transfer-encoding',\n    'content-length',\n    'host',\n    'cache-control',\n    'max-forwards',\n    'te',\n    'authorization',\n    'set-cookie',\n    'content-encoding',\n    'content-type',\n    'content-range',\n    'trailer',\n]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "setupResponseListeners",
    "snippet": "const setupResponseListeners = res => {\n    res[kResponseStartTime] = res.now();\n\n    const onResFinished = err => {\n        res[kResponseEndTime] = res.now();\n        res.removeListener('finish', onResFinished);\n        res.removeListener('error', onResFinished);\n\n        if (res && res.onResponse !== null && res.onResponse.length > 0) {\n            onResponseHookRunner(\n                res.onResponse,\n                res.request,\n                res,\n                onResponseCallback,\n            );\n        } else {\n            onResponseCallback(err, res.request, res);\n        }\n    };\n\n    res.on('finish', onResFinished);\n    res.on('error', onResFinished);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "onResFinished",
    "snippet": "const onResFinished = err => {\n        res[kResponseEndTime] = res.now();\n        res.removeListener('finish', onResFinished);\n        res.removeListener('error', onResFinished);\n\n        if (res && res.onResponse !== null && res.onResponse.length > 0) {\n            onResponseHookRunner(\n                res.onResponse,\n                res.request,\n                res,\n                onResponseCallback,\n            );\n        } else {\n            onResponseCallback(err, res.request, res);\n        }\n    };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "wrapThenable",
    "snippet": "const wrapThenable = (thenable, res, store?) => {\n    if (store) store.async = true;\n\n    thenable.then(\n        function (payload) {\n            if (res[kResponseHijacked] === true) return;\n\n            try {\n                if (\n                    payload !== undefined ||\n                    (res.sent === false &&\n                        res.headersSent === false &&\n                        res.request.aborted === false)\n                ) {\n                    try {\n                        res.send(payload);\n                    } catch (err) {\n                        res[kResponseIsError] = true;\n                        res.send(err);\n                    }\n                }\n            } finally {\n            }\n        },\n        function (err) {\n            try {\n                if (res.sent === true) {\n                    console.error(\n                        { err },\n                        'Promise errored, but reply.sent = true was set',\n                    );\n                    return;\n                }\n\n                res[kResponseIsError] = true;\n                res.send(err);\n            } catch (err) {\n                res.send(err);\n            }\n        },\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "safeWriteHead",
    "snippet": "function safeWriteHead(response, statusCode) {\n    if (response.headersSent === true) return;\n\n    try {\n        response.res.writeHead(statusCode, response[kResponseHeaders]);\n    } catch (err) {\n        /*if (err.code === 'ERR_HTTP_HEADERS_SENT') {\n            console.warn(\n                `Reply was already sent, did you forget to \"return reply\" in the \"${response.request.url}\" (${response.request.method}) route?`,\n            );\n        }*/\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "preSerializationHook",
    "snippet": "function preSerializationHook(res, payload) {\n    if (res.preSerialization !== null && res.preSerialization.length > 0) {\n        preSerializationHookRunner(\n            res.preSerialization,\n            res.request,\n            res,\n            payload,\n            preSerializationHookEnd,\n        );\n    } else {\n        preSerializationHookEnd(null, res.request, res, payload);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "preSerializationHookEnd",
    "snippet": "function preSerializationHookEnd(err, req, res, payload) {\n    if (err != null) {\n        onErrorHook(res, err);\n        return;\n    }\n\n    try {\n        if (res[kResponseSerializer] !== null) {\n            payload = res[kResponseSerializer](payload);\n        } else if (res[kResponseSerializerDefault]) {\n            payload = res[kResponseSerializerDefault](payload, res.statusCode);\n        } else {\n            payload = res.serialize(\n                res,\n                payload,\n                res.statusCode,\n                res[kResponseHeaders]['content-type'],\n            );\n        }\n    } catch (e) {\n        wrapSerializationError(e, res);\n        onErrorHook(res, e);\n        return;\n    }\n\n    onSendHook(res, payload);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "wrapSerializationError",
    "snippet": "function wrapSerializationError(error, res) {\n    error.serialization = res.request.config;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "onErrorHook",
    "snippet": "function onErrorHook(res, error, cb?) {\n    if (\n        res.onError !== null &&\n        res.onError !== undefined &&\n        res.onError.length > 0 &&\n        !res[kResponseNextErrorHandler]\n    ) {\n        res[kResponseIsRunningOnErrorHook] = true;\n        onSendHookRunner(res.onError, res.request, res, error, () =>\n            handleError(res, error, cb),\n        );\n    } else {\n        handleError(res, error, cb);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "onSendHook",
    "snippet": "function onSendHook(res, payload) {\n    if (\n        res.onSend !== null &&\n        res.onSend !== undefined &&\n        res.onSend.length > 0\n    ) {\n        onSendHookRunner(res.onSend, res.request, res, payload, wrapOnSendEnd);\n    } else {\n        onSendEnd(res, payload);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "onSendEnd",
    "snippet": "function onSendEnd(response, payload) {\n    if (response.headersSent === true) return;\n\n    // Optimized trailer processing\n    const trailers = response[kResponseTrailers];\n    if (trailers != null) {\n        let header = '';\n        for (const trailerName in trailers) {\n            if (typeof trailers[trailerName] !== 'function') continue;\n            header += `${trailerName} `;\n        }\n        if (header) {\n            response.res.setHeader('Transfer-Encoding', 'chunked');\n            response.res.setHeader('Trailer', header.trim());\n        }\n    }\n\n    if (payload && payload.body) {\n        if (payload.bodyUsed) throw new CM_ERR_RES_BODY_CONSUMED();\n        payload = payload.body;\n    }\n\n    for (const key in response[kResponseHeaders])\n        response.res.setHeader(key, response[kResponseHeaders][key]);\n\n    const statusCode = response.res.statusCode;\n\n    if (statusCode === 304 || statusCode === 204) payload = null;\n\n    if (payload == null) {\n        if (\n            statusCode >= 200 &&\n            response.request.method !== 'HEAD' &&\n            trailers != null\n        ) {\n            trailers['content-length'] = '0';\n        }\n\n        safeWriteHead(response, statusCode);\n        sendTrailer(payload, response);\n        return;\n    }\n\n    if ((statusCode >= 100 && statusCode < 200) || statusCode === 204) {\n        response.res.removeHeader('content-type');\n        response.res.removeHeader('content-length');\n        safeWriteHead(response, statusCode);\n        sendTrailer(undefined, response);\n        if (typeof payload.resume === 'function') payload.resume();\n        return;\n    }\n\n    if (typeof payload.pipe === 'function') {\n        sendStream(payload, response);\n        return;\n    }\n\n    if (typeof payload.getReader === 'function') {\n        sendWebStream(payload, response);\n        return;\n    }\n\n    if (typeof payload !== 'string' && !Buffer.isBuffer(payload))\n        throw new CM_ERR_RES_INVALID_PAYLOAD_TYPE(typeof payload);\n\n    if (!response[kResponseHeaders]['content-length']) {\n        response[kResponseHeaders]['content-length'] =\n            Buffer.byteLength(payload).toString();\n    }\n\n    safeWriteHead(response, statusCode);\n\n    if (response.req.method.toLowerCase() !== 'head') \n        response.res.write(payload);\n    \n    response.res.end();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailers",
    "snippet": "const trailers = response[kResponseTrailers];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailerName",
    "snippet": "const trailerName"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "statusCode",
    "snippet": "const statusCode = response.res.statusCode;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "onResponseCallback",
    "snippet": "function onResponseCallback(err, req, res) {\n    if (res[kDisableRequestLogging]) return;\n\n    const responseTime = res.elapsedTime;\n\n    if (err != null) {\n        console.error({ res, err, responseTime }, 'request errored');\n        return;\n    }\n\n    console.info({ res, responseTime }, 'request completed');\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "responseTime",
    "snippet": "const responseTime = res.elapsedTime;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "wrapOnSendEnd",
    "snippet": "function wrapOnSendEnd(err, req, res, payload) {\n    if (err != null) onErrorHook(res, err);\n    else onSendEnd(res, payload);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "shouldSendTrailer",
    "snippet": "function shouldSendTrailer(response) {\n    return (\n        response[kResponseTrailers] !== null &&\n        typeof response.res.addTrailers === 'function'\n    );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "sendTrailer",
    "snippet": "function sendTrailer(payload, response) {\n    if (!shouldSendTrailer(response)) {\n        response.res.end(payload || null);\n        return;\n    }\n\n    const trailerHeaders = Object.keys(response[kResponseTrailers]);\n    const trailers = {};\n    let handled = 0;\n\n    function send() {\n        if (handled === trailerHeaders.length) {\n            response.res.addTrailers(trailers);\n            response.res.end(payload || null);\n        }\n    }\n\n    for (const trailerName of trailerHeaders) {\n        const trailerFn = response[kResponseTrailers][trailerName];\n        if (typeof trailerFn === 'function') {\n            handled++;\n            trailerFn(response, payload, (err, value) => {\n                if (!err) trailers[trailerName] = value;\n                handled--;\n                send();\n            });\n        }\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailerHeaders",
    "snippet": "const trailerHeaders = Object.keys(response[kResponseTrailers]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailers",
    "snippet": "const trailers = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "send",
    "snippet": "function send() {\n        if (handled === trailerHeaders.length) {\n            response.res.addTrailers(trailers);\n            response.res.end(payload || null);\n        }\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailerName",
    "snippet": "const trailerName"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "trailerFn",
    "snippet": "const trailerFn = response[kResponseTrailers][trailerName];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "sendStreamTrailer",
    "snippet": "function sendStreamTrailer(payload, response) {\n    if (!shouldSendTrailer(response)) return;\n\n    payload.on('end', () => {\n        process.nextTick(() => sendTrailer(null, response));\n    });\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "logStreamError",
    "snippet": "function logStreamError(logger, err, res) {\n    if (err.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n        if (!logger[kDisableRequestLogging])\n            logger.info({ res }, 'stream closed prematurely');\n    } else {\n        logger.warn(\n            { err },\n            'response terminated with an error with headers already sent',\n        );\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "sendStream",
    "snippet": "function sendStream(payload, response) {\n    let sourceOpen = true;\n    let errorLogged = false;\n\n    if (\n        !(\n            payload instanceof Readable ||\n            (payload && typeof payload.pipe === 'function')\n        )\n    ) {\n        console.error('The payload is not a readable stream');\n        response.res.statusCode = 500;\n        response.res.end('Internal Server Error');\n        return;\n    }\n\n    sendStreamTrailer(payload, response);\n\n    eos(payload, { readable: true, writable: false }, function (err) {\n        sourceOpen = false;\n        if (err != null) {\n            if (response.headersSent || response.request.aborted === true) {\n                if (!errorLogged) {\n                    errorLogged = true;\n                    logStreamError(console, err, response);\n                }\n                response.destroy();\n            } else {\n                onErrorHook(response, err);\n            }\n        }\n    });\n\n    eos(response.res, function (err) {\n        if (sourceOpen) {\n            if (err != null && response.headersSent && !errorLogged) {\n                errorLogged = true;\n                logStreamError(console, err, response);\n            }\n\n            if (typeof payload.destroy === 'function') {\n                payload.destroy();\n            } else if (typeof payload.close === 'function') {\n                payload.close(noop);\n            } else if (typeof payload.abort === 'function') {\n                payload.abort();\n            } else {\n                console.warn('stream payload does not end properly');\n            }\n        }\n    });\n\n    if (!response.headersSent) {\n        for (const key in response[kResponseHeaders])\n            response.res.setHeader(key, response[kResponseHeaders][key]);\n    } else {\n        console.warn(\n            \"response will send, but you shouldn't use res.writeHead in stream mode\",\n        );\n    }\n\n    payload.pipe(response.res);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "sendWebStream",
    "snippet": "function sendWebStream(payload, res) {\n    const nodeStream = Readable.fromWeb(payload);\n    sendStream(nodeStream, res);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "nodeStream",
    "snippet": "const nodeStream = Readable.fromWeb(payload);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "serialize",
    "snippet": "function serialize(context, data, statusCode, contentType?) {\n    //const fnSerialize = getSchemaSerializer(context, statusCode, contentType);\n\n    //if (fnSerialize)\n    //    return fnSerialize(data)\n\n    return JSON.stringify(data);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "createReadableStream",
    "snippet": "function createReadableStream(payload) {\n    if (Buffer.isBuffer(payload)) {\n        return Readable.from(payload);\n    } else if (typeof payload === 'string') {\n        return Readable.from([payload]);\n    } else if (typeof payload === 'object') {\n        const jsonString = JSON.stringify(payload);\n        return Readable.from([jsonString]);\n    } else {\n        throw new Error('Unsupported payload type');\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "jsonString",
    "snippet": "const jsonString = JSON.stringify(payload);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Function",
    "value": "noop",
    "snippet": "function noop() {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "ts",
    "snippet": "const ts = process.hrtime();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "endTime",
    "snippet": "const endTime = this[kResponseEndTime] || this.now;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "original",
    "snippet": "const original = this._body;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "setType",
    "snippet": "const setType = !this.has('Content-Type');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "headers",
    "snippet": "const headers = val.headers;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "date",
    "snippet": "const date = this.get('last-modified');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "socket",
    "snippet": "const socket = this.res.socket;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "ct",
    "snippet": "const ct =\n            type.indexOf('/') === -1\n                ? mime.getType(type) || 'application/octet-stream'\n                : type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "payload",
    "snippet": "const payload = statuses.message[statusCode] || String(statusCode);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "customContentType",
    "snippet": "const customContentType = contentType.trim();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "escape",
    "snippet": "const escape = this.app.get('json escape');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "replacer",
    "snippet": "const replacer = this.app.get('json replacer');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "spaces",
    "snippet": "const spaces = this.app.get('json spaces');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "stringify",
    "snippet": "const stringify = fastJson(schema);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "escape",
    "snippet": "const escape = this.app.get('json escape');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "replacer",
    "snippet": "const replacer = this.app.get('json replacer');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "spaces",
    "snippet": "const spaces = this.app.get('json spaces');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "req",
    "snippet": "const req = this.req;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "res",
    "snippet": "const res = this;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "next",
    "snippet": "const next = req.next;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "pathname",
    "snippet": "const pathname = encodeURI(path);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "file",
    "snippet": "const file = send(req, pathname, opts);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "headers",
    "snippet": "const headers = {\n            'Content-Disposition': contentDisposition(name || path),\n        };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "keys",
    "snippet": "const keys = Object.keys(opts.headers);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "fullPath",
    "snippet": "const fullPath = !opts.root ? resolve(path) : path;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "prev",
    "snippet": "const prev = this.get(field);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts = { path: '/', ...options, expires: new Date(1) };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts = utilsMerge({}, options);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "secret",
    "snippet": "const secret = this.req.secret;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "signed",
    "snippet": "const signed = opts.signed;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "maxAge",
    "snippet": "const maxAge = opts.maxAge - 0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "app",
    "snippet": "const app = this.app;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "req",
    "snippet": "const req = this.req;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/response.ts",
    "type": "Constant",
    "value": "self",
    "snippet": "const self = this;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Class",
    "value": "Router",
    "snippet": "class Router {\n    public router: FindMyWay.Instance<FindMyWay.HTTPVersion.V2>;\n\n    public stack: Map<FindMyWay.HTTPMethod, Array<Function>> = new Map<\n        FindMyWay.HTTPMethod,\n        Array<Function>\n    >();\n\n    public params: Map<string, Function[]> = new Map<string, Function[]>();\n\n    public optionsAllow: Map<string, Set<string>> = new Map<\n        string,\n        Set<string>\n    >();\n\n    public registeredRoutes: {\n        method: FindMyWay.HTTPMethod;\n        path: string;\n        options: any;\n    }[] = [];\n\n    constructor(private path: string = '') {\n        if (!this.router) {\n            this.router = FindMyWay({\n                caseSensitive: false,\n                ignoreTrailingSlash: true,\n                ignoreDuplicateSlashes: true,\n                allowUnsafeRegex: true,\n            });\n\n            this.stack = new Map<FindMyWay.HTTPMethod, Array<Function>>();\n        }\n    }\n\n    public param(valueOrObject: string | string[], cb) {\n        //compatibility Expressjs\n        if (\n            typeof valueOrObject === 'string' &&\n            !this.params.has(valueOrObject)\n        )\n            this.params.set(valueOrObject, []);\n\n        if (typeof valueOrObject === 'string') {\n            const stack = this.params.get(valueOrObject);\n            stack.push(cb);\n            this.params.set(valueOrObject, stack);\n        } else if (Array.isArray(valueOrObject)) {\n            valueOrObject.forEach(item => {\n                if (typeof item === 'string' && !this.params.has(item))\n                    this.params.set(item, []);\n\n                const stack = this.params.get(item);\n                stack.push(cb);\n                this.params.set(item, stack);\n            });\n        }\n    }\n\n    public hasRoute(method: string, path: string) {\n        const httpMethod = method?.toUpperCase() as FindMyWay.HTTPMethod;\n        return this.router.hasRoute(httpMethod, path);\n    }\n\n    public find(method: string, path: string) {\n        return new Promise((resolve, reject) => {\n            if (method && path) {\n                const httpMethod =\n                    method?.toUpperCase() as FindMyWay.HTTPMethod;\n\n                const route = this.router.find(httpMethod, path);\n\n                if (route) resolve(route);\n                else reject();\n            } else {\n                reject();\n            }\n        });\n    }\n\n    public route(options: any) {\n        const opts = { ...options };\n\n        const path = opts.url || opts.path || '';\n        const finalPath = this.path ? this.path + path : path;\n\n        if (!opts.handler)\n            throw new CM_ERR_ROUTE_MISSING_HANDLER(opts.method, path);\n\n        if (\n            opts.errorHandler !== undefined &&\n            typeof opts.errorHandler !== 'function'\n        )\n            throw new CM_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path);\n\n        const methods = Array.isArray(opts.method)\n            ? opts.method\n            : [opts.method];\n\n        for (let method of methods) {\n            if (!this.router.hasRoute(method, finalPath)) {\n                this.router.on(method, finalPath, (req, res) => {}, {\n                    stack: [opts.handler],\n                    config: opts.config,\n                });\n            } else {\n                const handler = this.router.find(method, finalPath);\n                this.router.off(method, finalPath);\n                this.router.on(method, finalPath, (req, res) => {}, {\n                    stack: [...handler.store.stack, ...opts.handler],\n                    config: opts.config,\n                });\n            }\n        }\n    }\n\n    private mergeRoutes(\n        method: FindMyWay.HTTPMethod,\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        if (typeof path !== 'function') {\n            let finalPath = this.path ? this.path + path : path;\n\n            if (typeof finalPath === 'string') {\n                if (!this.optionsAllow.has(finalPath))\n                    this.optionsAllow.set(finalPath, new Set<string>());\n\n                if (!this.router.hasRoute(method, finalPath)) {\n                    this.router.on(method, finalPath, (req, res) => {}, {\n                        stack: callbacks,\n                    });\n\n                    this.registeredRoutes.push({\n                        method,\n                        path: finalPath,\n                        options: { callbacks },\n                    });\n                } else {\n                    const handler = this.router.find(method, finalPath);\n                    this.router.off(method, finalPath);\n                    this.router.on(method, finalPath, (req, res) => {}, {\n                        stack: [...handler.store.stack, ...callbacks],\n                    });\n                }\n            }\n        } else {\n            const stack = this.stack.has(method) ? this.stack.get(method) : [];\n            stack.push(path);\n            this.stack.set(method, stack);\n        }\n    }\n\n    public acl(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('ACL', path, ...callbacks);\n    }\n\n    public bind(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('BIND', path, ...callbacks);\n    }\n\n    public checkout(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('CHECKOUT', path, ...callbacks);\n    }\n\n    public connect(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('CONNECT', path, ...callbacks);\n    }\n\n    public copy(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('COPY', path, ...callbacks);\n    }\n\n    public delete(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('DELETE', path, ...callbacks);\n    }\n\n    public get(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('GET', path, ...callbacks);\n        this.mergeRoutes('HEAD', path, ...callbacks);\n    }\n\n    public head(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('HEAD', path, ...callbacks);\n    }\n\n    public link(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('LINK', path, ...callbacks);\n    }\n\n    public lock(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('LOCK', path, ...callbacks);\n    }\n\n    public 'm-search'(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('M-SEARCH', path, ...callbacks);\n    }\n\n    public merge(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('MERGE', path, ...callbacks);\n    }\n\n    public mkactivity(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('MKACTIVITY', path, ...callbacks);\n    }\n\n    public mkcalendar(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('MKCALENDAR', path, ...callbacks);\n    }\n\n    public mkcol(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('MKCOL', path, ...callbacks);\n    }\n\n    public move(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('MOVE', path, ...callbacks);\n    }\n\n    public notify(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('NOTIFY', path, ...callbacks);\n    }\n\n    public options(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('OPTIONS', path, ...callbacks);\n    }\n\n    public patch(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('PATCH', path, ...callbacks);\n    }\n\n    public post(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('POST', path, ...callbacks);\n    }\n\n    public propfind(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('PROPFIND', path, ...callbacks);\n    }\n\n    public proppatch(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('PROPPATCH', path, ...callbacks);\n    }\n\n    public purge(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('PURGE', path, ...callbacks);\n    }\n\n    public put(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('PUT', path, ...callbacks);\n    }\n\n    public rebind(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('REBIND', path, ...callbacks);\n    }\n\n    public report(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('REPORT', path, ...callbacks);\n    }\n\n    public search(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('SEARCH', path, ...callbacks);\n    }\n\n    public source(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('SOURCE', path, ...callbacks);\n    }\n\n    public subscribe(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('SUBSCRIBE', path, ...callbacks);\n    }\n\n    public trace(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('TRACE', path, ...callbacks);\n    }\n\n    public unbind(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('UNBIND', path, ...callbacks);\n    }\n\n    public unlink(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('UNLINK', path, ...callbacks);\n    }\n\n    public unlock(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('UNLOCK', path, ...callbacks);\n    }\n\n    public unsubscribe(\n        path: string | Function,\n        ...callbacks: Array<\n            (req: Request, res: Response, next?: Function) => void\n        >\n    ) {\n        this.mergeRoutes('UNSUBSCRIBE', path, ...callbacks);\n    }\n\n    public use(path: string, fn: Function) {\n        //console.log(path, fn);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "stack",
    "snippet": "const stack = this.params.get(valueOrObject);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "stack",
    "snippet": "const stack = this.params.get(item);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "httpMethod",
    "snippet": "const httpMethod = method?.toUpperCase() as FindMyWay.HTTPMethod;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "httpMethod",
    "snippet": "const httpMethod =\n                    method?.toUpperCase() as FindMyWay.HTTPMethod;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "route",
    "snippet": "const route = this.router.find(httpMethod, path);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts = { ...options };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "path",
    "snippet": "const path = opts.url || opts.path || '';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "finalPath",
    "snippet": "const finalPath = this.path ? this.path + path : path;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "methods",
    "snippet": "const methods = Array.isArray(opts.method)\n            ? opts.method\n            : [opts.method];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = this.router.find(method, finalPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "handler",
    "snippet": "const handler = this.router.find(method, finalPath);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/router.ts",
    "type": "Constant",
    "value": "stack",
    "snippet": "const stack = this.stack.has(method) ? this.stack.get(method) : [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kHooks",
    "snippet": "const kHooks = Symbol('cmmv.hooks');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.hooks",
    "snippet": "Symbol('cmmv.hooks')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kChildren",
    "snippet": "const kChildren = Symbol('cmmv.children');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.children",
    "snippet": "Symbol('cmmv.children')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kState",
    "snippet": "const kState = Symbol('cmmv.state');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.state",
    "snippet": "Symbol('cmmv.state')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kOptions",
    "snippet": "const kOptions = Symbol('cmmv.options');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.options",
    "snippet": "Symbol('cmmv.options')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kMiddlewares",
    "snippet": "const kMiddlewares = Symbol('cmmv.middlewares');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.middlewares",
    "snippet": "Symbol('cmmv.middlewares')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kContentTypeParsers",
    "snippet": "const kContentTypeParsers = Symbol('cmmv.contentTypeParsers');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.contentTypeParsers",
    "snippet": "Symbol('cmmv.contentTypeParsers')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kSchemaResponse",
    "snippet": "const kSchemaResponse = Symbol('cmmv.schema.response');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.schema.response",
    "snippet": "Symbol('cmmv.schema.response')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kRequest",
    "snippet": "const kRequest = Symbol('cmmv.request');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.request",
    "snippet": "Symbol('cmmv.request')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kRequestOriginalUrl",
    "snippet": "const kRequestOriginalUrl = Symbol('cmmv.request.originalUrl');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.request.originalUrl",
    "snippet": "Symbol('cmmv.request.originalUrl')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kDisableRequestLogging",
    "snippet": "const kDisableRequestLogging = Symbol('cmmv.request.disableLogging');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.request.disableLogging",
    "snippet": "Symbol('cmmv.request.disableLogging')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kRequestPayloadStream",
    "snippet": "const kRequestPayloadStream = Symbol('cmmv.request.payloadStream');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.request.payloadStream",
    "snippet": "Symbol('cmmv.request.payloadStream')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponse",
    "snippet": "const kResponse = Symbol('cmmv.response');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response",
    "snippet": "Symbol('cmmv.response')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseSerializer",
    "snippet": "const kResponseSerializer = Symbol('cmmv.response.serializer');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.serializer",
    "snippet": "Symbol('cmmv.response.serializer')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseIsError",
    "snippet": "const kResponseIsError = Symbol('cmmv.response.isError');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.isError",
    "snippet": "Symbol('cmmv.response.isError')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseErrorHandlerCalled",
    "snippet": "const kResponseErrorHandlerCalled = Symbol(\n    'cmmv.response.errorHandlerCalled',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.errorHandlerCalled",
    "snippet": "Symbol(\n    'cmmv.response.errorHandlerCalled',\n)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseHeaders",
    "snippet": "const kResponseHeaders = Symbol('cmmv.response.headers');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.headers",
    "snippet": "Symbol('cmmv.response.headers')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseHasStatusCode",
    "snippet": "const kResponseHasStatusCode = Symbol('cmmv.response.hasStatusCode');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.hasStatusCode",
    "snippet": "Symbol('cmmv.response.hasStatusCode')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseStartTime",
    "snippet": "const kResponseStartTime = Symbol('cmmv.response.startTime');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.startTime",
    "snippet": "Symbol('cmmv.response.startTime')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseEndTime",
    "snippet": "const kResponseEndTime = Symbol('cmmv.response.endTime');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.endTime",
    "snippet": "Symbol('cmmv.response.endTime')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseSerializerDefault",
    "snippet": "const kResponseSerializerDefault = Symbol(\n    'cmmv.response.serializerDefault',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.serializerDefault",
    "snippet": "Symbol(\n    'cmmv.response.serializerDefault',\n)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseIsRunningOnErrorHook",
    "snippet": "const kResponseIsRunningOnErrorHook = Symbol(\n    'cmmv.response.isRunningOnErrorHook',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.isRunningOnErrorHook",
    "snippet": "Symbol(\n    'cmmv.response.isRunningOnErrorHook',\n)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseTrailers",
    "snippet": "const kResponseTrailers = Symbol('cmmv.response.trailers');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.trailers",
    "snippet": "Symbol('cmmv.response.trailers')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseHijacked",
    "snippet": "const kResponseHijacked = Symbol('cmmv.response.hijacked');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.hijacked",
    "snippet": "Symbol('cmmv.response.hijacked')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseCacheSerializeFns",
    "snippet": "const kResponseCacheSerializeFns = Symbol(\n    'cmmv.response.cacheSerializeFns',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.cacheSerializeFns",
    "snippet": "Symbol(\n    'cmmv.response.cacheSerializeFns',\n)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kResponseNextErrorHandler",
    "snippet": "const kResponseNextErrorHandler = Symbol(\n    'cmmv.response.nextErrorHandler',\n);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.response.nextErrorHandler",
    "snippet": "Symbol(\n    'cmmv.response.nextErrorHandler',\n)"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Constant",
    "value": "kErrorHandler",
    "snippet": "const kErrorHandler = Symbol('cmmv.errorHandler');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/symbols.ts",
    "type": "Symbol",
    "value": "cmmv.errorHandler",
    "snippet": "Symbol('cmmv.errorHandler')"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "dirname",
    "snippet": "const dirname = path.dirname;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "basename",
    "snippet": "const basename = path.basename;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "extname",
    "snippet": "const extname = path.extname;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "join",
    "snippet": "const join = path.join;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "resolve",
    "snippet": "const resolve = path.resolve;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Function",
    "value": "View",
    "snippet": "function View(this: any, name, options) {\n    const opts = options || {};\n\n    this.defaultEngine = opts.defaultEngine;\n    this.ext = extname(name);\n    this.name = name;\n    this.root = opts.root;\n\n    if (!this.ext && !this.defaultEngine)\n        throw new Error(\n            'No default engine was specified and no extension was provided.',\n        );\n\n    let fileName = name;\n\n    if (!this.ext) {\n        this.ext =\n            this.defaultEngine[0] !== '.'\n                ? '.' + this.defaultEngine\n                : this.defaultEngine;\n\n        fileName += this.ext;\n    }\n\n    if (!opts.engines[this.ext]) {\n        const mod = this.ext.slice(1);\n        const fn = require(mod).__express;\n\n        if (typeof fn !== 'function')\n            throw new Error(\n                'Module \"' + mod + '\" does not provide a view engine.',\n            );\n\n        opts.engines[this.ext] = fn;\n    }\n\n    this.engine = opts.engines[this.ext];\n    this.path = this.lookup(fileName);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts = options || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "mod",
    "snippet": "const mod = this.ext.slice(1);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "fn",
    "snippet": "const fn = require(mod).__express;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "root",
    "snippet": "const root = roots[i];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "loc",
    "snippet": "const loc = resolve(root, name);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "dir",
    "snippet": "const dir = dirname(loc);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Constant",
    "value": "file",
    "snippet": "const file = basename(loc);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/lib/view.ts",
    "type": "Function",
    "value": "tryStat",
    "snippet": "function tryStat(path) {\n    try {\n        return fs.statSync(path);\n    } catch (e) {\n        return undefined;\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/interfaces/cookies-options.interface.ts",
    "type": "Interface",
    "value": "CookieOptions",
    "snippet": "interface CookieOptions {\r\n    domain?: string;\r\n    encode?: Function;\r\n    expires?: Date;\r\n    httpOnly?: boolean;\r\n    maxAge?: number;\r\n    path?: string;\r\n    partitioned?: boolean;\r\n    priority?: string;\r\n    secure: boolean;\r\n    signed: boolean;\r\n    sameSite: boolean | string;\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/types/other.ts",
    "type": "Constant",
    "value": "types",
    "snippet": "const types: { [key: string]: string[] } = {\n    'application/prs.cww': ['cww'],\n    'application/prs.xsf+xml': ['xsf'],\n    'application/vnd.1000minds.decision-model+xml': ['1km'],\n    'application/vnd.3gpp.pic-bw-large': ['plb'],\n    'application/vnd.3gpp.pic-bw-small': ['psb'],\n    'application/vnd.3gpp.pic-bw-var': ['pvb'],\n    'application/vnd.3gpp2.tcap': ['tcap'],\n    'application/vnd.3m.post-it-notes': ['pwn'],\n    'application/vnd.accpac.simply.aso': ['aso'],\n    'application/vnd.accpac.simply.imp': ['imp'],\n    'application/vnd.acucobol': ['acu'],\n    'application/vnd.acucorp': ['atc', 'acutc'],\n    'application/vnd.adobe.air-application-installer-package+zip': ['air'],\n    'application/vnd.adobe.formscentral.fcdt': ['fcdt'],\n    'application/vnd.adobe.fxp': ['fxp', 'fxpl'],\n    'application/vnd.adobe.xdp+xml': ['xdp'],\n    'application/vnd.adobe.xfdf': ['*xfdf'],\n    'application/vnd.age': ['age'],\n    'application/vnd.ahead.space': ['ahead'],\n    'application/vnd.airzip.filesecure.azf': ['azf'],\n    'application/vnd.airzip.filesecure.azs': ['azs'],\n    'application/vnd.amazon.ebook': ['azw'],\n    'application/vnd.americandynamics.acc': ['acc'],\n    'application/vnd.amiga.ami': ['ami'],\n    'application/vnd.android.package-archive': ['apk'],\n    'application/vnd.anser-web-certificate-issue-initiation': ['cii'],\n    'application/vnd.anser-web-funds-transfer-initiation': ['fti'],\n    'application/vnd.antix.game-component': ['atx'],\n    'application/vnd.apple.installer+xml': ['mpkg'],\n    'application/vnd.apple.keynote': ['key'],\n    'application/vnd.apple.mpegurl': ['m3u8'],\n    'application/vnd.apple.numbers': ['numbers'],\n    'application/vnd.apple.pages': ['pages'],\n    'application/vnd.apple.pkpass': ['pkpass'],\n    'application/vnd.aristanetworks.swi': ['swi'],\n    'application/vnd.astraea-software.iota': ['iota'],\n    'application/vnd.audiograph': ['aep'],\n    'application/vnd.balsamiq.bmml+xml': ['bmml'],\n    'application/vnd.blueice.multipass': ['mpm'],\n    'application/vnd.bmi': ['bmi'],\n    'application/vnd.businessobjects': ['rep'],\n    'application/vnd.chemdraw+xml': ['cdxml'],\n    'application/vnd.chipnuts.karaoke-mmd': ['mmd'],\n    'application/vnd.cinderella': ['cdy'],\n    'application/vnd.citationstyles.style+xml': ['csl'],\n    'application/vnd.claymore': ['cla'],\n    'application/vnd.cloanto.rp9': ['rp9'],\n    'application/vnd.clonk.c4group': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],\n    'application/vnd.cluetrust.cartomobile-config': ['c11amc'],\n    'application/vnd.cluetrust.cartomobile-config-pkg': ['c11amz'],\n    'application/vnd.commonspace': ['csp'],\n    'application/vnd.contact.cmsg': ['cdbcmsg'],\n    'application/vnd.cosmocaller': ['cmc'],\n    'application/vnd.crick.clicker': ['clkx'],\n    'application/vnd.crick.clicker.keyboard': ['clkk'],\n    'application/vnd.crick.clicker.palette': ['clkp'],\n    'application/vnd.crick.clicker.template': ['clkt'],\n    'application/vnd.crick.clicker.wordbank': ['clkw'],\n    'application/vnd.criticaltools.wbs+xml': ['wbs'],\n    'application/vnd.ctc-posml': ['pml'],\n    'application/vnd.cups-ppd': ['ppd'],\n    'application/vnd.curl.car': ['car'],\n    'application/vnd.curl.pcurl': ['pcurl'],\n    'application/vnd.dart': ['dart'],\n    'application/vnd.data-vision.rdz': ['rdz'],\n    'application/vnd.dbf': ['dbf'],\n    'application/vnd.dece.data': ['uvf', 'uvvf', 'uvd', 'uvvd'],\n    'application/vnd.dece.ttml+xml': ['uvt', 'uvvt'],\n    'application/vnd.dece.unspecified': ['uvx', 'uvvx'],\n    'application/vnd.dece.zip': ['uvz', 'uvvz'],\n    'application/vnd.denovo.fcselayout-link': ['fe_launch'],\n    'application/vnd.dna': ['dna'],\n    'application/vnd.dolby.mlp': ['mlp'],\n    'application/vnd.dpgraph': ['dpg'],\n    'application/vnd.dreamfactory': ['dfac'],\n    'application/vnd.ds-keypoint': ['kpxx'],\n    'application/vnd.dvb.ait': ['ait'],\n    'application/vnd.dvb.service': ['svc'],\n    'application/vnd.dynageo': ['geo'],\n    'application/vnd.ecowin.chart': ['mag'],\n    'application/vnd.enliven': ['nml'],\n    'application/vnd.epson.esf': ['esf'],\n    'application/vnd.epson.msf': ['msf'],\n    'application/vnd.epson.quickanime': ['qam'],\n    'application/vnd.epson.salt': ['slt'],\n    'application/vnd.epson.ssf': ['ssf'],\n    'application/vnd.eszigno3+xml': ['es3', 'et3'],\n    'application/vnd.ezpix-album': ['ez2'],\n    'application/vnd.ezpix-package': ['ez3'],\n    'application/vnd.fdf': ['*fdf'],\n    'application/vnd.fdsn.mseed': ['mseed'],\n    'application/vnd.fdsn.seed': ['seed', 'dataless'],\n    'application/vnd.flographit': ['gph'],\n    'application/vnd.fluxtime.clip': ['ftc'],\n    'application/vnd.framemaker': ['fm', 'frame', 'maker', 'book'],\n    'application/vnd.frogans.fnc': ['fnc'],\n    'application/vnd.frogans.ltf': ['ltf'],\n    'application/vnd.fsc.weblaunch': ['fsc'],\n    'application/vnd.fujitsu.oasys': ['oas'],\n    'application/vnd.fujitsu.oasys2': ['oa2'],\n    'application/vnd.fujitsu.oasys3': ['oa3'],\n    'application/vnd.fujitsu.oasysgp': ['fg5'],\n    'application/vnd.fujitsu.oasysprs': ['bh2'],\n    'application/vnd.fujixerox.ddd': ['ddd'],\n    'application/vnd.fujixerox.docuworks': ['xdw'],\n    'application/vnd.fujixerox.docuworks.binder': ['xbd'],\n    'application/vnd.fuzzysheet': ['fzs'],\n    'application/vnd.genomatix.tuxedo': ['txd'],\n    'application/vnd.geogebra.file': ['ggb'],\n    'application/vnd.geogebra.tool': ['ggt'],\n    'application/vnd.geometry-explorer': ['gex', 'gre'],\n    'application/vnd.geonext': ['gxt'],\n    'application/vnd.geoplan': ['g2w'],\n    'application/vnd.geospace': ['g3w'],\n    'application/vnd.gmx': ['gmx'],\n    'application/vnd.google-apps.document': ['gdoc'],\n    'application/vnd.google-apps.presentation': ['gslides'],\n    'application/vnd.google-apps.spreadsheet': ['gsheet'],\n    'application/vnd.google-earth.kml+xml': ['kml'],\n    'application/vnd.google-earth.kmz': ['kmz'],\n    'application/vnd.grafeq': ['gqf', 'gqs'],\n    'application/vnd.groove-account': ['gac'],\n    'application/vnd.groove-help': ['ghf'],\n    'application/vnd.groove-identity-message': ['gim'],\n    'application/vnd.groove-injector': ['grv'],\n    'application/vnd.groove-tool-message': ['gtm'],\n    'application/vnd.groove-tool-template': ['tpl'],\n    'application/vnd.groove-vcard': ['vcg'],\n    'application/vnd.hal+xml': ['hal'],\n    'application/vnd.handheld-entertainment+xml': ['zmm'],\n    'application/vnd.hbci': ['hbci'],\n    'application/vnd.hhe.lesson-player': ['les'],\n    'application/vnd.hp-hpgl': ['hpgl'],\n    'application/vnd.hp-hpid': ['hpid'],\n    'application/vnd.hp-hps': ['hps'],\n    'application/vnd.hp-jlyt': ['jlt'],\n    'application/vnd.hp-pcl': ['pcl'],\n    'application/vnd.hp-pclxl': ['pclxl'],\n    'application/vnd.hydrostatix.sof-data': ['sfd-hdstx'],\n    'application/vnd.ibm.minipay': ['mpy'],\n    'application/vnd.ibm.modcap': ['afp', 'listafp', 'list3820'],\n    'application/vnd.ibm.rights-management': ['irm'],\n    'application/vnd.ibm.secure-container': ['sc'],\n    'application/vnd.iccprofile': ['icc', 'icm'],\n    'application/vnd.igloader': ['igl'],\n    'application/vnd.immervision-ivp': ['ivp'],\n    'application/vnd.immervision-ivu': ['ivu'],\n    'application/vnd.insors.igm': ['igm'],\n    'application/vnd.intercon.formnet': ['xpw', 'xpx'],\n    'application/vnd.intergeo': ['i2g'],\n    'application/vnd.intu.qbo': ['qbo'],\n    'application/vnd.intu.qfx': ['qfx'],\n    'application/vnd.ipunplugged.rcprofile': ['rcprofile'],\n    'application/vnd.irepository.package+xml': ['irp'],\n    'application/vnd.is-xpr': ['xpr'],\n    'application/vnd.isac.fcs': ['fcs'],\n    'application/vnd.jam': ['jam'],\n    'application/vnd.jcp.javame.midlet-rms': ['rms'],\n    'application/vnd.jisp': ['jisp'],\n    'application/vnd.joost.joda-archive': ['joda'],\n    'application/vnd.kahootz': ['ktz', 'ktr'],\n    'application/vnd.kde.karbon': ['karbon'],\n    'application/vnd.kde.kchart': ['chrt'],\n    'application/vnd.kde.kformula': ['kfo'],\n    'application/vnd.kde.kivio': ['flw'],\n    'application/vnd.kde.kontour': ['kon'],\n    'application/vnd.kde.kpresenter': ['kpr', 'kpt'],\n    'application/vnd.kde.kspread': ['ksp'],\n    'application/vnd.kde.kword': ['kwd', 'kwt'],\n    'application/vnd.kenameaapp': ['htke'],\n    'application/vnd.kidspiration': ['kia'],\n    'application/vnd.kinar': ['kne', 'knp'],\n    'application/vnd.koan': ['skp', 'skd', 'skt', 'skm'],\n    'application/vnd.kodak-descriptor': ['sse'],\n    'application/vnd.las.las+xml': ['lasxml'],\n    'application/vnd.llamagraphics.life-balance.desktop': ['lbd'],\n    'application/vnd.llamagraphics.life-balance.exchange+xml': ['lbe'],\n    'application/vnd.lotus-1-2-3': ['123'],\n    'application/vnd.lotus-approach': ['apr'],\n    'application/vnd.lotus-freelance': ['pre'],\n    'application/vnd.lotus-notes': ['nsf'],\n    'application/vnd.lotus-organizer': ['org'],\n    'application/vnd.lotus-screencam': ['scm'],\n    'application/vnd.lotus-wordpro': ['lwp'],\n    'application/vnd.macports.portpkg': ['portpkg'],\n    'application/vnd.mapbox-vector-tile': ['mvt'],\n    'application/vnd.mcd': ['mcd'],\n    'application/vnd.medcalcdata': ['mc1'],\n    'application/vnd.mediastation.cdkey': ['cdkey'],\n    'application/vnd.mfer': ['mwf'],\n    'application/vnd.mfmp': ['mfm'],\n    'application/vnd.micrografx.flo': ['flo'],\n    'application/vnd.micrografx.igx': ['igx'],\n    'application/vnd.mif': ['mif'],\n    'application/vnd.mobius.daf': ['daf'],\n    'application/vnd.mobius.dis': ['dis'],\n    'application/vnd.mobius.mbk': ['mbk'],\n    'application/vnd.mobius.mqy': ['mqy'],\n    'application/vnd.mobius.msl': ['msl'],\n    'application/vnd.mobius.plc': ['plc'],\n    'application/vnd.mobius.txf': ['txf'],\n    'application/vnd.mophun.application': ['mpn'],\n    'application/vnd.mophun.certificate': ['mpc'],\n    'application/vnd.mozilla.xul+xml': ['xul'],\n    'application/vnd.ms-artgalry': ['cil'],\n    'application/vnd.ms-cab-compressed': ['cab'],\n    'application/vnd.ms-excel': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],\n    'application/vnd.ms-excel.addin.macroenabled.12': ['xlam'],\n    'application/vnd.ms-excel.sheet.binary.macroenabled.12': ['xlsb'],\n    'application/vnd.ms-excel.sheet.macroenabled.12': ['xlsm'],\n    'application/vnd.ms-excel.template.macroenabled.12': ['xltm'],\n    'application/vnd.ms-fontobject': ['eot'],\n    'application/vnd.ms-htmlhelp': ['chm'],\n    'application/vnd.ms-ims': ['ims'],\n    'application/vnd.ms-lrm': ['lrm'],\n    'application/vnd.ms-officetheme': ['thmx'],\n    'application/vnd.ms-outlook': ['msg'],\n    'application/vnd.ms-pki.seccat': ['cat'],\n    'application/vnd.ms-pki.stl': ['*stl'],\n    'application/vnd.ms-powerpoint': ['ppt', 'pps', 'pot'],\n    'application/vnd.ms-powerpoint.addin.macroenabled.12': ['ppam'],\n    'application/vnd.ms-powerpoint.presentation.macroenabled.12': ['pptm'],\n    'application/vnd.ms-powerpoint.slide.macroenabled.12': ['sldm'],\n    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': ['ppsm'],\n    'application/vnd.ms-powerpoint.template.macroenabled.12': ['potm'],\n    'application/vnd.ms-project': ['*mpp', 'mpt'],\n    'application/vnd.ms-word.document.macroenabled.12': ['docm'],\n    'application/vnd.ms-word.template.macroenabled.12': ['dotm'],\n    'application/vnd.ms-works': ['wps', 'wks', 'wcm', 'wdb'],\n    'application/vnd.ms-wpl': ['wpl'],\n    'application/vnd.ms-xpsdocument': ['xps'],\n    'application/vnd.mseq': ['mseq'],\n    'application/vnd.musician': ['mus'],\n    'application/vnd.muvee.style': ['msty'],\n    'application/vnd.mynfc': ['taglet'],\n    'application/vnd.neurolanguage.nlu': ['nlu'],\n    'application/vnd.nitf': ['ntf', 'nitf'],\n    'application/vnd.noblenet-directory': ['nnd'],\n    'application/vnd.noblenet-sealer': ['nns'],\n    'application/vnd.noblenet-web': ['nnw'],\n    'application/vnd.nokia.n-gage.ac+xml': ['*ac'],\n    'application/vnd.nokia.n-gage.data': ['ngdat'],\n    'application/vnd.nokia.n-gage.symbian.install': ['n-gage'],\n    'application/vnd.nokia.radio-preset': ['rpst'],\n    'application/vnd.nokia.radio-presets': ['rpss'],\n    'application/vnd.novadigm.edm': ['edm'],\n    'application/vnd.novadigm.edx': ['edx'],\n    'application/vnd.novadigm.ext': ['ext'],\n    'application/vnd.oasis.opendocument.chart': ['odc'],\n    'application/vnd.oasis.opendocument.chart-template': ['otc'],\n    'application/vnd.oasis.opendocument.database': ['odb'],\n    'application/vnd.oasis.opendocument.formula': ['odf'],\n    'application/vnd.oasis.opendocument.formula-template': ['odft'],\n    'application/vnd.oasis.opendocument.graphics': ['odg'],\n    'application/vnd.oasis.opendocument.graphics-template': ['otg'],\n    'application/vnd.oasis.opendocument.image': ['odi'],\n    'application/vnd.oasis.opendocument.image-template': ['oti'],\n    'application/vnd.oasis.opendocument.presentation': ['odp'],\n    'application/vnd.oasis.opendocument.presentation-template': ['otp'],\n    'application/vnd.oasis.opendocument.spreadsheet': ['ods'],\n    'application/vnd.oasis.opendocument.spreadsheet-template': ['ots'],\n    'application/vnd.oasis.opendocument.text': ['odt'],\n    'application/vnd.oasis.opendocument.text-master': ['odm'],\n    'application/vnd.oasis.opendocument.text-template': ['ott'],\n    'application/vnd.oasis.opendocument.text-web': ['oth'],\n    'application/vnd.olpc-sugar': ['xo'],\n    'application/vnd.oma.dd2+xml': ['dd2'],\n    'application/vnd.openblox.game+xml': ['obgx'],\n    'application/vnd.openofficeorg.extension': ['oxt'],\n    'application/vnd.openstreetmap.data+xml': ['osm'],\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation':\n        ['pptx'],\n    'application/vnd.openxmlformats-officedocument.presentationml.slide': [\n        'sldx',\n    ],\n    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': [\n        'ppsx',\n    ],\n    'application/vnd.openxmlformats-officedocument.presentationml.template': [\n        'potx',\n    ],\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': [\n        'xlsx',\n    ],\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': [\n        'xltx',\n    ],\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': [\n        'docx',\n    ],\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': [\n        'dotx',\n    ],\n    'application/vnd.osgeo.mapguide.package': ['mgp'],\n    'application/vnd.osgi.dp': ['dp'],\n    'application/vnd.osgi.subsystem': ['esa'],\n    'application/vnd.palm': ['pdb', 'pqa', 'oprc'],\n    'application/vnd.pawaafile': ['paw'],\n    'application/vnd.pg.format': ['str'],\n    'application/vnd.pg.osasli': ['ei6'],\n    'application/vnd.picsel': ['efif'],\n    'application/vnd.pmi.widget': ['wg'],\n    'application/vnd.pocketlearn': ['plf'],\n    'application/vnd.powerbuilder6': ['pbd'],\n    'application/vnd.previewsystems.box': ['box'],\n    'application/vnd.proteus.magazine': ['mgz'],\n    'application/vnd.publishare-delta-tree': ['qps'],\n    'application/vnd.pvi.ptid1': ['ptid'],\n    'application/vnd.pwg-xhtml-print+xml': ['xhtm'],\n    'application/vnd.quark.quarkxpress': [\n        'qxd',\n        'qxt',\n        'qwd',\n        'qwt',\n        'qxl',\n        'qxb',\n    ],\n    'application/vnd.rar': ['rar'],\n    'application/vnd.realvnc.bed': ['bed'],\n    'application/vnd.recordare.musicxml': ['mxl'],\n    'application/vnd.recordare.musicxml+xml': ['musicxml'],\n    'application/vnd.rig.cryptonote': ['cryptonote'],\n    'application/vnd.rim.cod': ['cod'],\n    'application/vnd.rn-realmedia': ['rm'],\n    'application/vnd.rn-realmedia-vbr': ['rmvb'],\n    'application/vnd.route66.link66+xml': ['link66'],\n    'application/vnd.sailingtracker.track': ['st'],\n    'application/vnd.seemail': ['see'],\n    'application/vnd.sema': ['sema'],\n    'application/vnd.semd': ['semd'],\n    'application/vnd.semf': ['semf'],\n    'application/vnd.shana.informed.formdata': ['ifm'],\n    'application/vnd.shana.informed.formtemplate': ['itp'],\n    'application/vnd.shana.informed.interchange': ['iif'],\n    'application/vnd.shana.informed.package': ['ipk'],\n    'application/vnd.simtech-mindmapper': ['twd', 'twds'],\n    'application/vnd.smaf': ['mmf'],\n    'application/vnd.smart.teacher': ['teacher'],\n    'application/vnd.software602.filler.form+xml': ['fo'],\n    'application/vnd.solent.sdkm+xml': ['sdkm', 'sdkd'],\n    'application/vnd.spotfire.dxp': ['dxp'],\n    'application/vnd.spotfire.sfs': ['sfs'],\n    'application/vnd.stardivision.calc': ['sdc'],\n    'application/vnd.stardivision.draw': ['sda'],\n    'application/vnd.stardivision.impress': ['sdd'],\n    'application/vnd.stardivision.math': ['smf'],\n    'application/vnd.stardivision.writer': ['sdw', 'vor'],\n    'application/vnd.stardivision.writer-global': ['sgl'],\n    'application/vnd.stepmania.package': ['smzip'],\n    'application/vnd.stepmania.stepchart': ['sm'],\n    'application/vnd.sun.wadl+xml': ['wadl'],\n    'application/vnd.sun.xml.calc': ['sxc'],\n    'application/vnd.sun.xml.calc.template': ['stc'],\n    'application/vnd.sun.xml.draw': ['sxd'],\n    'application/vnd.sun.xml.draw.template': ['std'],\n    'application/vnd.sun.xml.impress': ['sxi'],\n    'application/vnd.sun.xml.impress.template': ['sti'],\n    'application/vnd.sun.xml.math': ['sxm'],\n    'application/vnd.sun.xml.writer': ['sxw'],\n    'application/vnd.sun.xml.writer.global': ['sxg'],\n    'application/vnd.sun.xml.writer.template': ['stw'],\n    'application/vnd.sus-calendar': ['sus', 'susp'],\n    'application/vnd.svd': ['svd'],\n    'application/vnd.symbian.install': ['sis', 'sisx'],\n    'application/vnd.syncml+xml': ['xsm'],\n    'application/vnd.syncml.dm+wbxml': ['bdm'],\n    'application/vnd.syncml.dm+xml': ['xdm'],\n    'application/vnd.syncml.dmddf+xml': ['ddf'],\n    'application/vnd.tao.intent-module-archive': ['tao'],\n    'application/vnd.tcpdump.pcap': ['pcap', 'cap', 'dmp'],\n    'application/vnd.tmobile-livetv': ['tmo'],\n    'application/vnd.trid.tpt': ['tpt'],\n    'application/vnd.triscape.mxs': ['mxs'],\n    'application/vnd.trueapp': ['tra'],\n    'application/vnd.ufdl': ['ufd', 'ufdl'],\n    'application/vnd.uiq.theme': ['utz'],\n    'application/vnd.umajin': ['umj'],\n    'application/vnd.unity': ['unityweb'],\n    'application/vnd.uoml+xml': ['uoml', 'uo'],\n    'application/vnd.vcx': ['vcx'],\n    'application/vnd.visio': ['vsd', 'vst', 'vss', 'vsw'],\n    'application/vnd.visionary': ['vis'],\n    'application/vnd.vsf': ['vsf'],\n    'application/vnd.wap.wbxml': ['wbxml'],\n    'application/vnd.wap.wmlc': ['wmlc'],\n    'application/vnd.wap.wmlscriptc': ['wmlsc'],\n    'application/vnd.webturbo': ['wtb'],\n    'application/vnd.wolfram.player': ['nbp'],\n    'application/vnd.wordperfect': ['wpd'],\n    'application/vnd.wqd': ['wqd'],\n    'application/vnd.wt.stf': ['stf'],\n    'application/vnd.xara': ['xar'],\n    'application/vnd.xfdl': ['xfdl'],\n    'application/vnd.yamaha.hv-dic': ['hvd'],\n    'application/vnd.yamaha.hv-script': ['hvs'],\n    'application/vnd.yamaha.hv-voice': ['hvp'],\n    'application/vnd.yamaha.openscoreformat': ['osf'],\n    'application/vnd.yamaha.openscoreformat.osfpvg+xml': ['osfpvg'],\n    'application/vnd.yamaha.smaf-audio': ['saf'],\n    'application/vnd.yamaha.smaf-phrase': ['spf'],\n    'application/vnd.yellowriver-custom-menu': ['cmp'],\n    'application/vnd.zul': ['zir', 'zirz'],\n    'application/vnd.zzazz.deck+xml': ['zaz'],\n    'application/x-7z-compressed': ['7z'],\n    'application/x-abiword': ['abw'],\n    'application/x-ace-compressed': ['ace'],\n    'application/x-apple-diskimage': ['*dmg'],\n    'application/x-arj': ['arj'],\n    'application/x-authorware-bin': ['aab', 'x32', 'u32', 'vox'],\n    'application/x-authorware-map': ['aam'],\n    'application/x-authorware-seg': ['aas'],\n    'application/x-bcpio': ['bcpio'],\n    'application/x-bdoc': ['*bdoc'],\n    'application/x-bittorrent': ['torrent'],\n    'application/x-blorb': ['blb', 'blorb'],\n    'application/x-bzip': ['bz'],\n    'application/x-bzip2': ['bz2', 'boz'],\n    'application/x-cbr': ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],\n    'application/x-cdlink': ['vcd'],\n    'application/x-cfs-compressed': ['cfs'],\n    'application/x-chat': ['chat'],\n    'application/x-chess-pgn': ['pgn'],\n    'application/x-chrome-extension': ['crx'],\n    'application/x-cocoa': ['cco'],\n    'application/x-conference': ['nsc'],\n    'application/x-cpio': ['cpio'],\n    'application/x-csh': ['csh'],\n    'application/x-debian-package': ['*deb', 'udeb'],\n    'application/x-dgc-compressed': ['dgc'],\n    'application/x-director': [\n        'dir',\n        'dcr',\n        'dxr',\n        'cst',\n        'cct',\n        'cxt',\n        'w3d',\n        'fgd',\n        'swa',\n    ],\n    'application/x-doom': ['wad'],\n    'application/x-dtbncx+xml': ['ncx'],\n    'application/x-dtbook+xml': ['dtb'],\n    'application/x-dtbresource+xml': ['res'],\n    'application/x-dvi': ['dvi'],\n    'application/x-envoy': ['evy'],\n    'application/x-eva': ['eva'],\n    'application/x-font-bdf': ['bdf'],\n    'application/x-font-ghostscript': ['gsf'],\n    'application/x-font-linux-psf': ['psf'],\n    'application/x-font-pcf': ['pcf'],\n    'application/x-font-snf': ['snf'],\n    'application/x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],\n    'application/x-freearc': ['arc'],\n    'application/x-futuresplash': ['spl'],\n    'application/x-gca-compressed': ['gca'],\n    'application/x-glulx': ['ulx'],\n    'application/x-gnumeric': ['gnumeric'],\n    'application/x-gramps-xml': ['gramps'],\n    'application/x-gtar': ['gtar'],\n    'application/x-hdf': ['hdf'],\n    'application/x-httpd-php': ['php'],\n    'application/x-install-instructions': ['install'],\n    'application/x-iso9660-image': ['*iso'],\n    'application/x-iwork-keynote-sffkey': ['*key'],\n    'application/x-iwork-numbers-sffnumbers': ['*numbers'],\n    'application/x-iwork-pages-sffpages': ['*pages'],\n    'application/x-java-archive-diff': ['jardiff'],\n    'application/x-java-jnlp-file': ['jnlp'],\n    'application/x-keepass2': ['kdbx'],\n    'application/x-latex': ['latex'],\n    'application/x-lua-bytecode': ['luac'],\n    'application/x-lzh-compressed': ['lzh', 'lha'],\n    'application/x-makeself': ['run'],\n    'application/x-mie': ['mie'],\n    'application/x-mobipocket-ebook': ['*prc', 'mobi'],\n    'application/x-ms-application': ['application'],\n    'application/x-ms-shortcut': ['lnk'],\n    'application/x-ms-wmd': ['wmd'],\n    'application/x-ms-wmz': ['wmz'],\n    'application/x-ms-xbap': ['xbap'],\n    'application/x-msaccess': ['mdb'],\n    'application/x-msbinder': ['obd'],\n    'application/x-mscardfile': ['crd'],\n    'application/x-msclip': ['clp'],\n    'application/x-msdos-program': ['*exe'],\n    'application/x-msdownload': ['*exe', '*dll', 'com', 'bat', '*msi'],\n    'application/x-msmediaview': ['mvb', 'm13', 'm14'],\n    'application/x-msmetafile': ['*wmf', '*wmz', '*emf', 'emz'],\n    'application/x-msmoney': ['mny'],\n    'application/x-mspublisher': ['pub'],\n    'application/x-msschedule': ['scd'],\n    'application/x-msterminal': ['trm'],\n    'application/x-mswrite': ['wri'],\n    'application/x-netcdf': ['nc', 'cdf'],\n    'application/x-ns-proxy-autoconfig': ['pac'],\n    'application/x-nzb': ['nzb'],\n    'application/x-perl': ['pl', 'pm'],\n    'application/x-pilot': ['*prc', '*pdb'],\n    'application/x-pkcs12': ['p12', 'pfx'],\n    'application/x-pkcs7-certificates': ['p7b', 'spc'],\n    'application/x-pkcs7-certreqresp': ['p7r'],\n    'application/x-rar-compressed': ['*rar'],\n    'application/x-redhat-package-manager': ['rpm'],\n    'application/x-research-info-systems': ['ris'],\n    'application/x-sea': ['sea'],\n    'application/x-sh': ['sh'],\n    'application/x-shar': ['shar'],\n    'application/x-shockwave-flash': ['swf'],\n    'application/x-silverlight-app': ['xap'],\n    'application/x-sql': ['*sql'],\n    'application/x-stuffit': ['sit'],\n    'application/x-stuffitx': ['sitx'],\n    'application/x-subrip': ['srt'],\n    'application/x-sv4cpio': ['sv4cpio'],\n    'application/x-sv4crc': ['sv4crc'],\n    'application/x-t3vm-image': ['t3'],\n    'application/x-tads': ['gam'],\n    'application/x-tar': ['tar'],\n    'application/x-tcl': ['tcl', 'tk'],\n    'application/x-tex': ['tex'],\n    'application/x-tex-tfm': ['tfm'],\n    'application/x-texinfo': ['texinfo', 'texi'],\n    'application/x-tgif': ['*obj'],\n    'application/x-ustar': ['ustar'],\n    'application/x-virtualbox-hdd': ['hdd'],\n    'application/x-virtualbox-ova': ['ova'],\n    'application/x-virtualbox-ovf': ['ovf'],\n    'application/x-virtualbox-vbox': ['vbox'],\n    'application/x-virtualbox-vbox-extpack': ['vbox-extpack'],\n    'application/x-virtualbox-vdi': ['vdi'],\n    'application/x-virtualbox-vhd': ['vhd'],\n    'application/x-virtualbox-vmdk': ['vmdk'],\n    'application/x-wais-source': ['src'],\n    'application/x-web-app-manifest+json': ['webapp'],\n    'application/x-x509-ca-cert': ['der', 'crt', 'pem'],\n    'application/x-xfig': ['fig'],\n    'application/x-xliff+xml': ['*xlf'],\n    'application/x-xpinstall': ['xpi'],\n    'application/x-xz': ['xz'],\n    'application/x-zmachine': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],\n    'audio/vnd.dece.audio': ['uva', 'uvva'],\n    'audio/vnd.digital-winds': ['eol'],\n    'audio/vnd.dra': ['dra'],\n    'audio/vnd.dts': ['dts'],\n    'audio/vnd.dts.hd': ['dtshd'],\n    'audio/vnd.lucent.voice': ['lvp'],\n    'audio/vnd.ms-playready.media.pya': ['pya'],\n    'audio/vnd.nuera.ecelp4800': ['ecelp4800'],\n    'audio/vnd.nuera.ecelp7470': ['ecelp7470'],\n    'audio/vnd.nuera.ecelp9600': ['ecelp9600'],\n    'audio/vnd.rip': ['rip'],\n    'audio/x-aac': ['*aac'],\n    'audio/x-aiff': ['aif', 'aiff', 'aifc'],\n    'audio/x-caf': ['caf'],\n    'audio/x-flac': ['flac'],\n    'audio/x-m4a': ['*m4a'],\n    'audio/x-matroska': ['mka'],\n    'audio/x-mpegurl': ['m3u'],\n    'audio/x-ms-wax': ['wax'],\n    'audio/x-ms-wma': ['wma'],\n    'audio/x-pn-realaudio': ['ram', 'ra'],\n    'audio/x-pn-realaudio-plugin': ['rmp'],\n    'audio/x-realaudio': ['*ra'],\n    'audio/x-wav': ['*wav'],\n    'chemical/x-cdx': ['cdx'],\n    'chemical/x-cif': ['cif'],\n    'chemical/x-cmdf': ['cmdf'],\n    'chemical/x-cml': ['cml'],\n    'chemical/x-csml': ['csml'],\n    'chemical/x-xyz': ['xyz'],\n    'image/prs.btif': ['btif', 'btf'],\n    'image/prs.pti': ['pti'],\n    'image/vnd.adobe.photoshop': ['psd'],\n    'image/vnd.airzip.accelerator.azv': ['azv'],\n    'image/vnd.dece.graphic': ['uvi', 'uvvi', 'uvg', 'uvvg'],\n    'image/vnd.djvu': ['djvu', 'djv'],\n    'image/vnd.dvb.subtitle': ['*sub'],\n    'image/vnd.dwg': ['dwg'],\n    'image/vnd.dxf': ['dxf'],\n    'image/vnd.fastbidsheet': ['fbs'],\n    'image/vnd.fpx': ['fpx'],\n    'image/vnd.fst': ['fst'],\n    'image/vnd.fujixerox.edmics-mmr': ['mmr'],\n    'image/vnd.fujixerox.edmics-rlc': ['rlc'],\n    'image/vnd.microsoft.icon': ['ico'],\n    'image/vnd.ms-dds': ['dds'],\n    'image/vnd.ms-modi': ['mdi'],\n    'image/vnd.ms-photo': ['wdp'],\n    'image/vnd.net-fpx': ['npx'],\n    'image/vnd.pco.b16': ['b16'],\n    'image/vnd.tencent.tap': ['tap'],\n    'image/vnd.valve.source.texture': ['vtf'],\n    'image/vnd.wap.wbmp': ['wbmp'],\n    'image/vnd.xiff': ['xif'],\n    'image/vnd.zbrush.pcx': ['pcx'],\n    'image/x-3ds': ['3ds'],\n    'image/x-cmu-raster': ['ras'],\n    'image/x-cmx': ['cmx'],\n    'image/x-freehand': ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],\n    'image/x-icon': ['*ico'],\n    'image/x-jng': ['jng'],\n    'image/x-mrsid-image': ['sid'],\n    'image/x-ms-bmp': ['*bmp'],\n    'image/x-pcx': ['*pcx'],\n    'image/x-pict': ['pic', 'pct'],\n    'image/x-portable-anymap': ['pnm'],\n    'image/x-portable-bitmap': ['pbm'],\n    'image/x-portable-graymap': ['pgm'],\n    'image/x-portable-pixmap': ['ppm'],\n    'image/x-rgb': ['rgb'],\n    'image/x-tga': ['tga'],\n    'image/x-xbitmap': ['xbm'],\n    'image/x-xpixmap': ['xpm'],\n    'image/x-xwindowdump': ['xwd'],\n    'message/vnd.wfa.wsc': ['wsc'],\n    'model/vnd.cld': ['cld'],\n    'model/vnd.collada+xml': ['dae'],\n    'model/vnd.dwf': ['dwf'],\n    'model/vnd.gdl': ['gdl'],\n    'model/vnd.gtw': ['gtw'],\n    'model/vnd.mts': ['mts'],\n    'model/vnd.opengex': ['ogex'],\n    'model/vnd.parasolid.transmit.binary': ['x_b'],\n    'model/vnd.parasolid.transmit.text': ['x_t'],\n    'model/vnd.pytha.pyox': ['pyo', 'pyox'],\n    'model/vnd.sap.vds': ['vds'],\n    'model/vnd.usda': ['usda'],\n    'model/vnd.usdz+zip': ['usdz'],\n    'model/vnd.valve.source.compiled-map': ['bsp'],\n    'model/vnd.vtu': ['vtu'],\n    'text/prs.lines.tag': ['dsc'],\n    'text/vnd.curl': ['curl'],\n    'text/vnd.curl.dcurl': ['dcurl'],\n    'text/vnd.curl.mcurl': ['mcurl'],\n    'text/vnd.curl.scurl': ['scurl'],\n    'text/vnd.dvb.subtitle': ['sub'],\n    'text/vnd.familysearch.gedcom': ['ged'],\n    'text/vnd.fly': ['fly'],\n    'text/vnd.fmi.flexstor': ['flx'],\n    'text/vnd.graphviz': ['gv'],\n    'text/vnd.in3d.3dml': ['3dml'],\n    'text/vnd.in3d.spot': ['spot'],\n    'text/vnd.sun.j2me.app-descriptor': ['jad'],\n    'text/vnd.wap.wml': ['wml'],\n    'text/vnd.wap.wmlscript': ['wmls'],\n    'text/x-asm': ['s', 'asm'],\n    'text/x-c': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],\n    'text/x-component': ['htc'],\n    'text/x-fortran': ['f', 'for', 'f77', 'f90'],\n    'text/x-handlebars-template': ['hbs'],\n    'text/x-java-source': ['java'],\n    'text/x-lua': ['lua'],\n    'text/x-markdown': ['mkd'],\n    'text/x-nfo': ['nfo'],\n    'text/x-opml': ['opml'],\n    'text/x-org': ['*org'],\n    'text/x-pascal': ['p', 'pas'],\n    'text/x-processing': ['pde'],\n    'text/x-sass': ['sass'],\n    'text/x-scss': ['scss'],\n    'text/x-setext': ['etx'],\n    'text/x-sfv': ['sfv'],\n    'text/x-suse-ymp': ['ymp'],\n    'text/x-uuencode': ['uu'],\n    'text/x-vcalendar': ['vcs'],\n    'text/x-vcard': ['vcf'],\n    'video/vnd.dece.hd': ['uvh', 'uvvh'],\n    'video/vnd.dece.mobile': ['uvm', 'uvvm'],\n    'video/vnd.dece.pd': ['uvp', 'uvvp'],\n    'video/vnd.dece.sd': ['uvs', 'uvvs'],\n    'video/vnd.dece.video': ['uvv', 'uvvv'],\n    'video/vnd.dvb.file': ['dvb'],\n    'video/vnd.fvt': ['fvt'],\n    'video/vnd.mpegurl': ['mxu', 'm4u'],\n    'video/vnd.ms-playready.media.pyv': ['pyv'],\n    'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],\n    'video/vnd.vivo': ['viv'],\n    'video/x-f4v': ['f4v'],\n    'video/x-fli': ['fli'],\n    'video/x-flv': ['flv'],\n    'video/x-m4v': ['m4v'],\n    'video/x-matroska': ['mkv', 'mk3d', 'mks'],\n    'video/x-mng': ['mng'],\n    'video/x-ms-asf': ['asf', 'asx'],\n    'video/x-ms-vob': ['vob'],\n    'video/x-ms-wm': ['wm'],\n    'video/x-ms-wmv': ['wmv'],\n    'video/x-ms-wmx': ['wmx'],\n    'video/x-ms-wvx': ['wvx'],\n    'video/x-msvideo': ['avi'],\n    'video/x-sgi-movie': ['movie'],\n    'video/x-smv': ['smv'],\n    'x-conference/x-cooltalk': ['ice'],\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/types/standard.ts",
    "type": "Constant",
    "value": "types",
    "snippet": "const types: { [key: string]: string[] } = {\n    'application/andrew-inset': ['ez'],\n    'application/appinstaller': ['appinstaller'],\n    'application/applixware': ['aw'],\n    'application/appx': ['appx'],\n    'application/appxbundle': ['appxbundle'],\n    'application/atom+xml': ['atom'],\n    'application/atomcat+xml': ['atomcat'],\n    'application/atomdeleted+xml': ['atomdeleted'],\n    'application/atomsvc+xml': ['atomsvc'],\n    'application/atsc-dwd+xml': ['dwd'],\n    'application/atsc-held+xml': ['held'],\n    'application/atsc-rsat+xml': ['rsat'],\n    'application/automationml-aml+xml': ['aml'],\n    'application/automationml-amlx+zip': ['amlx'],\n    'application/bdoc': ['bdoc'],\n    'application/calendar+xml': ['xcs'],\n    'application/ccxml+xml': ['ccxml'],\n    'application/cdfx+xml': ['cdfx'],\n    'application/cdmi-capability': ['cdmia'],\n    'application/cdmi-container': ['cdmic'],\n    'application/cdmi-domain': ['cdmid'],\n    'application/cdmi-object': ['cdmio'],\n    'application/cdmi-queue': ['cdmiq'],\n    'application/cpl+xml': ['cpl'],\n    'application/cu-seeme': ['cu'],\n    'application/cwl': ['cwl'],\n    'application/dash+xml': ['mpd'],\n    'application/dash-patch+xml': ['mpp'],\n    'application/davmount+xml': ['davmount'],\n    'application/docbook+xml': ['dbk'],\n    'application/dssc+der': ['dssc'],\n    'application/dssc+xml': ['xdssc'],\n    'application/ecmascript': ['ecma'],\n    'application/emma+xml': ['emma'],\n    'application/emotionml+xml': ['emotionml'],\n    'application/epub+zip': ['epub'],\n    'application/exi': ['exi'],\n    'application/express': ['exp'],\n    'application/fdf': ['fdf'],\n    'application/fdt+xml': ['fdt'],\n    'application/font-tdpfr': ['pfr'],\n    'application/geo+json': ['geojson'],\n    'application/gml+xml': ['gml'],\n    'application/gpx+xml': ['gpx'],\n    'application/gxf': ['gxf'],\n    'application/gzip': ['gz'],\n    'application/hjson': ['hjson'],\n    'application/hyperstudio': ['stk'],\n    'application/inkml+xml': ['ink', 'inkml'],\n    'application/ipfix': ['ipfix'],\n    'application/its+xml': ['its'],\n    'application/java-archive': ['jar', 'war', 'ear'],\n    'application/java-serialized-object': ['ser'],\n    'application/java-vm': ['class'],\n    'application/javascript': ['*js'],\n    'application/json': ['json', 'map'],\n    'application/json5': ['json5'],\n    'application/jsonml+json': ['jsonml'],\n    'application/ld+json': ['jsonld'],\n    'application/lgr+xml': ['lgr'],\n    'application/lost+xml': ['lostxml'],\n    'application/mac-binhex40': ['hqx'],\n    'application/mac-compactpro': ['cpt'],\n    'application/mads+xml': ['mads'],\n    'application/manifest+json': ['webmanifest'],\n    'application/marc': ['mrc'],\n    'application/marcxml+xml': ['mrcx'],\n    'application/mathematica': ['ma', 'nb', 'mb'],\n    'application/mathml+xml': ['mathml'],\n    'application/mbox': ['mbox'],\n    'application/media-policy-dataset+xml': ['mpf'],\n    'application/mediaservercontrol+xml': ['mscml'],\n    'application/metalink+xml': ['metalink'],\n    'application/metalink4+xml': ['meta4'],\n    'application/mets+xml': ['mets'],\n    'application/mmt-aei+xml': ['maei'],\n    'application/mmt-usd+xml': ['musd'],\n    'application/mods+xml': ['mods'],\n    'application/mp21': ['m21', 'mp21'],\n    'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],\n    'application/msix': ['msix'],\n    'application/msixbundle': ['msixbundle'],\n    'application/msword': ['doc', 'dot'],\n    'application/mxf': ['mxf'],\n    'application/n-quads': ['nq'],\n    'application/n-triples': ['nt'],\n    'application/node': ['cjs'],\n    'application/octet-stream': [\n        'bin',\n        'dms',\n        'lrf',\n        'mar',\n        'so',\n        'dist',\n        'distz',\n        'pkg',\n        'bpk',\n        'dump',\n        'elc',\n        'deploy',\n        'exe',\n        'dll',\n        'deb',\n        'dmg',\n        'iso',\n        'img',\n        'msi',\n        'msp',\n        'msm',\n        'buffer',\n    ],\n    'application/oda': ['oda'],\n    'application/oebps-package+xml': ['opf'],\n    'application/ogg': ['ogx'],\n    'application/omdoc+xml': ['omdoc'],\n    'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],\n    'application/oxps': ['oxps'],\n    'application/p2p-overlay+xml': ['relo'],\n    'application/patch-ops-error+xml': ['xer'],\n    'application/pdf': ['pdf'],\n    'application/pgp-encrypted': ['pgp'],\n    'application/pgp-keys': ['asc'],\n    'application/pgp-signature': ['sig', '*asc'],\n    'application/pics-rules': ['prf'],\n    'application/pkcs10': ['p10'],\n    'application/pkcs7-mime': ['p7m', 'p7c'],\n    'application/pkcs7-signature': ['p7s'],\n    'application/pkcs8': ['p8'],\n    'application/pkix-attr-cert': ['ac'],\n    'application/pkix-cert': ['cer'],\n    'application/pkix-crl': ['crl'],\n    'application/pkix-pkipath': ['pkipath'],\n    'application/pkixcmp': ['pki'],\n    'application/pls+xml': ['pls'],\n    'application/postscript': ['ai', 'eps', 'ps'],\n    'application/provenance+xml': ['provx'],\n    'application/pskc+xml': ['pskcxml'],\n    'application/raml+yaml': ['raml'],\n    'application/rdf+xml': ['rdf', 'owl'],\n    'application/reginfo+xml': ['rif'],\n    'application/relax-ng-compact-syntax': ['rnc'],\n    'application/resource-lists+xml': ['rl'],\n    'application/resource-lists-diff+xml': ['rld'],\n    'application/rls-services+xml': ['rs'],\n    'application/route-apd+xml': ['rapd'],\n    'application/route-s-tsid+xml': ['sls'],\n    'application/route-usd+xml': ['rusd'],\n    'application/rpki-ghostbusters': ['gbr'],\n    'application/rpki-manifest': ['mft'],\n    'application/rpki-roa': ['roa'],\n    'application/rsd+xml': ['rsd'],\n    'application/rss+xml': ['rss'],\n    'application/rtf': ['rtf'],\n    'application/sbml+xml': ['sbml'],\n    'application/scvp-cv-request': ['scq'],\n    'application/scvp-cv-response': ['scs'],\n    'application/scvp-vp-request': ['spq'],\n    'application/scvp-vp-response': ['spp'],\n    'application/sdp': ['sdp'],\n    'application/senml+xml': ['senmlx'],\n    'application/sensml+xml': ['sensmlx'],\n    'application/set-payment-initiation': ['setpay'],\n    'application/set-registration-initiation': ['setreg'],\n    'application/shf+xml': ['shf'],\n    'application/sieve': ['siv', 'sieve'],\n    'application/smil+xml': ['smi', 'smil'],\n    'application/sparql-query': ['rq'],\n    'application/sparql-results+xml': ['srx'],\n    'application/sql': ['sql'],\n    'application/srgs': ['gram'],\n    'application/srgs+xml': ['grxml'],\n    'application/sru+xml': ['sru'],\n    'application/ssdl+xml': ['ssdl'],\n    'application/ssml+xml': ['ssml'],\n    'application/swid+xml': ['swidtag'],\n    'application/tei+xml': ['tei', 'teicorpus'],\n    'application/thraud+xml': ['tfi'],\n    'application/timestamped-data': ['tsd'],\n    'application/toml': ['toml'],\n    'application/trig': ['trig'],\n    'application/ttml+xml': ['ttml'],\n    'application/ubjson': ['ubj'],\n    'application/urc-ressheet+xml': ['rsheet'],\n    'application/urc-targetdesc+xml': ['td'],\n    'application/voicexml+xml': ['vxml'],\n    'application/wasm': ['wasm'],\n    'application/watcherinfo+xml': ['wif'],\n    'application/widget': ['wgt'],\n    'application/winhlp': ['hlp'],\n    'application/wsdl+xml': ['wsdl'],\n    'application/wspolicy+xml': ['wspolicy'],\n    'application/xaml+xml': ['xaml'],\n    'application/xcap-att+xml': ['xav'],\n    'application/xcap-caps+xml': ['xca'],\n    'application/xcap-diff+xml': ['xdf'],\n    'application/xcap-el+xml': ['xel'],\n    'application/xcap-ns+xml': ['xns'],\n    'application/xenc+xml': ['xenc'],\n    'application/xfdf': ['xfdf'],\n    'application/xhtml+xml': ['xhtml', 'xht'],\n    'application/xliff+xml': ['xlf'],\n    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],\n    'application/xml-dtd': ['dtd'],\n    'application/xop+xml': ['xop'],\n    'application/xproc+xml': ['xpl'],\n    'application/xslt+xml': ['*xsl', 'xslt'],\n    'application/xspf+xml': ['xspf'],\n    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],\n    'application/yang': ['yang'],\n    'application/yin+xml': ['yin'],\n    'application/zip': ['zip'],\n    'audio/3gpp': ['*3gpp'],\n    'audio/aac': ['adts', 'aac'],\n    'audio/adpcm': ['adp'],\n    'audio/amr': ['amr'],\n    'audio/basic': ['au', 'snd'],\n    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],\n    'audio/mobile-xmf': ['mxmf'],\n    'audio/mp3': ['*mp3'],\n    'audio/mp4': ['m4a', 'mp4a'],\n    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],\n    'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],\n    'audio/s3m': ['s3m'],\n    'audio/silk': ['sil'],\n    'audio/wav': ['wav'],\n    'audio/wave': ['*wav'],\n    'audio/webm': ['weba'],\n    'audio/xm': ['xm'],\n    'font/collection': ['ttc'],\n    'font/otf': ['otf'],\n    'font/ttf': ['ttf'],\n    'font/woff': ['woff'],\n    'font/woff2': ['woff2'],\n    'image/aces': ['exr'],\n    'image/apng': ['apng'],\n    'image/avci': ['avci'],\n    'image/avcs': ['avcs'],\n    'image/avif': ['avif'],\n    'image/bmp': ['bmp', 'dib'],\n    'image/cgm': ['cgm'],\n    'image/dicom-rle': ['drle'],\n    'image/dpx': ['dpx'],\n    'image/emf': ['emf'],\n    'image/fits': ['fits'],\n    'image/g3fax': ['g3'],\n    'image/gif': ['gif'],\n    'image/heic': ['heic'],\n    'image/heic-sequence': ['heics'],\n    'image/heif': ['heif'],\n    'image/heif-sequence': ['heifs'],\n    'image/hej2k': ['hej2'],\n    'image/hsj2': ['hsj2'],\n    'image/ief': ['ief'],\n    'image/jls': ['jls'],\n    'image/jp2': ['jp2', 'jpg2'],\n    'image/jpeg': ['jpeg', 'jpg', 'jpe'],\n    'image/jph': ['jph'],\n    'image/jphc': ['jhc'],\n    'image/jpm': ['jpm', 'jpgm'],\n    'image/jpx': ['jpx', 'jpf'],\n    'image/jxr': ['jxr'],\n    'image/jxra': ['jxra'],\n    'image/jxrs': ['jxrs'],\n    'image/jxs': ['jxs'],\n    'image/jxsc': ['jxsc'],\n    'image/jxsi': ['jxsi'],\n    'image/jxss': ['jxss'],\n    'image/ktx': ['ktx'],\n    'image/ktx2': ['ktx2'],\n    'image/png': ['png'],\n    'image/sgi': ['sgi'],\n    'image/svg+xml': ['svg', 'svgz'],\n    'image/t38': ['t38'],\n    'image/tiff': ['tif', 'tiff'],\n    'image/tiff-fx': ['tfx'],\n    'image/webp': ['webp'],\n    'image/wmf': ['wmf'],\n    'message/disposition-notification': ['disposition-notification'],\n    'message/global': ['u8msg'],\n    'message/global-delivery-status': ['u8dsn'],\n    'message/global-disposition-notification': ['u8mdn'],\n    'message/global-headers': ['u8hdr'],\n    'message/rfc822': ['eml', 'mime'],\n    'model/3mf': ['3mf'],\n    'model/gltf+json': ['gltf'],\n    'model/gltf-binary': ['glb'],\n    'model/iges': ['igs', 'iges'],\n    'model/jt': ['jt'],\n    'model/mesh': ['msh', 'mesh', 'silo'],\n    'model/mtl': ['mtl'],\n    'model/obj': ['obj'],\n    'model/prc': ['prc'],\n    'model/step+xml': ['stpx'],\n    'model/step+zip': ['stpz'],\n    'model/step-xml+zip': ['stpxz'],\n    'model/stl': ['stl'],\n    'model/u3d': ['u3d'],\n    'model/vrml': ['wrl', 'vrml'],\n    'model/x3d+binary': ['*x3db', 'x3dbz'],\n    'model/x3d+fastinfoset': ['x3db'],\n    'model/x3d+vrml': ['*x3dv', 'x3dvz'],\n    'model/x3d+xml': ['x3d', 'x3dz'],\n    'model/x3d-vrml': ['x3dv'],\n    'text/cache-manifest': ['appcache', 'manifest'],\n    'text/calendar': ['ics', 'ifb'],\n    'text/coffeescript': ['coffee', 'litcoffee'],\n    'text/css': ['css'],\n    'text/csv': ['csv'],\n    'text/html': ['html', 'htm', 'shtml'],\n    'text/jade': ['jade'],\n    'text/javascript': ['js', 'mjs'],\n    'text/jsx': ['jsx'],\n    'text/less': ['less'],\n    'text/markdown': ['md', 'markdown'],\n    'text/mathml': ['mml'],\n    'text/mdx': ['mdx'],\n    'text/n3': ['n3'],\n    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],\n    'text/richtext': ['rtx'],\n    'text/rtf': ['*rtf'],\n    'text/sgml': ['sgml', 'sgm'],\n    'text/shex': ['shex'],\n    'text/slim': ['slim', 'slm'],\n    'text/spdx': ['spdx'],\n    'text/stylus': ['stylus', 'styl'],\n    'text/tab-separated-values': ['tsv'],\n    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],\n    'text/turtle': ['ttl'],\n    'text/uri-list': ['uri', 'uris', 'urls'],\n    'text/vcard': ['vcard'],\n    'text/vtt': ['vtt'],\n    'text/wgsl': ['wgsl'],\n    'text/xml': ['*xml'],\n    'text/yaml': ['yaml', 'yml'],\n    'video/3gpp': ['3gp', '3gpp'],\n    'video/3gpp2': ['3g2'],\n    'video/h261': ['h261'],\n    'video/h263': ['h263'],\n    'video/h264': ['h264'],\n    'video/iso.segment': ['m4s'],\n    'video/jpeg': ['jpgv'],\n    'video/jpm': ['*jpm', '*jpgm'],\n    'video/mj2': ['mj2', 'mjp2'],\n    'video/mp2t': ['ts'],\n    'video/mp4': ['mp4', 'mp4v', 'mpg4'],\n    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],\n    'video/ogg': ['ogv'],\n    'video/quicktime': ['qt', 'mov'],\n    'video/webm': ['webm'],\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "ENCODE_URL_ATTR_CHAR_REGEXP",
    "snippet": "const ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "HEX_ESCAPE_REGEXP",
    "snippet": "const HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "HEX_ESCAPE_REPLACE_REGEXP",
    "snippet": "const HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "NON_LATIN1_REGEXP",
    "snippet": "const NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "QESC_REGEXP",
    "snippet": "const QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "QUOTE_REGEXP",
    "snippet": "const QUOTE_REGEXP = /([\\\\\"])/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "PARAM_REGEXP",
    "snippet": "const PARAM_REGEXP =\n    /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "TEXT_REGEXP",
    "snippet": "const TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "TOKEN_REGEXP",
    "snippet": "const TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "EXT_VALUE_REGEXP",
    "snippet": "const EXT_VALUE_REGEXP =\n    /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "DISPOSITION_TYPE_REGEXP",
    "snippet": "const DISPOSITION_TYPE_REGEXP =\n    /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "contentDisposition",
    "snippet": "const contentDisposition: any = (\n    filename?: string,\n    options?: {\n        type?: string | number;\n        fallback?: boolean | string | number;\n    },\n): string => {\n    const opts: any = options || {};\n\n    // get type\n    const type = opts.type || 'attachment';\n\n    // get parameters\n    const params = createparams(filename, opts.fallback);\n\n    // format into string\n    return format(new ContentDisposition(type, params));\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "opts",
    "snippet": "const opts: any = options || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = opts.type || 'attachment';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "params",
    "snippet": "const params = createparams(filename, opts.fallback);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "createparams",
    "snippet": "function createparams(filename, fallback) {\n    if (filename === undefined) return;\n\n    const params = {};\n\n    if (typeof filename !== 'string')\n        throw new TypeError('filename must be a string');\n\n    // fallback defaults to true\n    if (fallback === undefined) fallback = true;\n\n    if (typeof fallback !== 'string' && typeof fallback !== 'boolean')\n        throw new TypeError('fallback must be a string or boolean');\n\n    if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback))\n        throw new TypeError('fallback must be ISO-8859-1 string');\n\n    // restrict to file base name\n    const name = basename(filename);\n\n    // determine if name is suitable for quoted string\n    const isQuotedString = TEXT_REGEXP.test(name);\n\n    // generate fallback name\n    const fallbackName =\n        typeof fallback !== 'string'\n            ? fallback && getlatin1(name)\n            : basename(fallback);\n    const hasFallback =\n        typeof fallbackName === 'string' && fallbackName !== name;\n\n    // set extended filename parameter\n    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name))\n        params['filename*'] = name;\n\n    // set filename parameter\n    if (isQuotedString || hasFallback) {\n        params['filename'] = hasFallback ? fallbackName : name;\n    }\n\n    return params;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "params",
    "snippet": "const params = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "name",
    "snippet": "const name = basename(filename);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "isQuotedString",
    "snippet": "const isQuotedString = TEXT_REGEXP.test(name);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "fallbackName",
    "snippet": "const fallbackName =\n        typeof fallback !== 'string'\n            ? fallback && getlatin1(name)\n            : basename(fallback);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "hasFallback",
    "snippet": "const hasFallback =\n        typeof fallbackName === 'string' && fallbackName !== name;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "format",
    "snippet": "function format(obj) {\n    const parameters = obj.parameters;\n    const type = obj.type;\n\n    if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type))\n        throw new TypeError('invalid type');\n\n    // start with normalized type\n    let string = String(type).toLowerCase();\n\n    // append parameters\n    if (parameters && typeof parameters === 'object') {\n        let param;\n        const params = Object.keys(parameters).sort();\n\n        for (let i = 0; i < params.length; i++) {\n            param = params[i];\n\n            const val =\n                param.slice(-1) === '*'\n                    ? ustring(parameters[param])\n                    : qstring(parameters[param]);\n\n            string += '; ' + param + '=' + val;\n        }\n    }\n\n    return string;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "parameters",
    "snippet": "const parameters = obj.parameters;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = obj.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "params",
    "snippet": "const params = Object.keys(parameters).sort();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "val",
    "snippet": "const val =\n                param.slice(-1) === '*'\n                    ? ustring(parameters[param])\n                    : qstring(parameters[param]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "decodefield",
    "snippet": "function decodefield(str) {\n    const match = EXT_VALUE_REGEXP.exec(str);\n\n    if (!match) throw new TypeError('invalid extended field value');\n\n    const charset = match[1].toLowerCase();\n    const encoded = match[2];\n    let value;\n\n    // to binary string\n    const binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);\n\n    switch (charset) {\n        case 'iso-8859-1':\n            value = getlatin1(binary);\n            break;\n        case 'utf-8':\n        case 'utf8':\n            value = Buffer.from(binary, 'binary').toString('utf8');\n            break;\n        default:\n            throw new TypeError('unsupported charset in extended field');\n    }\n\n    return value;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "match",
    "snippet": "const match = EXT_VALUE_REGEXP.exec(str);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "charset",
    "snippet": "const charset = match[1].toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "encoded",
    "snippet": "const encoded = match[2];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "binary",
    "snippet": "const binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "getlatin1",
    "snippet": "function getlatin1(val) {\n    // simple Unicode -> ISO-8859-1 transformation\n    return String(val).replace(NON_LATIN1_REGEXP, '?');\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "parse",
    "snippet": "function parse(string) {\n    if (!string || typeof string !== 'string')\n        throw new TypeError('argument string is required');\n\n    let match = DISPOSITION_TYPE_REGEXP.exec(string);\n\n    if (!match) throw new TypeError('invalid type format');\n\n    // normalize type\n    let index = match[0].length;\n    const type = match[1].toLowerCase();\n\n    let key;\n    const names = [];\n    const params = {};\n    let value;\n\n    // calculate index to start at\n    index = PARAM_REGEXP.lastIndex =\n        match[0].slice(-1) === ';' ? index - 1 : index;\n\n    // match parameters\n    while ((match = PARAM_REGEXP.exec(string))) {\n        if (match.index !== index)\n            throw new TypeError('invalid parameter format');\n\n        index += match[0].length;\n        key = match[1].toLowerCase();\n        value = match[2];\n\n        if (names.indexOf(key) !== -1)\n            throw new TypeError('invalid duplicate parameter');\n\n        names.push(key);\n\n        if (key.indexOf('*') + 1 === key.length) {\n            // decode extended value\n            key = key.slice(0, -1);\n            value = decodefield(value);\n\n            // overwrite existing value\n            params[key] = value;\n            continue;\n        }\n\n        if (typeof params[key] === 'string') continue;\n\n        if (value[0] === '\"') {\n            // remove quotes and escapes\n            value = value.slice(1, -1).replace(QESC_REGEXP, '$1');\n        }\n\n        params[key] = value;\n    }\n\n    if (index !== -1 && index !== string.length)\n        throw new TypeError('invalid parameter format');\n\n    return new ContentDisposition(type, params);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = match[1].toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "names",
    "snippet": "const names = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "params",
    "snippet": "const params = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "pdecode",
    "snippet": "function pdecode(str: string, hex: string): string {\n    return String.fromCharCode(parseInt(hex, 16));\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "pencode",
    "snippet": "function pencode(char: string): string {\n    return '%' + String(char).charCodeAt(0).toString(16).toUpperCase();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "qstring",
    "snippet": "function qstring(val: string): string {\n    const str = String(val);\n    return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "str",
    "snippet": "const str = String(val);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "ustring",
    "snippet": "function ustring(val: string): string {\n    const str = String(val);\n\n    // percent encode as UTF-8\n    const encoded = encodeURIComponent(str).replace(\n        ENCODE_URL_ATTR_CHAR_REGEXP,\n        pencode,\n    );\n\n    return \"UTF-8''\" + encoded;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "str",
    "snippet": "const str = String(val);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Constant",
    "value": "encoded",
    "snippet": "const encoded = encodeURIComponent(str).replace(\n        ENCODE_URL_ATTR_CHAR_REGEXP,\n        pencode,\n    );"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-disposition.ts",
    "type": "Function",
    "value": "ContentDisposition",
    "snippet": "function ContentDisposition(this: any, type, parameters) {\n    this.type = type;\n    this.parameters = parameters;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "PARAM_REGEXP",
    "snippet": "const PARAM_REGEXP =\n    /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "TEXT_REGEXP",
    "snippet": "const TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "TOKEN_REGEXP",
    "snippet": "const TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "QESC_REGEXP",
    "snippet": "const QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "QUOTE_REGEXP",
    "snippet": "const QUOTE_REGEXP = /([\\\\\"])/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "TYPE_REGEXP",
    "snippet": "const TYPE_REGEXP =\n    /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "contentTypeFormat",
    "snippet": "const contentTypeFormat = obj => {\n    if (!obj || typeof obj !== 'object')\n        throw new TypeError('argument obj is required');\n\n    const parameters = obj.parameters;\n    const type = obj.type;\n\n    if (!type || !TYPE_REGEXP.test(type)) throw new TypeError('invalid type');\n\n    let string = type;\n\n    if (parameters && typeof parameters === 'object') {\n        let param;\n        let params = Object.keys(parameters).sort();\n\n        for (let i = 0; i < params.length; i++) {\n            param = params[i];\n\n            if (!TOKEN_REGEXP.test(param))\n                throw new TypeError('invalid parameter name');\n\n            string += '; ' + param + '=' + qstring(parameters[param]);\n        }\n    }\n\n    return string;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "parameters",
    "snippet": "const parameters = obj.parameters;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = obj.type;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "contentTypeParse",
    "snippet": "const contentTypeParse = (string: string) => {\n    if (!string) throw new TypeError('argument string is required');\n\n    const header = typeof string === 'object' ? getcontenttype(string) : string;\n\n    if (typeof header !== 'string')\n        throw new TypeError('argument string is required to be a string');\n\n    var index = header.indexOf(';');\n    var type = index !== -1 ? header.slice(0, index).trim() : header.trim();\n\n    if (!TYPE_REGEXP.test(type)) throw new TypeError('invalid media type');\n\n    const obj = new ContentType(type.toLowerCase());\n\n    if (index !== -1) {\n        let key;\n        let match;\n        let value;\n\n        PARAM_REGEXP.lastIndex = index;\n\n        while ((match = PARAM_REGEXP.exec(header))) {\n            if (match.index !== index)\n                throw new TypeError('invalid parameter format');\n\n            index += match[0].length;\n            key = match[1].toLowerCase();\n            value = match[2];\n\n            if (value.charCodeAt(0) === 0x22 /* \" */) {\n                value = value.slice(1, -1);\n\n                if (value.indexOf('\\\\') !== -1)\n                    value = value.replace(QESC_REGEXP, '$1');\n            }\n\n            obj.parameters[key] = value;\n        }\n\n        if (index !== header.length)\n            throw new TypeError('invalid parameter format');\n    }\n\n    return obj;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "header",
    "snippet": "const header = typeof string === 'object' ? getcontenttype(string) : string;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "obj",
    "snippet": "const obj = new ContentType(type.toLowerCase());"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Function",
    "value": "getcontenttype",
    "snippet": "function getcontenttype(obj) {\n    let header;\n\n    if (typeof obj.getHeader === 'function')\n        header = obj.getHeader('content-type');\n    else if (typeof obj.headers === 'object')\n        header = obj.headers && obj.headers['content-type'];\n\n    if (typeof header !== 'string')\n        throw new TypeError('content-type header is missing from object');\n\n    return header;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Function",
    "value": "qstring",
    "snippet": "function qstring(val) {\n    let str = String(val);\n\n    if (TOKEN_REGEXP.test(str)) return str;\n\n    if (str.length > 0 && !TEXT_REGEXP.test(str))\n        throw new TypeError('invalid parameter value');\n\n    return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Function",
    "value": "ContentType",
    "snippet": "function ContentType(this: any, type) {\n    this.parameters = Object.create(null);\n    this.type = type;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "setCharset",
    "snippet": "const setCharset = (type: string, charset: string) => {\n    if (!type || !charset) return type;\n\n    const parsed = contentTypeParse(type);\n    parsed.parameters.charset = charset;\n    return contentTypeFormat(parsed);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/content-type.ts",
    "type": "Constant",
    "value": "parsed",
    "snippet": "const parsed = contentTypeParse(type);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "cookieSignatureSign",
    "snippet": "const cookieSignatureSign = (val, secret) => {\n    if ('string' != typeof val)\n        throw new TypeError('Cookie value must be provided as a string.');\n    if (null == secret) throw new TypeError('Secret key must be provided.');\n    return (\n        val +\n        '.' +\n        crypto\n            .createHmac('sha256', secret)\n            .update(val)\n            .digest('base64')\n            .replace(/\\=+$/, '')\n    );\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "cookieSignatureUnsign",
    "snippet": "const cookieSignatureUnsign = (input, secret) => {\n    if ('string' != typeof input)\n        throw new TypeError('Signed cookie string must be provided.');\n    if (null == secret) throw new TypeError('Secret key must be provided.');\n    const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);\n    return expectedBuffer.length === inputBuffer.length &&\n        crypto.timingSafeEqual(expectedBuffer, inputBuffer)\n        ? tentativeValue\n        : false;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "tentativeValue",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "expectedInput",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "expectedBuffer",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie-signature.ts",
    "type": "Constant",
    "value": "inputBuffer",
    "snippet": "const tentativeValue = input.slice(0, input.lastIndexOf('.')),\n        expectedInput = exports.sign(tentativeValue, secret),\n        expectedBuffer = Buffer.from(expectedInput),\n        inputBuffer = Buffer.from(input);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "__toString",
    "snippet": "const __toString = Object.prototype.toString;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "fieldContentRegExp",
    "snippet": "const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "cookieParse",
    "snippet": "const cookieParse = (str, options) => {\n    if (typeof str !== 'string')\n        throw new TypeError('argument str must be a string');\n\n    const obj = {};\n    const opt = options || {};\n    const dec = opt.decode || decode;\n    let index = 0;\n\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        if (eqIdx === -1) break;\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        if (undefined === obj[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            if (val.charCodeAt(0) === 0x22) val = val.slice(1, -1);\n\n            obj[key] = tryDecode(val, dec);\n        }\n\n        index = endIdx + 1;\n    }\n\n    return obj;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "obj",
    "snippet": "const obj = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "opt",
    "snippet": "const opt = options || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "dec",
    "snippet": "const dec = opt.decode || decode;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "eqIdx",
    "snippet": "const eqIdx = str.indexOf('=', index);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "key",
    "snippet": "const key = str.slice(index, eqIdx).trim();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "cookieSerialize",
    "snippet": "const cookieSerialize = (name, val, options) => {\n    const opt = options || {};\n    const enc = opt.encode || encode;\n\n    if (typeof enc !== 'function')\n        throw new TypeError('option encode is invalid');\n\n    if (!fieldContentRegExp.test(name))\n        throw new TypeError('argument name is invalid');\n\n    const value = enc(val);\n\n    if (value && !fieldContentRegExp.test(value))\n        throw new TypeError('argument val is invalid');\n\n    let str = name + '=' + value;\n\n    if (null != opt.maxAge) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge))\n            throw new TypeError('option maxAge is invalid');\n\n        str += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain))\n            throw new TypeError('option domain is invalid');\n\n        str += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path))\n            throw new TypeError('option path is invalid');\n\n        str += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        const expires = opt.expires;\n\n        if (!isDate(expires) || isNaN(expires.valueOf()))\n            throw new TypeError('option expires is invalid');\n\n        str += '; Expires=' + expires.toUTCString();\n    }\n\n    if (opt.httpOnly) str += '; HttpOnly';\n\n    if (opt.secure) str += '; Secure';\n\n    if (opt.partitioned) str += '; Partitioned';\n\n    if (opt.priority) {\n        const priority =\n            typeof opt.priority === 'string'\n                ? opt.priority.toLowerCase()\n                : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                str += '; Priority=Low';\n                break;\n            case 'medium':\n                str += '; Priority=Medium';\n                break;\n            case 'high':\n                str += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite =\n            typeof opt.sameSite === 'string'\n                ? opt.sameSite.toLowerCase()\n                : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                str += '; SameSite=Strict';\n                break;\n            case 'lax':\n                str += '; SameSite=Lax';\n                break;\n            case 'strict':\n                str += '; SameSite=Strict';\n                break;\n            case 'none':\n                str += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return str;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "opt",
    "snippet": "const opt = options || {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "enc",
    "snippet": "const enc = opt.encode || encode;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "value",
    "snippet": "const value = enc(val);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "maxAge",
    "snippet": "const maxAge = opt.maxAge - 0;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "expires",
    "snippet": "const expires = opt.expires;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "priority",
    "snippet": "const priority =\n            typeof opt.priority === 'string'\n                ? opt.priority.toLowerCase()\n                : opt.priority;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Constant",
    "value": "sameSite",
    "snippet": "const sameSite =\n            typeof opt.sameSite === 'string'\n                ? opt.sameSite.toLowerCase()\n                : opt.sameSite;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Function",
    "value": "decode",
    "snippet": "function decode(str) {\n    return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Function",
    "value": "encode",
    "snippet": "function encode(val) {\n    return encodeURIComponent(val);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Function",
    "value": "isDate",
    "snippet": "function isDate(val) {\n    return __toString.call(val) === '[object Date]' || val instanceof Date;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/cookie.ts",
    "type": "Function",
    "value": "tryDecode",
    "snippet": "function tryDecode(str, decode) {\n    try {\n        return decode(str);\n    } catch (e) {\n        return str;\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Constant",
    "value": "destroy",
    "snippet": "const destroy = (stream?, suppress?) => {\n    if (!stream) return;\n\n    if (isFsReadStream(stream)) {\n        destroyReadStream(stream);\n    } else if (isZlibStream(stream)) {\n        destroyZlibStream(stream);\n    } else if (hasDestroy(stream)) {\n        stream.destroy();\n    }\n\n    if (isEventEmitter(stream) && suppress) {\n        stream.removeAllListeners('error');\n        stream.addListener('error', noop);\n    }\n\n    return stream;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "destroyReadStream",
    "snippet": "function destroyReadStream(stream) {\n    stream.destroy();\n\n    if (typeof stream.close === 'function') stream.on('open', onOpenClose);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "closeZlibStream",
    "snippet": "function closeZlibStream(stream) {\n    if (stream._hadError === true) {\n        const prop = stream._binding === null ? '_binding' : '_handle';\n\n        stream[prop] = {\n            close: function () {\n                this[prop] = null;\n            },\n        };\n    }\n\n    stream.close();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Constant",
    "value": "prop",
    "snippet": "const prop = stream._binding === null ? '_binding' : '_handle';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "destroyZlibStream",
    "snippet": "function destroyZlibStream(stream) {\n    if (typeof stream.destroy === 'function') {\n        if (stream._binding) {\n            stream.destroy();\n            if (stream._processing) {\n                stream._needDrain = true;\n                stream.once('drain', onDrainClearBinding);\n            } else {\n                stream._binding.clear();\n            }\n        } else if (\n            stream._destroy &&\n            stream._destroy !== Stream.Transform.prototype._destroy\n        ) {\n            stream.destroy();\n        } else if (stream._destroy && typeof stream.close === 'function') {\n            stream.destroyed = true;\n            stream.close();\n        } else {\n            stream.destroy();\n        }\n    } else if (typeof stream.close === 'function') {\n        closeZlibStream(stream);\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "hasDestroy",
    "snippet": "function hasDestroy(stream) {\n    return typeof stream.destroy === 'function';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "isEventEmitter",
    "snippet": "function isEventEmitter(val) {\n    return val instanceof EventEmitter;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "isFsReadStream",
    "snippet": "function isFsReadStream(stream) {\n    return stream instanceof ReadStream;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "isZlibStream",
    "snippet": "function isZlibStream(stream) {\n    return (\n        stream instanceof Zlib.gzip ||\n        stream instanceof Zlib.gunzip ||\n        stream instanceof Zlib.deflate ||\n        stream instanceof Zlib.deflateRaw ||\n        stream instanceof Zlib.inflate ||\n        stream instanceof Zlib.inflateRaw ||\n        stream instanceof Zlib.unzip\n    );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "noop",
    "snippet": "function noop() {}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "onDrainClearBinding",
    "snippet": "function onDrainClearBinding(this: any) {\n    this._binding.clear();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/destroy.ts",
    "type": "Function",
    "value": "onOpenClose",
    "snippet": "function onOpenClose(this: any) {\n    if (typeof this.fd === 'number') this.close();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/encodeurl.ts",
    "type": "Constant",
    "value": "ENCODE_CHARS_REGEXP",
    "snippet": "const ENCODE_CHARS_REGEXP =\n    /(?:[^\\x21\\x23-\\x3B\\x3D\\x3F-\\x5F\\x61-\\x7A\\x7C\\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/encodeurl.ts",
    "type": "Constant",
    "value": "UNMATCHED_SURROGATE_PAIR_REGEXP",
    "snippet": "const UNMATCHED_SURROGATE_PAIR_REGEXP =\n    /(^|[^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]([^\\uDC00-\\uDFFF]|$)/g;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/encodeurl.ts",
    "type": "Constant",
    "value": "UNMATCHED_SURROGATE_PAIR_REPLACE",
    "snippet": "const UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\\uFFFD$2';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/encodeurl.ts",
    "type": "Constant",
    "value": "encodeUrl",
    "snippet": "const encodeUrl = url => {\n    return String(url)\n        .replace(\n            UNMATCHED_SURROGATE_PAIR_REGEXP,\n            UNMATCHED_SURROGATE_PAIR_REPLACE,\n        )\n        .replace(ENCODE_CHARS_REGEXP, encodeURI);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/escape-html.ts",
    "type": "Constant",
    "value": "matchHtmlRegExp",
    "snippet": "const matchHtmlRegExp = /[\"'&<>]/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/escape-html.ts",
    "type": "Constant",
    "value": "escapeHtml",
    "snippet": "const escapeHtml = (string: string | number | object) => {\n    const str = '' + string;\n    const match = matchHtmlRegExp.exec(str);\n\n    if (!match) return str;\n\n    let escape;\n    let html = '';\n    let index = 0;\n    let lastIndex = 0;\n\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34:\n                escape = '&quot;';\n                break; // \"\n            case 38:\n                escape = '&amp;';\n                break; // &\n            case 39:\n                escape = '&#39;';\n                break; // '\n            case 60:\n                escape = '&lt;';\n                break; // <\n            case 62:\n                escape = '&gt;';\n                break; // >\n            default:\n                continue;\n        }\n\n        if (lastIndex !== index) html += str.substring(lastIndex, index);\n\n        lastIndex = index + 1;\n        html += escape;\n    }\n\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/escape-html.ts",
    "type": "Constant",
    "value": "str",
    "snippet": "const str = '' + string;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/escape-html.ts",
    "type": "Constant",
    "value": "match",
    "snippet": "const match = matchHtmlRegExp.exec(str);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "etag",
    "snippet": "const etag = createETagGenerator({ weak: false });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "wetag",
    "snippet": "const wetag = createETagGenerator({ weak: true });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "compileETag",
    "snippet": "const compileETag = val => {\n    let fn;\n\n    if (typeof val === 'function') return val;\n\n    switch (val) {\n        case true:\n        case 'weak':\n            fn = exports.wetag;\n            break;\n        case false:\n            break;\n        case 'strong':\n            fn = exports.etag;\n            break;\n        default:\n            throw new TypeError('unknown value for etag function: ' + val);\n    }\n\n    return fn;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Function",
    "value": "createETagGenerator",
    "snippet": "function createETagGenerator(options) {\n    return function generateETag(body, options?) {\n        const encoding = options === 'string' ? options : 'utf-8';\n\n        const buf =\n            typeof body === 'string' ? Buffer.from(body, encoding) : body;\n\n        return etagGen(buf, options);\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding = options === 'string' ? options : 'utf-8';"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "buf",
    "snippet": "const buf =\n            typeof body === 'string' ? Buffer.from(body, encoding) : body;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Function",
    "value": "etagGen",
    "snippet": "function etagGen(\n    entity?: string | Buffer | fs.Stats,\n    options?: { weak: boolean },\n) {\n    if (entity == null) throw new TypeError('argument entity is required');\n\n    // support fs.Stats object\n    const isStats = isstats(entity);\n    let weak =\n        options && typeof options.weak === 'boolean' ? options.weak : isStats;\n\n    if (options?.weak === false) weak = false;\n    else if (isStats === true) weak = true;\n\n    // validate argument\n    if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity))\n        throw new TypeError(\n            'argument entity must be string, Buffer, or fs.Stats',\n        );\n\n    // generate entity tag\n    const tag = isStats ? stattag(entity) : entitytag(entity);\n\n    return weak ? 'W/' + tag : tag;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "isStats",
    "snippet": "const isStats = isstats(entity);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "tag",
    "snippet": "const tag = isStats ? stattag(entity) : entitytag(entity);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Function",
    "value": "entitytag",
    "snippet": "function entitytag(entity) {\n    if (entity.length === 0) return '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"';\n\n    const hash = crypto\n        .createHash('sha1')\n        .update(entity, 'utf8')\n        .digest('base64')\n        .substring(0, 27);\n\n    const len =\n        typeof entity === 'string'\n            ? Buffer.byteLength(entity, 'utf8')\n            : entity.length;\n\n    return '\"' + len.toString(16) + '-' + hash + '\"';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "hash",
    "snippet": "const hash = crypto\n        .createHash('sha1')\n        .update(entity, 'utf8')\n        .digest('base64')\n        .substring(0, 27);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "len",
    "snippet": "const len =\n        typeof entity === 'string'\n            ? Buffer.byteLength(entity, 'utf8')\n            : entity.length;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Function",
    "value": "isstats",
    "snippet": "function isstats(obj) {\n    // genuine fs.Stats\n    if (typeof fs.Stats === 'function' && obj instanceof fs.Stats) return true;\n\n    // quack quack\n    return (\n        obj &&\n        typeof obj === 'object' &&\n        'ctime' in obj &&\n        toString.call(obj.ctime) === '[object Date]' &&\n        'mtime' in obj &&\n        toString.call(obj.mtime) === '[object Date]' &&\n        'ino' in obj &&\n        typeof obj.ino === 'number' &&\n        'size' in obj &&\n        typeof obj.size === 'number'\n    );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Function",
    "value": "stattag",
    "snippet": "function stattag(stat) {\n    const mtime = stat.mtime.getTime().toString(16);\n    const size = stat.size.toString(16);\n    return '\"' + size + '-' + mtime + '\"';\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "mtime",
    "snippet": "const mtime = stat.mtime.getTime().toString(16);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/etag.ts",
    "type": "Constant",
    "value": "size",
    "snippet": "const size = stat.size.toString(16);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "CACHE_CONTROL_NO_CACHE_REGEXP",
    "snippet": "const CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "fresh",
    "snippet": "const fresh = (reqHeaders, resHeaders) => {\n    // fields\n    const modifiedSince = reqHeaders['if-modified-since'];\n    const noneMatch = reqHeaders['if-none-match'];\n\n    // unconditional request\n    if (!modifiedSince && !noneMatch) return false;\n\n    // Always return stale when Cache-Control: no-cache\n    // to support end-to-end reload requests\n    // https://tools.ietf.org/html/rfc2616#section-14.9.4\n    const cacheControl = reqHeaders['cache-control'];\n    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl))\n        return false;\n\n    // if-none-match takes precedent over if-modified-since\n    if (noneMatch) {\n        if (noneMatch === '*') return true;\n\n        const etag = resHeaders.etag;\n\n        if (!etag) return false;\n\n        const matches = parseTokenList(noneMatch);\n\n        for (let i = 0; i < matches.length; i++) {\n            const match = matches[i];\n\n            if (\n                match === etag ||\n                match === 'W/' + etag ||\n                'W/' + match === etag\n            )\n                return true;\n        }\n\n        return false;\n    }\n\n    // if-modified-since\n    if (modifiedSince) {\n        const lastModified = resHeaders['last-modified'];\n        const modifiedStale =\n            !lastModified ||\n            !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));\n\n        if (modifiedStale) return false;\n    }\n\n    return true;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "modifiedSince",
    "snippet": "const modifiedSince = reqHeaders['if-modified-since'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "noneMatch",
    "snippet": "const noneMatch = reqHeaders['if-none-match'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "cacheControl",
    "snippet": "const cacheControl = reqHeaders['cache-control'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "etag",
    "snippet": "const etag = resHeaders.etag;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "matches",
    "snippet": "const matches = parseTokenList(noneMatch);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "match",
    "snippet": "const match = matches[i];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "lastModified",
    "snippet": "const lastModified = resHeaders['last-modified'];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "modifiedStale",
    "snippet": "const modifiedStale =\n            !lastModified ||\n            !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Function",
    "value": "parseHttpDate",
    "snippet": "function parseHttpDate(date) {\n    const timestamp = date && Date.parse(date);\n\n    // istanbul ignore next: guard against date.js Date.parse patching\n    return typeof timestamp === 'number' ? timestamp : NaN;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "timestamp",
    "snippet": "const timestamp = date && Date.parse(date);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Function",
    "value": "parseTokenList",
    "snippet": "function parseTokenList(str) {\n    let end = 0;\n    const list = [];\n    let start = 0;\n\n    // gather tokens\n    for (let i = 0, len = str.length; i < len; i++) {\n        switch (str.charCodeAt(i)) {\n            case 0x20 /*   */:\n                if (start === end) {\n                    start = end = i + 1;\n                }\n                break;\n            case 0x2c /* , */:\n                list.push(str.substring(start, end));\n                start = end = i + 1;\n                break;\n            default:\n                end = i + 1;\n                break;\n        }\n    }\n\n    // final token\n    list.push(str.substring(start, end));\n\n    return list;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/fresh.ts",
    "type": "Constant",
    "value": "list",
    "snippet": "const list = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "compileTrust",
    "snippet": "const compileTrust = val => {\n    if (typeof val === 'function') return val;\n\n    if (val === true)\n        return function () {\n            return true;\n        };\n\n    if (typeof val === 'number')\n        return function (a, i) {\n            return i < val;\n        };\n\n    if (typeof val === 'string') {\n        val = val.split(',').map(function (v) {\n            return v.trim();\n        });\n    }\n\n    return proxyaddr.compile(val || []);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "utilsMerge",
    "snippet": "const utilsMerge = (a, b) => {\n    if (a && b) {\n        for (var key in b) a[key] = b[key];\n    }\n    return a;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "normalizeType",
    "snippet": "const normalizeType = type => {\n    return ~type.indexOf('/')\n        ? acceptParams(type)\n        : {\n              value: mime.getType(type) || 'application/octet-stream',\n              params: {},\n          };\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "normalizeTypes",
    "snippet": "const normalizeTypes = types => {\n    const ret = [];\n\n    for (let i = 0; i < types.length; ++i)\n        ret.push(exports.normalizeType(types[i]));\n\n    return ret;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "ret",
    "snippet": "const ret = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "setPrototypeOf",
    "snippet": "const setPrototypeOf =\n    Object.setPrototypeOf ||\n    ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Function",
    "value": "acceptParams",
    "snippet": "function acceptParams(str) {\n    const parts = str.split(/ *; */);\n    const ret = { value: parts[0], quality: 1, params: {} };\n\n    for (var i = 1; i < parts.length; ++i) {\n        const pms = parts[i].split(/ *= */);\n\n        if ('q' === pms[0]) ret.quality = parseFloat(pms[1]);\n        else ret.params[pms[0]] = pms[1];\n    }\n\n    return ret;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "parts",
    "snippet": "const parts = str.split(/ *; */);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "ret",
    "snippet": "const ret = { value: parts[0], quality: 1, params: {} };"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Constant",
    "value": "pms",
    "snippet": "const pms = parts[i].split(/ *= */);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Function",
    "value": "setProtoOf",
    "snippet": "function setProtoOf(obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/index.ts",
    "type": "Function",
    "value": "mixinProperties",
    "snippet": "function mixinProperties(obj, proto) {\n    for (var prop in proto) {\n        if (!Object.prototype.hasOwnProperty.call(obj, prop))\n            obj[prop] = proto[prop];\n    }\n\n    return obj;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Class",
    "value": "Mime",
    "snippet": "class Mime {\n    #extensionToType = new Map<string, string>();\n    #typeToExtension = new Map<string, string>();\n    #typeToExtensions = new Map<string, Set<string>>();\n\n    constructor(...args: TypeMap[]) {\n        if (args.length > 0) {\n            for (const arg of args) this.define(arg);\n        } else {\n            this.define(standardTypes);\n            this.define(otherTypes);\n        }\n    }\n\n    define(typeMap: TypeMap, force = false) {\n        for (let [type, extensions] of Object.entries(typeMap)) {\n            type = type.toLowerCase();\n            extensions = extensions.map(ext => ext.toLowerCase());\n\n            if (!this.#typeToExtensions.has(type))\n                this.#typeToExtensions.set(type, new Set<string>());\n\n            const allExtensions = this.#typeToExtensions.get(type);\n\n            let first = true;\n            for (let extension of extensions) {\n                const starred = extension.startsWith('*');\n\n                extension = starred ? extension.slice(1) : extension;\n                allExtensions?.add(extension);\n\n                if (first) this.#typeToExtension.set(type, extension);\n\n                first = false;\n\n                if (starred) continue;\n\n                const currentType = this.#extensionToType.get(extension);\n\n                if (currentType && currentType != type && !force) {\n                    throw new Error(\n                        `\"${type} -> ${extension}\" conflicts with \"${currentType} -> ${extension}\". Pass \\`force=true\\` to override this definition.`,\n                    );\n                }\n\n                this.#extensionToType.set(extension, type);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Get mime type associated with an extension\n     */\n    getType(path: string) {\n        if (typeof path !== 'string') return null;\n\n        const last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n        const ext = last.replace(/^.*\\./, '').toLowerCase();\n\n        const hasPath = last.length < path.length;\n        const hasDot = ext.length < last.length - 1;\n\n        if (!hasDot && hasPath) return null;\n\n        return this.#extensionToType.get(ext) ?? null;\n    }\n\n    /**\n     * Get default file extension associated with a mime type\n     */\n    getExtension(type: string) {\n        if (typeof type !== 'string') return null;\n\n        type = type?.split?.(';')[0];\n\n        return (\n            (type && this.#typeToExtension.get(type.trim().toLowerCase())) ??\n            null\n        );\n    }\n\n    /**\n     * Get all file extensions associated with a mime type\n     */\n    getAllExtensions(type: string) {\n        if (typeof type !== 'string') return null;\n        return this.#typeToExtensions.get(type.toLowerCase()) ?? null;\n    }\n\n    //\n    // Private API, for internal use only.  These APIs may change at any time\n    //\n    _freeze() {\n        this.define = () => {\n            throw new Error(\n                'define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances',\n            );\n        };\n\n        Object.freeze(this);\n\n        for (const extensions of this.#typeToExtensions.values())\n            Object.freeze(extensions);\n\n        return this;\n    }\n\n    _getTestState() {\n        return {\n            types: this.#extensionToType,\n            extensions: this.#typeToExtension,\n        };\n    }\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "arg",
    "snippet": "const arg"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "allExtensions",
    "snippet": "const allExtensions = this.#typeToExtensions.get(type);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "starred",
    "snippet": "const starred = extension.startsWith('*');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "currentType",
    "snippet": "const currentType = this.#extensionToType.get(extension);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "last",
    "snippet": "const last = path.replace(/^.*[/\\\\]/, '').toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "ext",
    "snippet": "const ext = last.replace(/^.*\\./, '').toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "hasPath",
    "snippet": "const hasPath = last.length < path.length;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "hasDot",
    "snippet": "const hasDot = ext.length < last.length - 1;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "extensions",
    "snippet": "const extensions"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/mime.ts",
    "type": "Constant",
    "value": "mime",
    "snippet": "const mime = new Mime()._freeze();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "url",
    "snippet": "const url = require('url');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "parse",
    "snippet": "const parse = url.parse;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "Url",
    "snippet": "const Url = url.Url;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "parseurl",
    "snippet": "const parseurl = (req: Req): any | undefined => {\n    const urlReturn = req.url;\n\n    if (urlReturn === undefined) return undefined;\n\n    let parsed = req?._parsedUrl;\n\n    if (fresh(urlReturn, parsed)) return parsed;\n\n    parsed = fastparse(urlReturn);\n    parsed._raw = urlReturn;\n\n    return (req._parsedUrl = parsed);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "urlReturn",
    "snippet": "const urlReturn = req.url;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "parseUrlOriginal",
    "snippet": "const parseUrlOriginal = (req: Req) => {\n    const url = req.originalUrl;\n\n    if (typeof url !== 'string') return parseurl(req);\n\n    let parsed = req._parsedOriginalUrl;\n\n    if (fresh(url, parsed)) return parsed;\n\n    // Parse the URL\n    parsed = fastparse(url);\n    parsed._raw = url;\n\n    return (req._parsedOriginalUrl = parsed);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "url",
    "snippet": "const url = req.originalUrl;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "originalurl",
    "snippet": "const originalurl = (req: Req) => {\n    const urlReturn = req.originalUrl;\n\n    if (typeof urlReturn !== 'string') return parseurl(req);\n\n    let parsed = req._parsedOriginalUrl;\n\n    if (fresh(urlReturn, parsed)) return parsed;\n\n    // Parse the URL\n    parsed = fastparse(urlReturn);\n    parsed._raw = urlReturn;\n\n    return (req._parsedOriginalUrl = parsed);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "urlReturn",
    "snippet": "const urlReturn = req.originalUrl;"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Function",
    "value": "fastparse",
    "snippet": "function fastparse(str) {\n    if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */)\n        return parse(str);\n\n    let pathname = str;\n    let query = null;\n    let search = null;\n\n    // This takes the regexp from https://github.com/joyent/node/pull/7878\n    // Which is /^(\\/[^?#\\s]*)(\\?[^#\\s]*)?$/\n    // And unrolls it into a for loop\n    for (let i = 1; i < str.length; i++) {\n        switch (str.charCodeAt(i)) {\n            case 0x3f /* ?  */:\n                if (search === null) {\n                    pathname = str.substring(0, i);\n                    query = str.substring(i + 1);\n                    search = str.substring(i);\n                }\n                break;\n            case 0x09: /* \\t */\n            case 0x0a: /* \\n */\n            case 0x0c: /* \\f */\n            case 0x0d: /* \\r */\n            case 0x20: /*    */\n            case 0x23: /* #  */\n            case 0xa0:\n            case 0xfeff:\n                return parse(str);\n        }\n    }\n\n    const urlReturn = Url !== undefined ? new Url() : {};\n\n    urlReturn.path = str;\n    urlReturn.href = str;\n    urlReturn.pathname = pathname;\n\n    if (search !== null) {\n        urlReturn.query = query;\n        urlReturn.search = search;\n    }\n\n    return urlReturn;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Constant",
    "value": "urlReturn",
    "snippet": "const urlReturn = Url !== undefined ? new Url() : {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/parseurl.ts",
    "type": "Function",
    "value": "fresh",
    "snippet": "function fresh(url, parsedUrl) {\n    return (\n        typeof parsedUrl === 'object' &&\n        parsedUrl !== null &&\n        (Url === undefined || parsedUrl instanceof Url) &&\n        parsedUrl._raw === url\n    );\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/querystring.ts",
    "type": "Constant",
    "value": "compileQueryParser",
    "snippet": "const compileQueryParser = function compileQueryParser(\n    val: string | Function | boolean,\n) {\n    let fn;\n\n    if (typeof val === 'function') return val;\n\n    switch (val) {\n        case true:\n        case 'simple':\n            fn = qs.parse;\n            break;\n        case false:\n            break;\n        case 'extended':\n            fn = parseExtendedQueryString;\n            break;\n        default:\n            throw new TypeError(\n                'unknown value for query parser function: ' + val,\n            );\n    }\n\n    return fn;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/querystring.ts",
    "type": "Function",
    "value": "parseExtendedQueryString",
    "snippet": "function parseExtendedQueryString(str) {\n    return qs.parse(str, {\n        allowPrototypes: true,\n    });\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "rangeParser",
    "snippet": "const rangeParser = (size: number, str: string, options?: any) => {\n    if (typeof str !== 'string')\n        throw new TypeError('argument str must be a string');\n\n    const index = str.indexOf('=');\n\n    if (index === -1) return -2;\n\n    const arr = str.slice(index + 1).split(',');\n    const ranges: any = [];\n\n    ranges.type = str.slice(0, index);\n\n    for (let i = 0; i < arr.length; i++) {\n        const range = arr[i].split('-');\n        let start = parseInt(range[0], 10);\n        let end = parseInt(range[1], 10);\n\n        // -nnn\n        if (isNaN(start)) {\n            start = size - end;\n            end = size - 1;\n            // nnn-\n        } else if (isNaN(end)) {\n            end = size - 1;\n        }\n\n        // limit last-byte-pos to current length\n        if (end > size - 1) end = size - 1;\n\n        // invalid or unsatisifiable\n        if (isNaN(start) || isNaN(end) || start > end || start < 0) continue;\n\n        // add range\n        ranges.push({\n            start: start,\n            end: end,\n        });\n    }\n\n    if (ranges.length < 1) return -1;\n\n    return options && options.combine ? combineRanges(ranges) : ranges;\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "index",
    "snippet": "const index = str.indexOf('=');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "arr",
    "snippet": "const arr = str.slice(index + 1).split(',');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "ranges",
    "snippet": "const ranges: any = [];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "range",
    "snippet": "const range = arr[i].split('-');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Function",
    "value": "combineRanges",
    "snippet": "function combineRanges(ranges) {\n    const ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);\n    let j = 0;\n\n    for (let i = 1; i < ordered.length; i++) {\n        const range = ordered[i];\n        const current = ordered[j];\n\n        if (range.start > current.end + 1) {\n            // next range\n            ordered[++j] = range;\n        } else if (range.end > current.end) {\n            // extend range\n            current.end = range.end;\n            current.index = Math.min(current.index, range.index);\n        }\n    }\n\n    // trim ordered array\n    ordered.length = j + 1;\n\n    // generate combined range\n    const combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);\n\n    // copy ranges type\n    combined.type = ranges.type;\n\n    return combined;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "ordered",
    "snippet": "const ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "range",
    "snippet": "const range = ordered[i];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "current",
    "snippet": "const current = ordered[j];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Constant",
    "value": "combined",
    "snippet": "const combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Function",
    "value": "mapWithIndex",
    "snippet": "function mapWithIndex(range, index) {\n    return {\n        start: range.start,\n        end: range.end,\n        index: index,\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Function",
    "value": "mapWithoutIndex",
    "snippet": "function mapWithoutIndex(range) {\n    return {\n        start: range.start,\n        end: range.end,\n    };\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Function",
    "value": "sortByRangeIndex",
    "snippet": "function sortByRangeIndex(a, b) {\n    return a.index - b.index;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/range-parser.ts",
    "type": "Function",
    "value": "sortByRangeStart",
    "snippet": "function sortByRangeStart(a, b) {\n    return a.start - b.start;\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Constant",
    "value": "onFinished",
    "snippet": "const onFinished = require('on-finished');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Constant",
    "value": "sendfile",
    "snippet": "const sendfile = (res, file, options, callback) => {\n    let done = false;\n    let streaming;\n\n    // request aborted\n    function onaborted() {\n        if (done) return;\n        done = true;\n\n        const err: any = new Error('Request aborted');\n        err.code = 'ECONNABORTED';\n        callback(err);\n    }\n\n    // directory\n    function ondirectory() {\n        if (done) return;\n        done = true;\n\n        const err: any = new Error('EISDIR, read');\n        err.code = 'EISDIR';\n        callback(err);\n    }\n\n    // errors\n    function onerror(err) {\n        if (done) return;\n        done = true;\n        callback(err);\n    }\n\n    // ended\n    function onend() {\n        if (done) return;\n        done = true;\n        callback();\n    }\n\n    // file\n    function onfile() {\n        streaming = false;\n    }\n\n    // finished\n    function onfinish(err) {\n        if (err && err.code === 'ECONNRESET') return onaborted();\n        if (err) return onerror(err);\n        if (done) return;\n\n        setImmediate(function () {\n            if (streaming !== false && !done) {\n                onaborted();\n                return;\n            }\n\n            if (done) return;\n            done = true;\n            callback();\n        });\n    }\n\n    // streaming\n    function onstream() {\n        streaming = true;\n    }\n\n    file.on('directory', ondirectory);\n    file.on('end', onend);\n    file.on('error', onerror);\n    file.on('file', onfile);\n    file.on('stream', onstream);\n    onFinished(res, onfinish);\n\n    if (options.headers) {\n        file.on('headers', function headers(res) {\n            var obj = options.headers;\n            var keys = Object.keys(obj);\n\n            for (let i = 0; i < keys.length; i++) {\n                let k = keys[i];\n                res.setHeader(k, obj[k]);\n            }\n        });\n    }\n\n    file.pipe(res);\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onaborted",
    "snippet": "function onaborted() {\n        if (done) return;\n        done = true;\n\n        const err: any = new Error('Request aborted');\n        err.code = 'ECONNABORTED';\n        callback(err);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Constant",
    "value": "err",
    "snippet": "const err: any = new Error('Request aborted');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "ondirectory",
    "snippet": "function ondirectory() {\n        if (done) return;\n        done = true;\n\n        const err: any = new Error('EISDIR, read');\n        err.code = 'EISDIR';\n        callback(err);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Constant",
    "value": "err",
    "snippet": "const err: any = new Error('EISDIR, read');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onerror",
    "snippet": "function onerror(err) {\n        if (done) return;\n        done = true;\n        callback(err);\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onend",
    "snippet": "function onend() {\n        if (done) return;\n        done = true;\n        callback();\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onfile",
    "snippet": "function onfile() {\n        streaming = false;\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onfinish",
    "snippet": "function onfinish(err) {\n        if (err && err.code === 'ECONNRESET') return onaborted();\n        if (err) return onerror(err);\n        if (done) return;\n\n        setImmediate(function () {\n            if (streaming !== false && !done) {\n                onaborted();\n                return;\n            }\n\n            if (done) return;\n            done = true;\n            callback();\n        });\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/sendfile.ts",
    "type": "Function",
    "value": "onstream",
    "snippet": "function onstream() {\n        streaming = true;\n    }"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "Codes",
    "snippet": "const Codes = require('./codes.json');"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "statuses",
    "snippet": "const statuses = {\n    // status code to message map\n    get message() {\n        return Codes;\n    },\n\n    // status message (lower-case) to code map\n    get code() {\n        return this.createMessageToStatusCodeMap(Codes);\n    },\n\n    // array of status codes\n    get codes() {\n        return this.createStatusCodeList(Codes);\n    },\n\n    // status codes for redirects\n    redirect: {\n        300: true,\n        301: true,\n        302: true,\n        303: true,\n        305: true,\n        307: true,\n        308: true,\n    },\n\n    // status codes for empty bodies\n    empty: {\n        204: true,\n        205: true,\n        304: true,\n    },\n\n    // status codes for when you should retry the request\n    retry: {\n        502: true,\n        503: true,\n        504: true,\n    },\n\n    /**\n     * Create a map of message to status code.\n     * @private\n     */\n    createMessageToStatusCodeMap(codes) {\n        const map = {};\n\n        Object.keys(codes).forEach(function forEachCode(code) {\n            const message = codes[code];\n            const status = Number(code);\n            map[message.toLowerCase()] = status;\n        });\n\n        return map;\n    },\n\n    /**\n     * Create a list of all status codes.\n     * @private\n     */\n    createStatusCodeList(codes) {\n        return Object.keys(codes).map(function mapCode(code) {\n            return Number(code);\n        });\n    },\n\n    /**\n     * Get the status code for given message.\n     * @private\n     */\n    getStatusCode(message) {\n        const msg = message.toLowerCase();\n\n        if (!Object.prototype.hasOwnProperty.call(this.code, msg))\n            throw new Error('invalid status message: \"' + message + '\"');\n\n        return this.code[msg];\n    },\n\n    getStatusMessage(code) {\n        if (!Object.prototype.hasOwnProperty.call(this.message, code))\n            throw new Error('invalid status code: ' + code);\n\n        return this.message[code];\n    },\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "map",
    "snippet": "const map = {};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "message",
    "snippet": "const message = codes[code];"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "status",
    "snippet": "const status = Number(code);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "msg",
    "snippet": "const msg = message.toLowerCase();"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Function",
    "value": "status",
    "snippet": "function status(code: string | number): number {\n    if (typeof code === 'number') return statuses.getStatusMessage(code);\n\n    if (typeof code !== 'string')\n        throw new TypeError('code must be a number or string');\n\n    // '403'\n    const n = parseInt(code, 10);\n\n    if (!isNaN(n)) return statuses.getStatusMessage(n);\n\n    return statuses.getStatusCode(code);\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server/utils/statuses.ts",
    "type": "Constant",
    "value": "n",
    "snippet": "const n = parseInt(code, 10);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/types/other.ts",
    "type": "Constant",
    "value": "types",
    "snippet": "const types: { [key: string]: string[] } = {\n    'application/prs.cww': ['cww'],\n    'application/prs.xsf+xml': ['xsf'],\n    'application/vnd.1000minds.decision-model+xml': ['1km'],\n    'application/vnd.3gpp.pic-bw-large': ['plb'],\n    'application/vnd.3gpp.pic-bw-small': ['psb'],\n    'application/vnd.3gpp.pic-bw-var': ['pvb'],\n    'application/vnd.3gpp2.tcap': ['tcap'],\n    'application/vnd.3m.post-it-notes': ['pwn'],\n    'application/vnd.accpac.simply.aso': ['aso'],\n    'application/vnd.accpac.simply.imp': ['imp'],\n    'application/vnd.acucobol': ['acu'],\n    'application/vnd.acucorp': ['atc', 'acutc'],\n    'application/vnd.adobe.air-application-installer-package+zip': ['air'],\n    'application/vnd.adobe.formscentral.fcdt': ['fcdt'],\n    'application/vnd.adobe.fxp': ['fxp', 'fxpl'],\n    'application/vnd.adobe.xdp+xml': ['xdp'],\n    'application/vnd.adobe.xfdf': ['*xfdf'],\n    'application/vnd.age': ['age'],\n    'application/vnd.ahead.space': ['ahead'],\n    'application/vnd.airzip.filesecure.azf': ['azf'],\n    'application/vnd.airzip.filesecure.azs': ['azs'],\n    'application/vnd.amazon.ebook': ['azw'],\n    'application/vnd.americandynamics.acc': ['acc'],\n    'application/vnd.amiga.ami': ['ami'],\n    'application/vnd.android.package-archive': ['apk'],\n    'application/vnd.anser-web-certificate-issue-initiation': ['cii'],\n    'application/vnd.anser-web-funds-transfer-initiation': ['fti'],\n    'application/vnd.antix.game-component': ['atx'],\n    'application/vnd.apple.installer+xml': ['mpkg'],\n    'application/vnd.apple.keynote': ['key'],\n    'application/vnd.apple.mpegurl': ['m3u8'],\n    'application/vnd.apple.numbers': ['numbers'],\n    'application/vnd.apple.pages': ['pages'],\n    'application/vnd.apple.pkpass': ['pkpass'],\n    'application/vnd.aristanetworks.swi': ['swi'],\n    'application/vnd.astraea-software.iota': ['iota'],\n    'application/vnd.audiograph': ['aep'],\n    'application/vnd.balsamiq.bmml+xml': ['bmml'],\n    'application/vnd.blueice.multipass': ['mpm'],\n    'application/vnd.bmi': ['bmi'],\n    'application/vnd.businessobjects': ['rep'],\n    'application/vnd.chemdraw+xml': ['cdxml'],\n    'application/vnd.chipnuts.karaoke-mmd': ['mmd'],\n    'application/vnd.cinderella': ['cdy'],\n    'application/vnd.citationstyles.style+xml': ['csl'],\n    'application/vnd.claymore': ['cla'],\n    'application/vnd.cloanto.rp9': ['rp9'],\n    'application/vnd.clonk.c4group': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],\n    'application/vnd.cluetrust.cartomobile-config': ['c11amc'],\n    'application/vnd.cluetrust.cartomobile-config-pkg': ['c11amz'],\n    'application/vnd.commonspace': ['csp'],\n    'application/vnd.contact.cmsg': ['cdbcmsg'],\n    'application/vnd.cosmocaller': ['cmc'],\n    'application/vnd.crick.clicker': ['clkx'],\n    'application/vnd.crick.clicker.keyboard': ['clkk'],\n    'application/vnd.crick.clicker.palette': ['clkp'],\n    'application/vnd.crick.clicker.template': ['clkt'],\n    'application/vnd.crick.clicker.wordbank': ['clkw'],\n    'application/vnd.criticaltools.wbs+xml': ['wbs'],\n    'application/vnd.ctc-posml': ['pml'],\n    'application/vnd.cups-ppd': ['ppd'],\n    'application/vnd.curl.car': ['car'],\n    'application/vnd.curl.pcurl': ['pcurl'],\n    'application/vnd.dart': ['dart'],\n    'application/vnd.data-vision.rdz': ['rdz'],\n    'application/vnd.dbf': ['dbf'],\n    'application/vnd.dece.data': ['uvf', 'uvvf', 'uvd', 'uvvd'],\n    'application/vnd.dece.ttml+xml': ['uvt', 'uvvt'],\n    'application/vnd.dece.unspecified': ['uvx', 'uvvx'],\n    'application/vnd.dece.zip': ['uvz', 'uvvz'],\n    'application/vnd.denovo.fcselayout-link': ['fe_launch'],\n    'application/vnd.dna': ['dna'],\n    'application/vnd.dolby.mlp': ['mlp'],\n    'application/vnd.dpgraph': ['dpg'],\n    'application/vnd.dreamfactory': ['dfac'],\n    'application/vnd.ds-keypoint': ['kpxx'],\n    'application/vnd.dvb.ait': ['ait'],\n    'application/vnd.dvb.service': ['svc'],\n    'application/vnd.dynageo': ['geo'],\n    'application/vnd.ecowin.chart': ['mag'],\n    'application/vnd.enliven': ['nml'],\n    'application/vnd.epson.esf': ['esf'],\n    'application/vnd.epson.msf': ['msf'],\n    'application/vnd.epson.quickanime': ['qam'],\n    'application/vnd.epson.salt': ['slt'],\n    'application/vnd.epson.ssf': ['ssf'],\n    'application/vnd.eszigno3+xml': ['es3', 'et3'],\n    'application/vnd.ezpix-album': ['ez2'],\n    'application/vnd.ezpix-package': ['ez3'],\n    'application/vnd.fdf': ['*fdf'],\n    'application/vnd.fdsn.mseed': ['mseed'],\n    'application/vnd.fdsn.seed': ['seed', 'dataless'],\n    'application/vnd.flographit': ['gph'],\n    'application/vnd.fluxtime.clip': ['ftc'],\n    'application/vnd.framemaker': ['fm', 'frame', 'maker', 'book'],\n    'application/vnd.frogans.fnc': ['fnc'],\n    'application/vnd.frogans.ltf': ['ltf'],\n    'application/vnd.fsc.weblaunch': ['fsc'],\n    'application/vnd.fujitsu.oasys': ['oas'],\n    'application/vnd.fujitsu.oasys2': ['oa2'],\n    'application/vnd.fujitsu.oasys3': ['oa3'],\n    'application/vnd.fujitsu.oasysgp': ['fg5'],\n    'application/vnd.fujitsu.oasysprs': ['bh2'],\n    'application/vnd.fujixerox.ddd': ['ddd'],\n    'application/vnd.fujixerox.docuworks': ['xdw'],\n    'application/vnd.fujixerox.docuworks.binder': ['xbd'],\n    'application/vnd.fuzzysheet': ['fzs'],\n    'application/vnd.genomatix.tuxedo': ['txd'],\n    'application/vnd.geogebra.file': ['ggb'],\n    'application/vnd.geogebra.tool': ['ggt'],\n    'application/vnd.geometry-explorer': ['gex', 'gre'],\n    'application/vnd.geonext': ['gxt'],\n    'application/vnd.geoplan': ['g2w'],\n    'application/vnd.geospace': ['g3w'],\n    'application/vnd.gmx': ['gmx'],\n    'application/vnd.google-apps.document': ['gdoc'],\n    'application/vnd.google-apps.presentation': ['gslides'],\n    'application/vnd.google-apps.spreadsheet': ['gsheet'],\n    'application/vnd.google-earth.kml+xml': ['kml'],\n    'application/vnd.google-earth.kmz': ['kmz'],\n    'application/vnd.grafeq': ['gqf', 'gqs'],\n    'application/vnd.groove-account': ['gac'],\n    'application/vnd.groove-help': ['ghf'],\n    'application/vnd.groove-identity-message': ['gim'],\n    'application/vnd.groove-injector': ['grv'],\n    'application/vnd.groove-tool-message': ['gtm'],\n    'application/vnd.groove-tool-template': ['tpl'],\n    'application/vnd.groove-vcard': ['vcg'],\n    'application/vnd.hal+xml': ['hal'],\n    'application/vnd.handheld-entertainment+xml': ['zmm'],\n    'application/vnd.hbci': ['hbci'],\n    'application/vnd.hhe.lesson-player': ['les'],\n    'application/vnd.hp-hpgl': ['hpgl'],\n    'application/vnd.hp-hpid': ['hpid'],\n    'application/vnd.hp-hps': ['hps'],\n    'application/vnd.hp-jlyt': ['jlt'],\n    'application/vnd.hp-pcl': ['pcl'],\n    'application/vnd.hp-pclxl': ['pclxl'],\n    'application/vnd.hydrostatix.sof-data': ['sfd-hdstx'],\n    'application/vnd.ibm.minipay': ['mpy'],\n    'application/vnd.ibm.modcap': ['afp', 'listafp', 'list3820'],\n    'application/vnd.ibm.rights-management': ['irm'],\n    'application/vnd.ibm.secure-container': ['sc'],\n    'application/vnd.iccprofile': ['icc', 'icm'],\n    'application/vnd.igloader': ['igl'],\n    'application/vnd.immervision-ivp': ['ivp'],\n    'application/vnd.immervision-ivu': ['ivu'],\n    'application/vnd.insors.igm': ['igm'],\n    'application/vnd.intercon.formnet': ['xpw', 'xpx'],\n    'application/vnd.intergeo': ['i2g'],\n    'application/vnd.intu.qbo': ['qbo'],\n    'application/vnd.intu.qfx': ['qfx'],\n    'application/vnd.ipunplugged.rcprofile': ['rcprofile'],\n    'application/vnd.irepository.package+xml': ['irp'],\n    'application/vnd.is-xpr': ['xpr'],\n    'application/vnd.isac.fcs': ['fcs'],\n    'application/vnd.jam': ['jam'],\n    'application/vnd.jcp.javame.midlet-rms': ['rms'],\n    'application/vnd.jisp': ['jisp'],\n    'application/vnd.joost.joda-archive': ['joda'],\n    'application/vnd.kahootz': ['ktz', 'ktr'],\n    'application/vnd.kde.karbon': ['karbon'],\n    'application/vnd.kde.kchart': ['chrt'],\n    'application/vnd.kde.kformula': ['kfo'],\n    'application/vnd.kde.kivio': ['flw'],\n    'application/vnd.kde.kontour': ['kon'],\n    'application/vnd.kde.kpresenter': ['kpr', 'kpt'],\n    'application/vnd.kde.kspread': ['ksp'],\n    'application/vnd.kde.kword': ['kwd', 'kwt'],\n    'application/vnd.kenameaapp': ['htke'],\n    'application/vnd.kidspiration': ['kia'],\n    'application/vnd.kinar': ['kne', 'knp'],\n    'application/vnd.koan': ['skp', 'skd', 'skt', 'skm'],\n    'application/vnd.kodak-descriptor': ['sse'],\n    'application/vnd.las.las+xml': ['lasxml'],\n    'application/vnd.llamagraphics.life-balance.desktop': ['lbd'],\n    'application/vnd.llamagraphics.life-balance.exchange+xml': ['lbe'],\n    'application/vnd.lotus-1-2-3': ['123'],\n    'application/vnd.lotus-approach': ['apr'],\n    'application/vnd.lotus-freelance': ['pre'],\n    'application/vnd.lotus-notes': ['nsf'],\n    'application/vnd.lotus-organizer': ['org'],\n    'application/vnd.lotus-screencam': ['scm'],\n    'application/vnd.lotus-wordpro': ['lwp'],\n    'application/vnd.macports.portpkg': ['portpkg'],\n    'application/vnd.mapbox-vector-tile': ['mvt'],\n    'application/vnd.mcd': ['mcd'],\n    'application/vnd.medcalcdata': ['mc1'],\n    'application/vnd.mediastation.cdkey': ['cdkey'],\n    'application/vnd.mfer': ['mwf'],\n    'application/vnd.mfmp': ['mfm'],\n    'application/vnd.micrografx.flo': ['flo'],\n    'application/vnd.micrografx.igx': ['igx'],\n    'application/vnd.mif': ['mif'],\n    'application/vnd.mobius.daf': ['daf'],\n    'application/vnd.mobius.dis': ['dis'],\n    'application/vnd.mobius.mbk': ['mbk'],\n    'application/vnd.mobius.mqy': ['mqy'],\n    'application/vnd.mobius.msl': ['msl'],\n    'application/vnd.mobius.plc': ['plc'],\n    'application/vnd.mobius.txf': ['txf'],\n    'application/vnd.mophun.application': ['mpn'],\n    'application/vnd.mophun.certificate': ['mpc'],\n    'application/vnd.mozilla.xul+xml': ['xul'],\n    'application/vnd.ms-artgalry': ['cil'],\n    'application/vnd.ms-cab-compressed': ['cab'],\n    'application/vnd.ms-excel': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],\n    'application/vnd.ms-excel.addin.macroenabled.12': ['xlam'],\n    'application/vnd.ms-excel.sheet.binary.macroenabled.12': ['xlsb'],\n    'application/vnd.ms-excel.sheet.macroenabled.12': ['xlsm'],\n    'application/vnd.ms-excel.template.macroenabled.12': ['xltm'],\n    'application/vnd.ms-fontobject': ['eot'],\n    'application/vnd.ms-htmlhelp': ['chm'],\n    'application/vnd.ms-ims': ['ims'],\n    'application/vnd.ms-lrm': ['lrm'],\n    'application/vnd.ms-officetheme': ['thmx'],\n    'application/vnd.ms-outlook': ['msg'],\n    'application/vnd.ms-pki.seccat': ['cat'],\n    'application/vnd.ms-pki.stl': ['*stl'],\n    'application/vnd.ms-powerpoint': ['ppt', 'pps', 'pot'],\n    'application/vnd.ms-powerpoint.addin.macroenabled.12': ['ppam'],\n    'application/vnd.ms-powerpoint.presentation.macroenabled.12': ['pptm'],\n    'application/vnd.ms-powerpoint.slide.macroenabled.12': ['sldm'],\n    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': ['ppsm'],\n    'application/vnd.ms-powerpoint.template.macroenabled.12': ['potm'],\n    'application/vnd.ms-project': ['*mpp', 'mpt'],\n    'application/vnd.ms-word.document.macroenabled.12': ['docm'],\n    'application/vnd.ms-word.template.macroenabled.12': ['dotm'],\n    'application/vnd.ms-works': ['wps', 'wks', 'wcm', 'wdb'],\n    'application/vnd.ms-wpl': ['wpl'],\n    'application/vnd.ms-xpsdocument': ['xps'],\n    'application/vnd.mseq': ['mseq'],\n    'application/vnd.musician': ['mus'],\n    'application/vnd.muvee.style': ['msty'],\n    'application/vnd.mynfc': ['taglet'],\n    'application/vnd.neurolanguage.nlu': ['nlu'],\n    'application/vnd.nitf': ['ntf', 'nitf'],\n    'application/vnd.noblenet-directory': ['nnd'],\n    'application/vnd.noblenet-sealer': ['nns'],\n    'application/vnd.noblenet-web': ['nnw'],\n    'application/vnd.nokia.n-gage.ac+xml': ['*ac'],\n    'application/vnd.nokia.n-gage.data': ['ngdat'],\n    'application/vnd.nokia.n-gage.symbian.install': ['n-gage'],\n    'application/vnd.nokia.radio-preset': ['rpst'],\n    'application/vnd.nokia.radio-presets': ['rpss'],\n    'application/vnd.novadigm.edm': ['edm'],\n    'application/vnd.novadigm.edx': ['edx'],\n    'application/vnd.novadigm.ext': ['ext'],\n    'application/vnd.oasis.opendocument.chart': ['odc'],\n    'application/vnd.oasis.opendocument.chart-template': ['otc'],\n    'application/vnd.oasis.opendocument.database': ['odb'],\n    'application/vnd.oasis.opendocument.formula': ['odf'],\n    'application/vnd.oasis.opendocument.formula-template': ['odft'],\n    'application/vnd.oasis.opendocument.graphics': ['odg'],\n    'application/vnd.oasis.opendocument.graphics-template': ['otg'],\n    'application/vnd.oasis.opendocument.image': ['odi'],\n    'application/vnd.oasis.opendocument.image-template': ['oti'],\n    'application/vnd.oasis.opendocument.presentation': ['odp'],\n    'application/vnd.oasis.opendocument.presentation-template': ['otp'],\n    'application/vnd.oasis.opendocument.spreadsheet': ['ods'],\n    'application/vnd.oasis.opendocument.spreadsheet-template': ['ots'],\n    'application/vnd.oasis.opendocument.text': ['odt'],\n    'application/vnd.oasis.opendocument.text-master': ['odm'],\n    'application/vnd.oasis.opendocument.text-template': ['ott'],\n    'application/vnd.oasis.opendocument.text-web': ['oth'],\n    'application/vnd.olpc-sugar': ['xo'],\n    'application/vnd.oma.dd2+xml': ['dd2'],\n    'application/vnd.openblox.game+xml': ['obgx'],\n    'application/vnd.openofficeorg.extension': ['oxt'],\n    'application/vnd.openstreetmap.data+xml': ['osm'],\n    'application/vnd.openxmlformats-officedocument.presentationml.presentation':\n        ['pptx'],\n    'application/vnd.openxmlformats-officedocument.presentationml.slide': [\n        'sldx',\n    ],\n    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': [\n        'ppsx',\n    ],\n    'application/vnd.openxmlformats-officedocument.presentationml.template': [\n        'potx',\n    ],\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': [\n        'xlsx',\n    ],\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': [\n        'xltx',\n    ],\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': [\n        'docx',\n    ],\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': [\n        'dotx',\n    ],\n    'application/vnd.osgeo.mapguide.package': ['mgp'],\n    'application/vnd.osgi.dp': ['dp'],\n    'application/vnd.osgi.subsystem': ['esa'],\n    'application/vnd.palm': ['pdb', 'pqa', 'oprc'],\n    'application/vnd.pawaafile': ['paw'],\n    'application/vnd.pg.format': ['str'],\n    'application/vnd.pg.osasli': ['ei6'],\n    'application/vnd.picsel': ['efif'],\n    'application/vnd.pmi.widget': ['wg'],\n    'application/vnd.pocketlearn': ['plf'],\n    'application/vnd.powerbuilder6': ['pbd'],\n    'application/vnd.previewsystems.box': ['box'],\n    'application/vnd.proteus.magazine': ['mgz'],\n    'application/vnd.publishare-delta-tree': ['qps'],\n    'application/vnd.pvi.ptid1': ['ptid'],\n    'application/vnd.pwg-xhtml-print+xml': ['xhtm'],\n    'application/vnd.quark.quarkxpress': [\n        'qxd',\n        'qxt',\n        'qwd',\n        'qwt',\n        'qxl',\n        'qxb',\n    ],\n    'application/vnd.rar': ['rar'],\n    'application/vnd.realvnc.bed': ['bed'],\n    'application/vnd.recordare.musicxml': ['mxl'],\n    'application/vnd.recordare.musicxml+xml': ['musicxml'],\n    'application/vnd.rig.cryptonote': ['cryptonote'],\n    'application/vnd.rim.cod': ['cod'],\n    'application/vnd.rn-realmedia': ['rm'],\n    'application/vnd.rn-realmedia-vbr': ['rmvb'],\n    'application/vnd.route66.link66+xml': ['link66'],\n    'application/vnd.sailingtracker.track': ['st'],\n    'application/vnd.seemail': ['see'],\n    'application/vnd.sema': ['sema'],\n    'application/vnd.semd': ['semd'],\n    'application/vnd.semf': ['semf'],\n    'application/vnd.shana.informed.formdata': ['ifm'],\n    'application/vnd.shana.informed.formtemplate': ['itp'],\n    'application/vnd.shana.informed.interchange': ['iif'],\n    'application/vnd.shana.informed.package': ['ipk'],\n    'application/vnd.simtech-mindmapper': ['twd', 'twds'],\n    'application/vnd.smaf': ['mmf'],\n    'application/vnd.smart.teacher': ['teacher'],\n    'application/vnd.software602.filler.form+xml': ['fo'],\n    'application/vnd.solent.sdkm+xml': ['sdkm', 'sdkd'],\n    'application/vnd.spotfire.dxp': ['dxp'],\n    'application/vnd.spotfire.sfs': ['sfs'],\n    'application/vnd.stardivision.calc': ['sdc'],\n    'application/vnd.stardivision.draw': ['sda'],\n    'application/vnd.stardivision.impress': ['sdd'],\n    'application/vnd.stardivision.math': ['smf'],\n    'application/vnd.stardivision.writer': ['sdw', 'vor'],\n    'application/vnd.stardivision.writer-global': ['sgl'],\n    'application/vnd.stepmania.package': ['smzip'],\n    'application/vnd.stepmania.stepchart': ['sm'],\n    'application/vnd.sun.wadl+xml': ['wadl'],\n    'application/vnd.sun.xml.calc': ['sxc'],\n    'application/vnd.sun.xml.calc.template': ['stc'],\n    'application/vnd.sun.xml.draw': ['sxd'],\n    'application/vnd.sun.xml.draw.template': ['std'],\n    'application/vnd.sun.xml.impress': ['sxi'],\n    'application/vnd.sun.xml.impress.template': ['sti'],\n    'application/vnd.sun.xml.math': ['sxm'],\n    'application/vnd.sun.xml.writer': ['sxw'],\n    'application/vnd.sun.xml.writer.global': ['sxg'],\n    'application/vnd.sun.xml.writer.template': ['stw'],\n    'application/vnd.sus-calendar': ['sus', 'susp'],\n    'application/vnd.svd': ['svd'],\n    'application/vnd.symbian.install': ['sis', 'sisx'],\n    'application/vnd.syncml+xml': ['xsm'],\n    'application/vnd.syncml.dm+wbxml': ['bdm'],\n    'application/vnd.syncml.dm+xml': ['xdm'],\n    'application/vnd.syncml.dmddf+xml': ['ddf'],\n    'application/vnd.tao.intent-module-archive': ['tao'],\n    'application/vnd.tcpdump.pcap': ['pcap', 'cap', 'dmp'],\n    'application/vnd.tmobile-livetv': ['tmo'],\n    'application/vnd.trid.tpt': ['tpt'],\n    'application/vnd.triscape.mxs': ['mxs'],\n    'application/vnd.trueapp': ['tra'],\n    'application/vnd.ufdl': ['ufd', 'ufdl'],\n    'application/vnd.uiq.theme': ['utz'],\n    'application/vnd.umajin': ['umj'],\n    'application/vnd.unity': ['unityweb'],\n    'application/vnd.uoml+xml': ['uoml', 'uo'],\n    'application/vnd.vcx': ['vcx'],\n    'application/vnd.visio': ['vsd', 'vst', 'vss', 'vsw'],\n    'application/vnd.visionary': ['vis'],\n    'application/vnd.vsf': ['vsf'],\n    'application/vnd.wap.wbxml': ['wbxml'],\n    'application/vnd.wap.wmlc': ['wmlc'],\n    'application/vnd.wap.wmlscriptc': ['wmlsc'],\n    'application/vnd.webturbo': ['wtb'],\n    'application/vnd.wolfram.player': ['nbp'],\n    'application/vnd.wordperfect': ['wpd'],\n    'application/vnd.wqd': ['wqd'],\n    'application/vnd.wt.stf': ['stf'],\n    'application/vnd.xara': ['xar'],\n    'application/vnd.xfdl': ['xfdl'],\n    'application/vnd.yamaha.hv-dic': ['hvd'],\n    'application/vnd.yamaha.hv-script': ['hvs'],\n    'application/vnd.yamaha.hv-voice': ['hvp'],\n    'application/vnd.yamaha.openscoreformat': ['osf'],\n    'application/vnd.yamaha.openscoreformat.osfpvg+xml': ['osfpvg'],\n    'application/vnd.yamaha.smaf-audio': ['saf'],\n    'application/vnd.yamaha.smaf-phrase': ['spf'],\n    'application/vnd.yellowriver-custom-menu': ['cmp'],\n    'application/vnd.zul': ['zir', 'zirz'],\n    'application/vnd.zzazz.deck+xml': ['zaz'],\n    'application/x-7z-compressed': ['7z'],\n    'application/x-abiword': ['abw'],\n    'application/x-ace-compressed': ['ace'],\n    'application/x-apple-diskimage': ['*dmg'],\n    'application/x-arj': ['arj'],\n    'application/x-authorware-bin': ['aab', 'x32', 'u32', 'vox'],\n    'application/x-authorware-map': ['aam'],\n    'application/x-authorware-seg': ['aas'],\n    'application/x-bcpio': ['bcpio'],\n    'application/x-bdoc': ['*bdoc'],\n    'application/x-bittorrent': ['torrent'],\n    'application/x-blorb': ['blb', 'blorb'],\n    'application/x-bzip': ['bz'],\n    'application/x-bzip2': ['bz2', 'boz'],\n    'application/x-cbr': ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],\n    'application/x-cdlink': ['vcd'],\n    'application/x-cfs-compressed': ['cfs'],\n    'application/x-chat': ['chat'],\n    'application/x-chess-pgn': ['pgn'],\n    'application/x-chrome-extension': ['crx'],\n    'application/x-cocoa': ['cco'],\n    'application/x-conference': ['nsc'],\n    'application/x-cpio': ['cpio'],\n    'application/x-csh': ['csh'],\n    'application/x-debian-package': ['*deb', 'udeb'],\n    'application/x-dgc-compressed': ['dgc'],\n    'application/x-director': [\n        'dir',\n        'dcr',\n        'dxr',\n        'cst',\n        'cct',\n        'cxt',\n        'w3d',\n        'fgd',\n        'swa',\n    ],\n    'application/x-doom': ['wad'],\n    'application/x-dtbncx+xml': ['ncx'],\n    'application/x-dtbook+xml': ['dtb'],\n    'application/x-dtbresource+xml': ['res'],\n    'application/x-dvi': ['dvi'],\n    'application/x-envoy': ['evy'],\n    'application/x-eva': ['eva'],\n    'application/x-font-bdf': ['bdf'],\n    'application/x-font-ghostscript': ['gsf'],\n    'application/x-font-linux-psf': ['psf'],\n    'application/x-font-pcf': ['pcf'],\n    'application/x-font-snf': ['snf'],\n    'application/x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],\n    'application/x-freearc': ['arc'],\n    'application/x-futuresplash': ['spl'],\n    'application/x-gca-compressed': ['gca'],\n    'application/x-glulx': ['ulx'],\n    'application/x-gnumeric': ['gnumeric'],\n    'application/x-gramps-xml': ['gramps'],\n    'application/x-gtar': ['gtar'],\n    'application/x-hdf': ['hdf'],\n    'application/x-httpd-php': ['php'],\n    'application/x-install-instructions': ['install'],\n    'application/x-iso9660-image': ['*iso'],\n    'application/x-iwork-keynote-sffkey': ['*key'],\n    'application/x-iwork-numbers-sffnumbers': ['*numbers'],\n    'application/x-iwork-pages-sffpages': ['*pages'],\n    'application/x-java-archive-diff': ['jardiff'],\n    'application/x-java-jnlp-file': ['jnlp'],\n    'application/x-keepass2': ['kdbx'],\n    'application/x-latex': ['latex'],\n    'application/x-lua-bytecode': ['luac'],\n    'application/x-lzh-compressed': ['lzh', 'lha'],\n    'application/x-makeself': ['run'],\n    'application/x-mie': ['mie'],\n    'application/x-mobipocket-ebook': ['*prc', 'mobi'],\n    'application/x-ms-application': ['application'],\n    'application/x-ms-shortcut': ['lnk'],\n    'application/x-ms-wmd': ['wmd'],\n    'application/x-ms-wmz': ['wmz'],\n    'application/x-ms-xbap': ['xbap'],\n    'application/x-msaccess': ['mdb'],\n    'application/x-msbinder': ['obd'],\n    'application/x-mscardfile': ['crd'],\n    'application/x-msclip': ['clp'],\n    'application/x-msdos-program': ['*exe'],\n    'application/x-msdownload': ['*exe', '*dll', 'com', 'bat', '*msi'],\n    'application/x-msmediaview': ['mvb', 'm13', 'm14'],\n    'application/x-msmetafile': ['*wmf', '*wmz', '*emf', 'emz'],\n    'application/x-msmoney': ['mny'],\n    'application/x-mspublisher': ['pub'],\n    'application/x-msschedule': ['scd'],\n    'application/x-msterminal': ['trm'],\n    'application/x-mswrite': ['wri'],\n    'application/x-netcdf': ['nc', 'cdf'],\n    'application/x-ns-proxy-autoconfig': ['pac'],\n    'application/x-nzb': ['nzb'],\n    'application/x-perl': ['pl', 'pm'],\n    'application/x-pilot': ['*prc', '*pdb'],\n    'application/x-pkcs12': ['p12', 'pfx'],\n    'application/x-pkcs7-certificates': ['p7b', 'spc'],\n    'application/x-pkcs7-certreqresp': ['p7r'],\n    'application/x-rar-compressed': ['*rar'],\n    'application/x-redhat-package-manager': ['rpm'],\n    'application/x-research-info-systems': ['ris'],\n    'application/x-sea': ['sea'],\n    'application/x-sh': ['sh'],\n    'application/x-shar': ['shar'],\n    'application/x-shockwave-flash': ['swf'],\n    'application/x-silverlight-app': ['xap'],\n    'application/x-sql': ['*sql'],\n    'application/x-stuffit': ['sit'],\n    'application/x-stuffitx': ['sitx'],\n    'application/x-subrip': ['srt'],\n    'application/x-sv4cpio': ['sv4cpio'],\n    'application/x-sv4crc': ['sv4crc'],\n    'application/x-t3vm-image': ['t3'],\n    'application/x-tads': ['gam'],\n    'application/x-tar': ['tar'],\n    'application/x-tcl': ['tcl', 'tk'],\n    'application/x-tex': ['tex'],\n    'application/x-tex-tfm': ['tfm'],\n    'application/x-texinfo': ['texinfo', 'texi'],\n    'application/x-tgif': ['*obj'],\n    'application/x-ustar': ['ustar'],\n    'application/x-virtualbox-hdd': ['hdd'],\n    'application/x-virtualbox-ova': ['ova'],\n    'application/x-virtualbox-ovf': ['ovf'],\n    'application/x-virtualbox-vbox': ['vbox'],\n    'application/x-virtualbox-vbox-extpack': ['vbox-extpack'],\n    'application/x-virtualbox-vdi': ['vdi'],\n    'application/x-virtualbox-vhd': ['vhd'],\n    'application/x-virtualbox-vmdk': ['vmdk'],\n    'application/x-wais-source': ['src'],\n    'application/x-web-app-manifest+json': ['webapp'],\n    'application/x-x509-ca-cert': ['der', 'crt', 'pem'],\n    'application/x-xfig': ['fig'],\n    'application/x-xliff+xml': ['*xlf'],\n    'application/x-xpinstall': ['xpi'],\n    'application/x-xz': ['xz'],\n    'application/x-zmachine': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],\n    'audio/vnd.dece.audio': ['uva', 'uvva'],\n    'audio/vnd.digital-winds': ['eol'],\n    'audio/vnd.dra': ['dra'],\n    'audio/vnd.dts': ['dts'],\n    'audio/vnd.dts.hd': ['dtshd'],\n    'audio/vnd.lucent.voice': ['lvp'],\n    'audio/vnd.ms-playready.media.pya': ['pya'],\n    'audio/vnd.nuera.ecelp4800': ['ecelp4800'],\n    'audio/vnd.nuera.ecelp7470': ['ecelp7470'],\n    'audio/vnd.nuera.ecelp9600': ['ecelp9600'],\n    'audio/vnd.rip': ['rip'],\n    'audio/x-aac': ['*aac'],\n    'audio/x-aiff': ['aif', 'aiff', 'aifc'],\n    'audio/x-caf': ['caf'],\n    'audio/x-flac': ['flac'],\n    'audio/x-m4a': ['*m4a'],\n    'audio/x-matroska': ['mka'],\n    'audio/x-mpegurl': ['m3u'],\n    'audio/x-ms-wax': ['wax'],\n    'audio/x-ms-wma': ['wma'],\n    'audio/x-pn-realaudio': ['ram', 'ra'],\n    'audio/x-pn-realaudio-plugin': ['rmp'],\n    'audio/x-realaudio': ['*ra'],\n    'audio/x-wav': ['*wav'],\n    'chemical/x-cdx': ['cdx'],\n    'chemical/x-cif': ['cif'],\n    'chemical/x-cmdf': ['cmdf'],\n    'chemical/x-cml': ['cml'],\n    'chemical/x-csml': ['csml'],\n    'chemical/x-xyz': ['xyz'],\n    'image/prs.btif': ['btif', 'btf'],\n    'image/prs.pti': ['pti'],\n    'image/vnd.adobe.photoshop': ['psd'],\n    'image/vnd.airzip.accelerator.azv': ['azv'],\n    'image/vnd.dece.graphic': ['uvi', 'uvvi', 'uvg', 'uvvg'],\n    'image/vnd.djvu': ['djvu', 'djv'],\n    'image/vnd.dvb.subtitle': ['*sub'],\n    'image/vnd.dwg': ['dwg'],\n    'image/vnd.dxf': ['dxf'],\n    'image/vnd.fastbidsheet': ['fbs'],\n    'image/vnd.fpx': ['fpx'],\n    'image/vnd.fst': ['fst'],\n    'image/vnd.fujixerox.edmics-mmr': ['mmr'],\n    'image/vnd.fujixerox.edmics-rlc': ['rlc'],\n    'image/vnd.microsoft.icon': ['ico'],\n    'image/vnd.ms-dds': ['dds'],\n    'image/vnd.ms-modi': ['mdi'],\n    'image/vnd.ms-photo': ['wdp'],\n    'image/vnd.net-fpx': ['npx'],\n    'image/vnd.pco.b16': ['b16'],\n    'image/vnd.tencent.tap': ['tap'],\n    'image/vnd.valve.source.texture': ['vtf'],\n    'image/vnd.wap.wbmp': ['wbmp'],\n    'image/vnd.xiff': ['xif'],\n    'image/vnd.zbrush.pcx': ['pcx'],\n    'image/x-3ds': ['3ds'],\n    'image/x-cmu-raster': ['ras'],\n    'image/x-cmx': ['cmx'],\n    'image/x-freehand': ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],\n    'image/x-icon': ['*ico'],\n    'image/x-jng': ['jng'],\n    'image/x-mrsid-image': ['sid'],\n    'image/x-ms-bmp': ['*bmp'],\n    'image/x-pcx': ['*pcx'],\n    'image/x-pict': ['pic', 'pct'],\n    'image/x-portable-anymap': ['pnm'],\n    'image/x-portable-bitmap': ['pbm'],\n    'image/x-portable-graymap': ['pgm'],\n    'image/x-portable-pixmap': ['ppm'],\n    'image/x-rgb': ['rgb'],\n    'image/x-tga': ['tga'],\n    'image/x-xbitmap': ['xbm'],\n    'image/x-xpixmap': ['xpm'],\n    'image/x-xwindowdump': ['xwd'],\n    'message/vnd.wfa.wsc': ['wsc'],\n    'model/vnd.cld': ['cld'],\n    'model/vnd.collada+xml': ['dae'],\n    'model/vnd.dwf': ['dwf'],\n    'model/vnd.gdl': ['gdl'],\n    'model/vnd.gtw': ['gtw'],\n    'model/vnd.mts': ['mts'],\n    'model/vnd.opengex': ['ogex'],\n    'model/vnd.parasolid.transmit.binary': ['x_b'],\n    'model/vnd.parasolid.transmit.text': ['x_t'],\n    'model/vnd.pytha.pyox': ['pyo', 'pyox'],\n    'model/vnd.sap.vds': ['vds'],\n    'model/vnd.usda': ['usda'],\n    'model/vnd.usdz+zip': ['usdz'],\n    'model/vnd.valve.source.compiled-map': ['bsp'],\n    'model/vnd.vtu': ['vtu'],\n    'text/prs.lines.tag': ['dsc'],\n    'text/vnd.curl': ['curl'],\n    'text/vnd.curl.dcurl': ['dcurl'],\n    'text/vnd.curl.mcurl': ['mcurl'],\n    'text/vnd.curl.scurl': ['scurl'],\n    'text/vnd.dvb.subtitle': ['sub'],\n    'text/vnd.familysearch.gedcom': ['ged'],\n    'text/vnd.fly': ['fly'],\n    'text/vnd.fmi.flexstor': ['flx'],\n    'text/vnd.graphviz': ['gv'],\n    'text/vnd.in3d.3dml': ['3dml'],\n    'text/vnd.in3d.spot': ['spot'],\n    'text/vnd.sun.j2me.app-descriptor': ['jad'],\n    'text/vnd.wap.wml': ['wml'],\n    'text/vnd.wap.wmlscript': ['wmls'],\n    'text/x-asm': ['s', 'asm'],\n    'text/x-c': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],\n    'text/x-component': ['htc'],\n    'text/x-fortran': ['f', 'for', 'f77', 'f90'],\n    'text/x-handlebars-template': ['hbs'],\n    'text/x-java-source': ['java'],\n    'text/x-lua': ['lua'],\n    'text/x-markdown': ['mkd'],\n    'text/x-nfo': ['nfo'],\n    'text/x-opml': ['opml'],\n    'text/x-org': ['*org'],\n    'text/x-pascal': ['p', 'pas'],\n    'text/x-processing': ['pde'],\n    'text/x-sass': ['sass'],\n    'text/x-scss': ['scss'],\n    'text/x-setext': ['etx'],\n    'text/x-sfv': ['sfv'],\n    'text/x-suse-ymp': ['ymp'],\n    'text/x-uuencode': ['uu'],\n    'text/x-vcalendar': ['vcs'],\n    'text/x-vcard': ['vcf'],\n    'video/vnd.dece.hd': ['uvh', 'uvvh'],\n    'video/vnd.dece.mobile': ['uvm', 'uvvm'],\n    'video/vnd.dece.pd': ['uvp', 'uvvp'],\n    'video/vnd.dece.sd': ['uvs', 'uvvs'],\n    'video/vnd.dece.video': ['uvv', 'uvvv'],\n    'video/vnd.dvb.file': ['dvb'],\n    'video/vnd.fvt': ['fvt'],\n    'video/vnd.mpegurl': ['mxu', 'm4u'],\n    'video/vnd.ms-playready.media.pyv': ['pyv'],\n    'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],\n    'video/vnd.vivo': ['viv'],\n    'video/x-f4v': ['f4v'],\n    'video/x-fli': ['fli'],\n    'video/x-flv': ['flv'],\n    'video/x-m4v': ['m4v'],\n    'video/x-matroska': ['mkv', 'mk3d', 'mks'],\n    'video/x-mng': ['mng'],\n    'video/x-ms-asf': ['asf', 'asx'],\n    'video/x-ms-vob': ['vob'],\n    'video/x-ms-wm': ['wm'],\n    'video/x-ms-wmv': ['wmv'],\n    'video/x-ms-wmx': ['wmx'],\n    'video/x-ms-wvx': ['wvx'],\n    'video/x-msvideo': ['avi'],\n    'video/x-sgi-movie': ['movie'],\n    'video/x-smv': ['smv'],\n    'x-conference/x-cooltalk': ['ice'],\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/server-static/types/standard.ts",
    "type": "Constant",
    "value": "types",
    "snippet": "const types: { [key: string]: string[] } = {\n    'application/andrew-inset': ['ez'],\n    'application/appinstaller': ['appinstaller'],\n    'application/applixware': ['aw'],\n    'application/appx': ['appx'],\n    'application/appxbundle': ['appxbundle'],\n    'application/atom+xml': ['atom'],\n    'application/atomcat+xml': ['atomcat'],\n    'application/atomdeleted+xml': ['atomdeleted'],\n    'application/atomsvc+xml': ['atomsvc'],\n    'application/atsc-dwd+xml': ['dwd'],\n    'application/atsc-held+xml': ['held'],\n    'application/atsc-rsat+xml': ['rsat'],\n    'application/automationml-aml+xml': ['aml'],\n    'application/automationml-amlx+zip': ['amlx'],\n    'application/bdoc': ['bdoc'],\n    'application/calendar+xml': ['xcs'],\n    'application/ccxml+xml': ['ccxml'],\n    'application/cdfx+xml': ['cdfx'],\n    'application/cdmi-capability': ['cdmia'],\n    'application/cdmi-container': ['cdmic'],\n    'application/cdmi-domain': ['cdmid'],\n    'application/cdmi-object': ['cdmio'],\n    'application/cdmi-queue': ['cdmiq'],\n    'application/cpl+xml': ['cpl'],\n    'application/cu-seeme': ['cu'],\n    'application/cwl': ['cwl'],\n    'application/dash+xml': ['mpd'],\n    'application/dash-patch+xml': ['mpp'],\n    'application/davmount+xml': ['davmount'],\n    'application/docbook+xml': ['dbk'],\n    'application/dssc+der': ['dssc'],\n    'application/dssc+xml': ['xdssc'],\n    'application/ecmascript': ['ecma'],\n    'application/emma+xml': ['emma'],\n    'application/emotionml+xml': ['emotionml'],\n    'application/epub+zip': ['epub'],\n    'application/exi': ['exi'],\n    'application/express': ['exp'],\n    'application/fdf': ['fdf'],\n    'application/fdt+xml': ['fdt'],\n    'application/font-tdpfr': ['pfr'],\n    'application/geo+json': ['geojson'],\n    'application/gml+xml': ['gml'],\n    'application/gpx+xml': ['gpx'],\n    'application/gxf': ['gxf'],\n    'application/gzip': ['gz'],\n    'application/hjson': ['hjson'],\n    'application/hyperstudio': ['stk'],\n    'application/inkml+xml': ['ink', 'inkml'],\n    'application/ipfix': ['ipfix'],\n    'application/its+xml': ['its'],\n    'application/java-archive': ['jar', 'war', 'ear'],\n    'application/java-serialized-object': ['ser'],\n    'application/java-vm': ['class'],\n    'application/javascript': ['*js'],\n    'application/json': ['json', 'map'],\n    'application/json5': ['json5'],\n    'application/jsonml+json': ['jsonml'],\n    'application/ld+json': ['jsonld'],\n    'application/lgr+xml': ['lgr'],\n    'application/lost+xml': ['lostxml'],\n    'application/mac-binhex40': ['hqx'],\n    'application/mac-compactpro': ['cpt'],\n    'application/mads+xml': ['mads'],\n    'application/manifest+json': ['webmanifest'],\n    'application/marc': ['mrc'],\n    'application/marcxml+xml': ['mrcx'],\n    'application/mathematica': ['ma', 'nb', 'mb'],\n    'application/mathml+xml': ['mathml'],\n    'application/mbox': ['mbox'],\n    'application/media-policy-dataset+xml': ['mpf'],\n    'application/mediaservercontrol+xml': ['mscml'],\n    'application/metalink+xml': ['metalink'],\n    'application/metalink4+xml': ['meta4'],\n    'application/mets+xml': ['mets'],\n    'application/mmt-aei+xml': ['maei'],\n    'application/mmt-usd+xml': ['musd'],\n    'application/mods+xml': ['mods'],\n    'application/mp21': ['m21', 'mp21'],\n    'application/mp4': ['*mp4', '*mpg4', 'mp4s', 'm4p'],\n    'application/msix': ['msix'],\n    'application/msixbundle': ['msixbundle'],\n    'application/msword': ['doc', 'dot'],\n    'application/mxf': ['mxf'],\n    'application/n-quads': ['nq'],\n    'application/n-triples': ['nt'],\n    'application/node': ['cjs'],\n    'application/octet-stream': [\n        'bin',\n        'dms',\n        'lrf',\n        'mar',\n        'so',\n        'dist',\n        'distz',\n        'pkg',\n        'bpk',\n        'dump',\n        'elc',\n        'deploy',\n        'exe',\n        'dll',\n        'deb',\n        'dmg',\n        'iso',\n        'img',\n        'msi',\n        'msp',\n        'msm',\n        'buffer',\n    ],\n    'application/oda': ['oda'],\n    'application/oebps-package+xml': ['opf'],\n    'application/ogg': ['ogx'],\n    'application/omdoc+xml': ['omdoc'],\n    'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],\n    'application/oxps': ['oxps'],\n    'application/p2p-overlay+xml': ['relo'],\n    'application/patch-ops-error+xml': ['xer'],\n    'application/pdf': ['pdf'],\n    'application/pgp-encrypted': ['pgp'],\n    'application/pgp-keys': ['asc'],\n    'application/pgp-signature': ['sig', '*asc'],\n    'application/pics-rules': ['prf'],\n    'application/pkcs10': ['p10'],\n    'application/pkcs7-mime': ['p7m', 'p7c'],\n    'application/pkcs7-signature': ['p7s'],\n    'application/pkcs8': ['p8'],\n    'application/pkix-attr-cert': ['ac'],\n    'application/pkix-cert': ['cer'],\n    'application/pkix-crl': ['crl'],\n    'application/pkix-pkipath': ['pkipath'],\n    'application/pkixcmp': ['pki'],\n    'application/pls+xml': ['pls'],\n    'application/postscript': ['ai', 'eps', 'ps'],\n    'application/provenance+xml': ['provx'],\n    'application/pskc+xml': ['pskcxml'],\n    'application/raml+yaml': ['raml'],\n    'application/rdf+xml': ['rdf', 'owl'],\n    'application/reginfo+xml': ['rif'],\n    'application/relax-ng-compact-syntax': ['rnc'],\n    'application/resource-lists+xml': ['rl'],\n    'application/resource-lists-diff+xml': ['rld'],\n    'application/rls-services+xml': ['rs'],\n    'application/route-apd+xml': ['rapd'],\n    'application/route-s-tsid+xml': ['sls'],\n    'application/route-usd+xml': ['rusd'],\n    'application/rpki-ghostbusters': ['gbr'],\n    'application/rpki-manifest': ['mft'],\n    'application/rpki-roa': ['roa'],\n    'application/rsd+xml': ['rsd'],\n    'application/rss+xml': ['rss'],\n    'application/rtf': ['rtf'],\n    'application/sbml+xml': ['sbml'],\n    'application/scvp-cv-request': ['scq'],\n    'application/scvp-cv-response': ['scs'],\n    'application/scvp-vp-request': ['spq'],\n    'application/scvp-vp-response': ['spp'],\n    'application/sdp': ['sdp'],\n    'application/senml+xml': ['senmlx'],\n    'application/sensml+xml': ['sensmlx'],\n    'application/set-payment-initiation': ['setpay'],\n    'application/set-registration-initiation': ['setreg'],\n    'application/shf+xml': ['shf'],\n    'application/sieve': ['siv', 'sieve'],\n    'application/smil+xml': ['smi', 'smil'],\n    'application/sparql-query': ['rq'],\n    'application/sparql-results+xml': ['srx'],\n    'application/sql': ['sql'],\n    'application/srgs': ['gram'],\n    'application/srgs+xml': ['grxml'],\n    'application/sru+xml': ['sru'],\n    'application/ssdl+xml': ['ssdl'],\n    'application/ssml+xml': ['ssml'],\n    'application/swid+xml': ['swidtag'],\n    'application/tei+xml': ['tei', 'teicorpus'],\n    'application/thraud+xml': ['tfi'],\n    'application/timestamped-data': ['tsd'],\n    'application/toml': ['toml'],\n    'application/trig': ['trig'],\n    'application/ttml+xml': ['ttml'],\n    'application/ubjson': ['ubj'],\n    'application/urc-ressheet+xml': ['rsheet'],\n    'application/urc-targetdesc+xml': ['td'],\n    'application/voicexml+xml': ['vxml'],\n    'application/wasm': ['wasm'],\n    'application/watcherinfo+xml': ['wif'],\n    'application/widget': ['wgt'],\n    'application/winhlp': ['hlp'],\n    'application/wsdl+xml': ['wsdl'],\n    'application/wspolicy+xml': ['wspolicy'],\n    'application/xaml+xml': ['xaml'],\n    'application/xcap-att+xml': ['xav'],\n    'application/xcap-caps+xml': ['xca'],\n    'application/xcap-diff+xml': ['xdf'],\n    'application/xcap-el+xml': ['xel'],\n    'application/xcap-ns+xml': ['xns'],\n    'application/xenc+xml': ['xenc'],\n    'application/xfdf': ['xfdf'],\n    'application/xhtml+xml': ['xhtml', 'xht'],\n    'application/xliff+xml': ['xlf'],\n    'application/xml': ['xml', 'xsl', 'xsd', 'rng'],\n    'application/xml-dtd': ['dtd'],\n    'application/xop+xml': ['xop'],\n    'application/xproc+xml': ['xpl'],\n    'application/xslt+xml': ['*xsl', 'xslt'],\n    'application/xspf+xml': ['xspf'],\n    'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],\n    'application/yang': ['yang'],\n    'application/yin+xml': ['yin'],\n    'application/zip': ['zip'],\n    'audio/3gpp': ['*3gpp'],\n    'audio/aac': ['adts', 'aac'],\n    'audio/adpcm': ['adp'],\n    'audio/amr': ['amr'],\n    'audio/basic': ['au', 'snd'],\n    'audio/midi': ['mid', 'midi', 'kar', 'rmi'],\n    'audio/mobile-xmf': ['mxmf'],\n    'audio/mp3': ['*mp3'],\n    'audio/mp4': ['m4a', 'mp4a'],\n    'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],\n    'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],\n    'audio/s3m': ['s3m'],\n    'audio/silk': ['sil'],\n    'audio/wav': ['wav'],\n    'audio/wave': ['*wav'],\n    'audio/webm': ['weba'],\n    'audio/xm': ['xm'],\n    'font/collection': ['ttc'],\n    'font/otf': ['otf'],\n    'font/ttf': ['ttf'],\n    'font/woff': ['woff'],\n    'font/woff2': ['woff2'],\n    'image/aces': ['exr'],\n    'image/apng': ['apng'],\n    'image/avci': ['avci'],\n    'image/avcs': ['avcs'],\n    'image/avif': ['avif'],\n    'image/bmp': ['bmp', 'dib'],\n    'image/cgm': ['cgm'],\n    'image/dicom-rle': ['drle'],\n    'image/dpx': ['dpx'],\n    'image/emf': ['emf'],\n    'image/fits': ['fits'],\n    'image/g3fax': ['g3'],\n    'image/gif': ['gif'],\n    'image/heic': ['heic'],\n    'image/heic-sequence': ['heics'],\n    'image/heif': ['heif'],\n    'image/heif-sequence': ['heifs'],\n    'image/hej2k': ['hej2'],\n    'image/hsj2': ['hsj2'],\n    'image/ief': ['ief'],\n    'image/jls': ['jls'],\n    'image/jp2': ['jp2', 'jpg2'],\n    'image/jpeg': ['jpeg', 'jpg', 'jpe'],\n    'image/jph': ['jph'],\n    'image/jphc': ['jhc'],\n    'image/jpm': ['jpm', 'jpgm'],\n    'image/jpx': ['jpx', 'jpf'],\n    'image/jxr': ['jxr'],\n    'image/jxra': ['jxra'],\n    'image/jxrs': ['jxrs'],\n    'image/jxs': ['jxs'],\n    'image/jxsc': ['jxsc'],\n    'image/jxsi': ['jxsi'],\n    'image/jxss': ['jxss'],\n    'image/ktx': ['ktx'],\n    'image/ktx2': ['ktx2'],\n    'image/png': ['png'],\n    'image/sgi': ['sgi'],\n    'image/svg+xml': ['svg', 'svgz'],\n    'image/t38': ['t38'],\n    'image/tiff': ['tif', 'tiff'],\n    'image/tiff-fx': ['tfx'],\n    'image/webp': ['webp'],\n    'image/wmf': ['wmf'],\n    'message/disposition-notification': ['disposition-notification'],\n    'message/global': ['u8msg'],\n    'message/global-delivery-status': ['u8dsn'],\n    'message/global-disposition-notification': ['u8mdn'],\n    'message/global-headers': ['u8hdr'],\n    'message/rfc822': ['eml', 'mime'],\n    'model/3mf': ['3mf'],\n    'model/gltf+json': ['gltf'],\n    'model/gltf-binary': ['glb'],\n    'model/iges': ['igs', 'iges'],\n    'model/jt': ['jt'],\n    'model/mesh': ['msh', 'mesh', 'silo'],\n    'model/mtl': ['mtl'],\n    'model/obj': ['obj'],\n    'model/prc': ['prc'],\n    'model/step+xml': ['stpx'],\n    'model/step+zip': ['stpz'],\n    'model/step-xml+zip': ['stpxz'],\n    'model/stl': ['stl'],\n    'model/u3d': ['u3d'],\n    'model/vrml': ['wrl', 'vrml'],\n    'model/x3d+binary': ['*x3db', 'x3dbz'],\n    'model/x3d+fastinfoset': ['x3db'],\n    'model/x3d+vrml': ['*x3dv', 'x3dvz'],\n    'model/x3d+xml': ['x3d', 'x3dz'],\n    'model/x3d-vrml': ['x3dv'],\n    'text/cache-manifest': ['appcache', 'manifest'],\n    'text/calendar': ['ics', 'ifb'],\n    'text/coffeescript': ['coffee', 'litcoffee'],\n    'text/css': ['css'],\n    'text/csv': ['csv'],\n    'text/html': ['html', 'htm', 'shtml'],\n    'text/jade': ['jade'],\n    'text/javascript': ['js', 'mjs'],\n    'text/jsx': ['jsx'],\n    'text/less': ['less'],\n    'text/markdown': ['md', 'markdown'],\n    'text/mathml': ['mml'],\n    'text/mdx': ['mdx'],\n    'text/n3': ['n3'],\n    'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],\n    'text/richtext': ['rtx'],\n    'text/rtf': ['*rtf'],\n    'text/sgml': ['sgml', 'sgm'],\n    'text/shex': ['shex'],\n    'text/slim': ['slim', 'slm'],\n    'text/spdx': ['spdx'],\n    'text/stylus': ['stylus', 'styl'],\n    'text/tab-separated-values': ['tsv'],\n    'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],\n    'text/turtle': ['ttl'],\n    'text/uri-list': ['uri', 'uris', 'urls'],\n    'text/vcard': ['vcard'],\n    'text/vtt': ['vtt'],\n    'text/wgsl': ['wgsl'],\n    'text/xml': ['*xml'],\n    'text/yaml': ['yaml', 'yml'],\n    'video/3gpp': ['3gp', '3gpp'],\n    'video/3gpp2': ['3g2'],\n    'video/h261': ['h261'],\n    'video/h263': ['h263'],\n    'video/h264': ['h264'],\n    'video/iso.segment': ['m4s'],\n    'video/jpeg': ['jpgv'],\n    'video/jpm': ['*jpm', '*jpgm'],\n    'video/mj2': ['mj2', 'mjp2'],\n    'video/mp2t': ['ts'],\n    'video/mp4': ['mp4', 'mp4v', 'mpg4'],\n    'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],\n    'video/ogg': ['ogv'],\n    'video/quicktime': ['qt', 'mov'],\n    'video/webm': ['webm'],\n};"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/cookie.ts",
    "type": "Class",
    "value": "Cookie",
    "snippet": "class Cookie {\r\n    public path: string = \"/\";\r\n    public originalMaxAge: number | null = null;\r\n    public httpOnly: boolean = true;\r\n    public partitioned?: boolean;\r\n    public priority?: \"low\" | \"medium\" | \"high\" = \"low\";\r\n    public sameSite?: boolean | \"lax\" | \"none\" | \"strict\" = false;\r\n    public secure?: boolean = false;\r\n    public domain?: string;\r\n\r\n    constructor(options){\r\n        if (options) {\r\n            if (typeof options !== 'object') \r\n                throw new TypeError('argument options must be a object')\r\n                \r\n            for (var key in options) {\r\n                if (key !== 'data') \r\n                    this[key] = options[key]\r\n            }\r\n        }\r\n\r\n        if (this.originalMaxAge === undefined || this.originalMaxAge === null) \r\n            this.originalMaxAge = this.maxAge;\r\n    }\r\n\r\n    private _expires;\r\n\r\n    /**\r\n     * Set expires `date`.\r\n     *\r\n     * @param {Date} date\r\n     * @api public\r\n     */\r\n    set expires(date){\r\n        this._expires = date;\r\n        this.originalMaxAge = this.maxAge;\r\n    }\r\n\r\n    /**\r\n     * Get expires `date`.\r\n     *\r\n     * @return {Date}\r\n     * @api public\r\n     */\r\n    get expires() {\r\n        return this._expires;\r\n    }\r\n\r\n    /**\r\n     * Set expires via max-age in `ms`.\r\n     *\r\n     * @param {Number} ms\r\n     * @api public\r\n     */\r\n    set maxAge(ms) {\r\n        if (ms && typeof ms !== 'number' && !(ms instanceof Date)) {\r\n            throw new TypeError('maxAge must be a number or Date')\r\n        }\r\n\r\n        this.expires = typeof ms === 'number'\r\n        ? new Date(Date.now() + ms)\r\n        : ms;\r\n    }\r\n\r\n    /**\r\n     * Get expires max-age in `ms`.\r\n     *\r\n     * @return {Number}\r\n     * @api public\r\n     */\r\n    get maxAge() {\r\n        return this.expires instanceof Date\r\n        ? this.expires.valueOf() - Date.now()\r\n        : this.expires;\r\n    }\r\n\r\n    /**\r\n     * Return cookie data object.\r\n     *\r\n     * @return {Object}\r\n     * @api private\r\n     */\r\n    get data() {\r\n        return {\r\n          originalMaxAge: this.originalMaxAge,\r\n          partitioned: this.partitioned,\r\n          priority: this.priority\r\n          , expires: this._expires\r\n          , secure: this.secure\r\n          , httpOnly: this.httpOnly\r\n          , domain: this.domain\r\n          , path: this.path\r\n          , sameSite: this.sameSite\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a serialized cookie string.\r\n     *\r\n     * @return {String}\r\n     * @api public\r\n     */\r\n    serialize(name: string, val: string) {\r\n        return cookie.serialize(name, val, this.data);\r\n    }\r\n\r\n     /**\r\n     * Return JSON representation of this cookie.\r\n     *\r\n     * @return {Object}\r\n     * @api private\r\n     */\r\n    toJSON() {\r\n        return this.data;\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/memory.ts",
    "type": "Class",
    "value": "MemoryStore",
    "snippet": "class MemoryStore extends EventEmitter {\r\n    constructor(private readonly options?: any){\r\n        super();\r\n    }\r\n\r\n    \r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/session.ts",
    "type": "Class",
    "value": "Session",
    "snippet": "class Session {\r\n    public cookie: Cookie;\r\n\r\n    constructor(req, data?){\r\n        if (typeof data === 'object' && data !== null) {\r\n            for (var prop in data) {\r\n                if (!(prop in this)) \r\n                    this[prop] = data[prop];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _req;\r\n    set req(req){\r\n        this._req = req;\r\n    }\r\n\r\n    get req(){\r\n        return this._req;\r\n    }\r\n\r\n    private _id;\r\n    set id(id){\r\n        this._id = id;\r\n    }\r\n\r\n    get id(){\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * Update reset `.cookie.maxAge` to prevent\r\n     * the cookie from expiring when the\r\n     * session is still active.\r\n     *\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    touch(){\r\n        return this.resetMaxAge();\r\n    }\r\n\r\n    /**\r\n     * Reset `.maxAge` to `.originalMaxAge`.\r\n     *\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    resetMaxAge(){\r\n        this.cookie.maxAge = this.cookie.originalMaxAge;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Save the session data with optional callback `fn(err)`.\r\n     *\r\n     * @param {Function} fn\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    save(fn){\r\n        this.req.sessionStore.set(this.id, this, fn || function(){});\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Re-loads the session data _without_ altering\r\n     * the maxAge properties. Invokes the callback `fn(err)`,\r\n     * after which time if no exception has occurred the\r\n     * `req.session` property will be a new `Session` object,\r\n     * although representing the same session.\r\n     *\r\n     * @param {Function} fn\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    reload(fn){\r\n        const req = this.req\r\n        const store = this.req.sessionStore\r\n      \r\n        store.get(this.id, (err, sess) => {\r\n            if (err) return fn(err);\r\n            if (!sess) return fn(new Error('failed to load session'));\r\n            store.createSession(req, sess);\r\n            fn();\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destroy `this` session.\r\n     *\r\n     * @param {Function} fn\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    destroy(fn){\r\n        delete this.req.session;\r\n        this.req.sessionStore.destroy(this.id, fn);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Regenerate this request's session.\r\n     *\r\n     * @param {Function} fn\r\n     * @return {Session} for chaining\r\n     * @api public\r\n     */\r\n    regenerate(fn){\r\n        this.req.sessionStore.regenerate(this.req, fn);\r\n        return this;\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/session.ts",
    "type": "Constant",
    "value": "req",
    "snippet": "const req = this.req"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/session.ts",
    "type": "Constant",
    "value": "store",
    "snippet": "const store = this.req.sessionStore"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/packages/session/lib/store.ts",
    "type": "Class",
    "value": "Store",
    "snippet": "class Store extends EventEmitter {\r\n    constructor(private readonly options?: any){\r\n        super();\r\n    }\r\n\r\n    destroy(sessionId, callback){}\r\n\r\n    generateId(req){}\r\n\r\n    /**\r\n     * Re-generate the given requests's session.\r\n     *\r\n     * @param {IncomingRequest} req\r\n     * @return {Function} fn\r\n     * @api public\r\n     */\r\n    regenerate(req, fn){\r\n        this.destroy(req.sessionID, (err) => {\r\n            this.generate(req);\r\n            fn(err)\r\n        });\r\n    }\r\n\r\n    generate(req){\r\n        req.sessionID = this.generateId(req);\r\n        req.session = new Session(req);\r\n        req.session.cookie = new Cookie(this.options.cookieOptions);\r\n    \r\n        if (this.options.cookieOptions.secure === 'auto') {\r\n            req.session.cookie.secure = issecure(req, trustProxy);\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/clean.ts",
    "type": "Function",
    "value": "cleanOutput",
    "snippet": "function cleanOutput() {\n    return src(\n        [\n            `${source}/**/*.js`,\n            `${source}/**/*.d.ts`,\n            `${source}/**/*.js.map`,\n            `${source}/**/*.d.ts.map`,\n            `${source}/**/*.ts.map`,\n            `!${source}/**/globals.d.ts`,\n            `!${source}/**/*.config.js`,\n        ],\n        {\n            read: false,\n        },\n    ).pipe(clean({ force: true }));\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/clean.ts",
    "type": "Function",
    "value": "cleanDirs",
    "snippet": "function cleanDirs(done: () => void) {\n    deleteEmpty.sync(`${source}/`);\n    done();\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/copy-misc.ts",
    "type": "Function",
    "value": "copyMisc",
    "snippet": "function copyMisc(): NodeJS.ReadWriteStream {\r\n\tconst miscFiles = src(['Readme.md', 'LICENSE', '.npmignore']);\r\n\r\n\treturn packagePaths.reduce(\r\n\t\t(stream, packagePath) => stream.pipe(dest(packagePath)),\r\n\t\tmiscFiles,\r\n\t);\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/copy-misc.ts",
    "type": "Constant",
    "value": "miscFiles",
    "snippet": "const miscFiles = src(['Readme.md', 'LICENSE', '.npmignore']);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/move.ts",
    "type": "Constant",
    "value": "distFiles",
    "snippet": "const distFiles = src([\r\n\t'packages/**/*',\r\n\t'!packages/**/*.ts',\r\n\t'packages/**/*.d.ts',\r\n]);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/tasks/move.ts",
    "type": "Function",
    "value": "move",
    "snippet": "function move() {\r\n\treturn distFiles.pipe(dest('node_modules/@cmmv'));\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "isDirectory",
    "snippet": "function isDirectory(path: string) {\r\n    return statSync(path).isDirectory();\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "getFolders",
    "snippet": "function getFolders(dir: string) {\r\n    return readdirSync(dir).filter(file => isDirectory(join(dir, file)));\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "getDirs",
    "snippet": "function getDirs(base: string) {\r\n    return getFolders(base).map(path => `${base}/${path}`);\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-server/tools/gulp/util/task-helpers.ts",
    "type": "Function",
    "value": "containsPackageJson",
    "snippet": "function containsPackageJson(dir: string) {\r\n    return readdirSync(dir).some(file => file === 'package.json');\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/console/console.node.ts",
    "type": "Class",
    "value": "NodeConsole",
    "snippet": "@Node(\"cmmv.console\", \"console\")\r\nexport class NodeConsole extends NodeGraph {\r\n    @Input(\"string\")\r\n    public message: Property<string>;\r\n\r\n    @Exec()\r\n    public handlerExec(cxt: Blueprint, $args?: any[]) {\r\n        let message = this.getNodeParameter<string>(\"message\");\r\n        console.log(message);\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "metadata",
    "snippet": "const metadata = Object.assign({}, require(\"./crypto.node.json\"));"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Class",
    "value": "NodeCrypto",
    "snippet": "@Node(\"node.crypto\", \"crypto\")\r\nexport class NodeCrypto extends NodeGraph {\r\n    @Input(\"option\", \"hash\", metadata.actions)\r\n    public action: Property<string>;\r\n\r\n    @Input(\"option\", \"sha256\", metadata.types)\r\n    public type: Property<string>;\r\n\r\n    @Input(\"option\", \"hex\", metadata.encodings)\r\n    public encoding: Property<string>;\r\n\r\n    @Input(\"int32\", 32, null, true)\r\n    public stringLength: Property<number>;\r\n\r\n    @Input(\"options\", \"uuid\", metadata.generateEncodingType, true)\r\n    public encodingType: Property<\"uuid\" | \"base64\" | \"buffer\">;\r\n\r\n    @Input(\"string\")\r\n    public value: Property<string>;\r\n\r\n    @Input(\"crypto.KeyLike\")\r\n    public privateKey: Property<crypto.KeyLike>;\r\n\r\n    @Output(\"string\")\r\n    public result: Property<string>;\r\n\r\n    @Exec()\r\n    public handlerExec(cxt: Blueprint, $args?: any[]) {\r\n        try{\r\n            const encoding = this.getNodeParameter<crypto.BinaryToTextEncoding>(\"encoding\");\r\n            const type = this.getNodeParameter<string>(\"type\");\r\n            const value = this.getNodeParameter<string>(\"value\");\r\n            const secret = this.getNodeParameter<string>(\"secret\");\r\n            const privateKey = this.getNodeParameter<crypto.KeyLike>(\"privateKey\");\r\n\r\n            switch(this.action.value){\r\n                case \"generate\": \r\n                    const encodingType = this.getNodeParameter<\"uuid\" | \"base64\" | \"string\">(\"encodingType\");\r\n\r\n                    if(encodingType === \"uuid\"){\r\n                        this.result.value = uuid();\r\n                    }\r\n                    else{\r\n                        const stringLength = this.getNodeParameter<number>(\"stringLength\");\r\n\r\n                        if(encodingType === \"base64\"){\r\n                            this.result.value = crypto.randomBytes(stringLength)\r\n                            .toString(encodingType as BufferEncoding)\r\n                            .replace(/\\W/g, '').slice(0, stringLength);\r\n                        }\r\n                        else{\r\n                            this.result.value = crypto.randomBytes(stringLength)\r\n                            .toString(encodingType as BufferEncoding)\r\n                            .slice(0, stringLength);\r\n                        }\r\n                    }\r\n                break;\r\n                case \"hash\": \r\n                    this.result.value = crypto.\r\n                    createHash(type)?.\r\n                    update(value).digest(encoding);\r\n                break;\r\n                case \"hmac\":\r\n                    this.result.value = crypto.\r\n                    createHmac(type, secret)?.\r\n                    update(value).digest(encoding);\r\n                break;\r\n                case \"sign\":\r\n                    const sign = crypto.createSign(type);\r\n                    sign.write(value);\r\n                    sign.end();\r\n\r\n                    this.result.value = sign.sign(privateKey, encoding);\r\n                break;\r\n            }\r\n\r\n            this.next?.execute(cxt, $args);\r\n        }\r\n        catch(e){\r\n            cxt.catch(e);\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "encoding",
    "snippet": "const encoding = this.getNodeParameter<crypto.BinaryToTextEncoding>(\"encoding\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = this.getNodeParameter<string>(\"type\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "value",
    "snippet": "const value = this.getNodeParameter<string>(\"value\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "secret",
    "snippet": "const secret = this.getNodeParameter<string>(\"secret\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "privateKey",
    "snippet": "const privateKey = this.getNodeParameter<crypto.KeyLike>(\"privateKey\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "encodingType",
    "snippet": "const encodingType = this.getNodeParameter<\"uuid\" | \"base64\" | \"string\">(\"encodingType\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "stringLength",
    "snippet": "const stringLength = this.getNodeParameter<number>(\"stringLength\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "sign",
    "snippet": "const sign = crypto.createSign(type);"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Class",
    "value": "NodeCryptoGenerateKey",
    "snippet": "@Node(\"node.crypto.generatekey\", \"rsa-generatekey\")\r\nexport class NodeCryptoGenerateKey extends NodeGraph {\r\n    @Input(\"option\", \"rsa\", metadata.keyTypes)\r\n    public type: Property<string>;\r\n\r\n    @Input(\"int32\", 1024, null, true)\r\n    public modulusLength: Property<number>;\r\n\r\n    @Input(\"int32\", 0x10001, null, true)\r\n    public publicExponent: Property<number>;\r\n\r\n    @Input(\"string\", \"RSA-PSS\", null, true)\r\n    public hashAlgorithm: Property<string>;\r\n\r\n    @Input(\"string\", undefined, null, true)\r\n    public mgf1HashAlgorithm: Property<string>;\r\n\r\n    @Input(\"string\", \"pkcs1\", null, true)\r\n    public publicKeyRSAEncodingType: Property<\"pkcs1\" | \"spki\">;\r\n\r\n    @Input(\"string\", \"pkcs1\", null, true)\r\n    public privateKeyRSAEncodingType: Property<\"pkcs1\" | \"pkcs8\">;\r\n\r\n    @Input(\"string\", undefined, null, true)\r\n    public privateKeyRSACipher: Property<string>;\r\n\r\n    @Input(\"string\", undefined, null, true)\r\n    public privateKeyRSAPassphrase: Property<string>;\r\n\r\n    @Output(\"publicKey\")\r\n    public publicKey: Property<string>;\r\n\r\n    @Output(\"privateKey\")\r\n    public privateKey: Property<string>;\r\n\r\n    @Exec()\r\n    public handlerExec(cxt: Blueprint, $args?: any[]) {\r\n        try{\r\n            const type = this.getNodeParameter<string>(\"type\");\r\n            const modulusLength = this.getNodeParameter<number>(\"modulusLength\");\r\n            const divisorLength = this.getNodeParameter<number>(\"divisorLength\");\r\n            const publicExponent = this.getNodeParameter<number>(\"publicExponent\");\r\n            const hashAlgorithm = this.getNodeParameter<string>(\"hashAlgorithm\");\r\n            const mgf1HashAlgorithm = this.getNodeParameter<string>(\"mgf1HashAlgorithm\");\r\n\r\n            //RSA\r\n            const privateKeyRSACipher = \r\n                this.getNodeParameter<string>(\"privateKeyRSACipher\");\r\n            const privateKeyRSAPassphrase = \r\n                this.getNodeParameter<string>(\"privateKeyRSAPassphrase\");\r\n\r\n            switch(type){\r\n                case \"rsa\":\r\n                    const publicKeyRSAEncodingType = \r\n                        this.getNodeParameter<\"pkcs1\" | \"spki\">(\"publicKeyRSAEncodingType\");\r\n                    const privateKeyRSAEncodingType = \r\n                        this.getNodeParameter<\"pkcs1\" | \"pkcs8\">(\"privateKeyRSAEncodingType\");\r\n                    \r\n                    const RSAKeys = crypto.generateKeyPairSync(\"rsa\", {\r\n                        modulusLength,\r\n                        publicExponent,\r\n                        publicKeyEncoding: {\r\n                            type: publicKeyRSAEncodingType,\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: privateKeyRSAEncodingType,\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    }); \r\n            \r\n                    this.publicKey.value = RSAKeys.publicKey;\r\n                    this.privateKey.value = RSAKeys.privateKey;\r\n                break;\r\n                case \"rsa-pss\":\r\n                    const RSAPSSKeys = crypto.generateKeyPairSync(\"rsa-pss\", {\r\n                        modulusLength,\r\n                        publicExponent,\r\n                        hashAlgorithm,\r\n                        mgf1HashAlgorithm,\r\n                        publicKeyEncoding: {\r\n                            type: \"spki\",\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: \"pkcs8\",\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    }); \r\n            \r\n                    this.publicKey.value = RSAPSSKeys.publicKey;\r\n                    this.privateKey.value = RSAPSSKeys.privateKey;\r\n                break;\r\n                case \"dsa\":\r\n                    const DSAKeys = crypto.generateKeyPairSync(\"dsa\", {\r\n                        modulusLength,\r\n                        divisorLength,\r\n                        publicKeyEncoding: {\r\n                            type: \"spki\",\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: \"pkcs8\",\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    }); \r\n            \r\n                    this.publicKey.value = DSAKeys.publicKey;\r\n                    this.privateKey.value = DSAKeys.privateKey;\r\n                break;\r\n            }\r\n\r\n            this.next?.execute(cxt, $args);\r\n        }\r\n        catch(e){\r\n            cxt.catch(e);\r\n        }\r\n    }\r\n}"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "type",
    "snippet": "const type = this.getNodeParameter<string>(\"type\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "modulusLength",
    "snippet": "const modulusLength = this.getNodeParameter<number>(\"modulusLength\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "divisorLength",
    "snippet": "const divisorLength = this.getNodeParameter<number>(\"divisorLength\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "publicExponent",
    "snippet": "const publicExponent = this.getNodeParameter<number>(\"publicExponent\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "hashAlgorithm",
    "snippet": "const hashAlgorithm = this.getNodeParameter<string>(\"hashAlgorithm\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "mgf1HashAlgorithm",
    "snippet": "const mgf1HashAlgorithm = this.getNodeParameter<string>(\"mgf1HashAlgorithm\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "privateKeyRSACipher",
    "snippet": "const privateKeyRSACipher = \r\n                this.getNodeParameter<string>(\"privateKeyRSACipher\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "privateKeyRSAPassphrase",
    "snippet": "const privateKeyRSAPassphrase = \r\n                this.getNodeParameter<string>(\"privateKeyRSAPassphrase\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "publicKeyRSAEncodingType",
    "snippet": "const publicKeyRSAEncodingType = \r\n                        this.getNodeParameter<\"pkcs1\" | \"spki\">(\"publicKeyRSAEncodingType\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "privateKeyRSAEncodingType",
    "snippet": "const privateKeyRSAEncodingType = \r\n                        this.getNodeParameter<\"pkcs1\" | \"pkcs8\">(\"privateKeyRSAEncodingType\");"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "RSAKeys",
    "snippet": "const RSAKeys = crypto.generateKeyPairSync(\"rsa\", {\r\n                        modulusLength,\r\n                        publicExponent,\r\n                        publicKeyEncoding: {\r\n                            type: publicKeyRSAEncodingType,\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: privateKeyRSAEncodingType,\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "RSAPSSKeys",
    "snippet": "const RSAPSSKeys = crypto.generateKeyPairSync(\"rsa-pss\", {\r\n                        modulusLength,\r\n                        publicExponent,\r\n                        hashAlgorithm,\r\n                        mgf1HashAlgorithm,\r\n                        publicKeyEncoding: {\r\n                            type: \"spki\",\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: \"pkcs8\",\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/crypto/crypto.node.ts",
    "type": "Constant",
    "value": "DSAKeys",
    "snippet": "const DSAKeys = crypto.generateKeyPairSync(\"dsa\", {\r\n                        modulusLength,\r\n                        divisorLength,\r\n                        publicKeyEncoding: {\r\n                            type: \"spki\",\r\n                            format: \"pem\",\r\n                        },\r\n                        privateKeyEncoding: {\r\n                            type: \"pkcs8\",\r\n                            format: 'pem',\r\n                            cipher: privateKeyRSACipher,\r\n                            passphrase: privateKeyRSAPassphrase\r\n                        },\r\n                    });"
  },
  {
    "filename": "/mnt/f/Node/cmmv-blueprint/packages/nodes/nodes-base/cron/cron.node.ts",
    "type": "Class",
    "value": "NodeCron",
    "snippet": "@Node(\"cmmv.cron\", \"cron\")\r\nexport class NodeCron extends NodeGraph {\r\n    @Input(\"int32\", 1)\r\n    public interval: Property<number>;\r\n\r\n    @Output(\"int32\")\r\n    public deltaTime: Property<number>;\r\n\r\n    @Exec()\r\n    public handlerExec(cxt: Blueprint, $args?: any[]) {\r\n        setInterval(() => {\r\n            this.deltaTime.value = new Date().getTime();\r\n            this.next?.execute(cxt, $args);\r\n        }, this.interval.value * 1000);\r\n    }\r\n}"
  }
]